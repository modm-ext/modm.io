{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#modm-a-barebone-embedded-library-generator","title":"modm: a barebone embedded library generator","text":"<p>modm (pronounced like dial-up \"modem\") is a toolbox for building custom C++23 libraries tailored to your embedded device. modm generates startup code, HALs and their implementations, communication protocols, drivers for external devices, and BSPs in a modular, customizable process that you can fine-tune to your needs.</p> <ul> <li>Install the toolchain and explore our examples.</li> <li>You can discover the modm library in more detail.</li> <li>Easily start your own completely custom project.</li> <li>Our CI checks every contribution for regressions.</li> <li>We care about testing modm.</li> <li>API reference is available here.</li> <li>We do quarterly releases with a curated changelog.</li> </ul> <p>This project also has a forum for discussions and a technical blog to document larger design concepts.</p> <ul> <li>You found a bug? Open up an issue, we don't bite.</li> <li>You have a question? We probably have an answer.</li> <li>You require a feature? Write it down to get things rolling.</li> <li>You want to contribute? Read the contribution guidelines and open a pull request.</li> </ul> <p>modm is optimized for the harsh requirements of the Eurobot competition, where our robots need to run reliably and completely autonomously for the game's 100 second duration. Our robots contain a lot of different microcontrollers, some without a lot of resources, so modm needs to fulfill a diverse set of objectives, like small code size with small memory consumption, predictable program flow, extreme portability.</p> <p>The library source code is licensed as MPLv2 with any external source code under compatible licenses (BSD, Apache2, MIT). So feel free to fork this project and adapt it to your needs. The only thing we ask of you is to contribute your changes back so everyone can benefit.</p> <p>Please clone modm recursively, you need all the submodules:</p> <pre><code>git clone --recurse-submodules --jobs 8 https://github.com/modm-io/modm.git\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Efficient and fast object-oriented C++23 API.</li> <li>Support for thousands of AVR and ARM Cortex-M microcontrollers from Microchip, STMicroelectronics and Raspberry Pi.</li> <li>Build system agnostic: Choose SCons, CMake, Makefile or use your own.</li> <li>Modular, data-driven, target-specific HAL generation using the lbuild code generator.</li> <li>No memory allocations in HAL with very low overall RAM consumption.</li> <li>Highly configurable modules with sensible defaults and lots of documentation.</li> <li>Cross-platform peripheral interfaces incl. bit banging:<ul> <li>GPIO, External Interrupt and IO expanders.</li> <li>ADC, DAC and Comparators.</li> <li>UART, I<sup>2</sup>C, SPI, CAN and Ethernet.</li> </ul> </li> <li>Interfaces and drivers for many external I<sup>2</sup>C and SPI sensors and devices.</li> <li>Debug/logging system with IOStream and printf interface.</li> <li>Cooperative, stackful fibers and scheduler.</li> <li>Functional (partial) libstdc++ implementation for AVRs.</li> <li>Useful filter, interpolation and geometric algorithms.</li> <li>Lightweight unit testing system (suitable for AVRs).</li> <li>Hundreds of tests to ensure correct functionality.</li> <li>Integration of useful third-party software:<ul> <li>FreeRTOS and FreeRTOS+TCP operating system.</li> <li>CMSIS and CMSIS-DSP interfaces.</li> <li>ETL: Embedded Template Library.</li> <li>TinyUSB: USB Host/Device stack.</li> <li>FatFS: FAT/exFAT filesystem.</li> <li>ROSserial: Embedded ROS client.</li> <li>CrashCatcher: Crash reports for HardFaults.</li> <li>printf: Small printf implementation.</li> <li>Nanopb: Embedded Protocol Buffers.</li> <li>LVGL: Embedded Graphics Library.</li> <li>RTT: Segger Real-Time Transport.</li> </ul> </li> </ul>"},{"location":"#microcontrollers","title":"Microcontrollers","text":"<p>modm can create a HAL for 3887 devices of these vendors:</p> <ul> <li>STMicroelectronics STM32: 3082 devices.</li> <li>Microchip SAM: 416 devices.</li> <li>Microchip AVR: 388 devices.</li> <li>Raspberry Pi: 1 device.</li> </ul> <p>Here is a table with all device families and the peripheral drivers they support:</p> <ul> <li>\u2705 Implemented as a software driver in modm.</li> <li>\u25cb Available in hardware but missing a software driver in modm.</li> <li>\u2715 Unavailable in hardware or device with that peripheral not supported by modm.</li> </ul> <p>Note that this is a summary overview and your specific device may not have all the peripherals in this table. Please discover modm's peripheral drivers for your specific device.</p> STM32 SAM RP AT Peripheral C0 F0 F1 F2 F3 F4 F7 G0 G4 H7 L0 L1 L4 L5 U5 D1xD2xDAx D5xE5x E7xS7xV7x G5x 20 90 Mega Tiny ADC \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u2705 \u2705 \u2705 \u25cb \u25cb \u25cb \u2705 \u2705 \u2705 \u25cb \u2705 \u2705 CAN \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2715 \u2715 \u2705 \u2705 \u2705 \u2715 \u25cb \u2705 \u2715 \u2715 \u25cb \u25cb \u2715 Comparator \u2715 \u25cb \u2715 \u2715 \u2705 \u2715 \u2715 \u2705 \u2705 \u25cb \u25cb \u25cb \u2705 \u25cb \u25cb \u25cb \u25cb \u25cb \u2715 \u2715 \u25cb \u25cb \u25cb DAC \u2715 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u25cb \u2705 \u2715 \u2715 \u2715 \u25cb \u2715 DMA \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u25cb \u25cb \u2705 \u2715 \u2705 \u2715 \u2715 \u2715 Ethernet \u2715 \u2715 \u25cb \u25cb \u2715 \u2705 \u2705 \u2715 \u2715 \u25cb \u2715 \u2715 \u2715 \u2715 \u2715 \u2715 \u25cb \u25cb \u2715 \u2715 \u2715 \u2715 \u2715 External Interrupt \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u25cb \u25cb \u2705 \u2705 \u2705 \u2705 External Memory \u2715 \u2715 \u2705 \u2705 \u2715 \u2705 \u25cb \u2715 \u25cb \u25cb \u2715 \u2715 \u25cb \u25cb \u25cb \u2715 \u2715 \u25cb \u2715 \u2715 \u2715 \u2715 \u2715 GPIO \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 I<sup>2</sup>C \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u25cb \u2705 \u25cb \u2705 \u2705 \u2705 \u2705 Internal Flash \u25cb \u25cb \u2705 \u25cb \u25cb \u2705 \u25cb \u2705 \u2705 \u25cb \u25cb \u25cb \u25cb \u25cb \u25cb \u25cb \u25cb \u25cb \u25cb \u2715 \u2715 \u2715 \u2715 IWDG \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2715 \u2715 \u2715 \u2715 \u2715 \u2715 \u2715 \u2715 Random Generator \u2715 \u2715 \u2715 \u2705 \u2715 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2715 \u2705 \u2705 \u2705 \u2715 \u25cb \u25cb \u2715 \u2715 \u2715 \u2715 \u2715 RTC \u2705 \u2705 \u25cb \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u25cb \u25cb \u25cb \u25cb \u2715 \u2715 \u2715 SPI \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u25cb \u25cb \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 System Clock \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2715 \u2715 \u2715 Timer \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u25cb \u2705 \u2705 \u25cb \u25cb \u25cb \u25cb UART \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb Unique ID \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2715 \u2715 \u2715 \u2715 \u2715 \u2715 \u2715 \u2715 USB \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2715 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u2705 \u2705 \u2715 \u2715 \u2715 <p>We are only a small team of developers and are limited in the amount of devices we can support and test in hardware. Open a discussion to ask if your specific device is supported out-of-the-box and how you can add it otherwise.</p>"},{"location":"#boards","title":"Boards","text":"<p>We have out-of-box support for many development boards including documentation.</p> AL-AVREB-CAN Arduino NANO Arduino UNO Black Pill F103 Black Pill F401 Black Pill F411 Blue Pill F103 DEVEBOX-STM32F4XX DEVEBOX-STM32H750VB DISCO-F051R8 DISCO-F072RB DISCO-F100RB DISCO-F303VC DISCO-F401VC DISCO-F407VG DISCO-F411VE DISCO-F429ZI DISCO-F469NI DISCO-F723IE DISCO-F746NG DISCO-F769NI DISCO-L152RC DISCO-L476VG FEATHER-M0 FEATHER-M4 FEATHER-RP2040 MEGA-2560-PRO NUCLEO-C031C6 NUCLEO-F031K6 NUCLEO-F042K6 NUCLEO-F072RB NUCLEO-F091RC NUCLEO-F103RB NUCLEO-F303K8 NUCLEO-F303RE NUCLEO-F334R8 NUCLEO-F401RE NUCLEO-F411RE NUCLEO-F429ZI NUCLEO-F439ZI NUCLEO-F446RE NUCLEO-F446ZE NUCLEO-F746ZG NUCLEO-F767ZI NUCLEO-G070RB NUCLEO-G071RB NUCLEO-G431KB NUCLEO-G431RB NUCLEO-G474RE NUCLEO-H723ZG NUCLEO-H743ZI NUCLEO-L031K6 NUCLEO-L053R8 NUCLEO-L152RE NUCLEO-L432KC NUCLEO-L452RE NUCLEO-L476RG NUCLEO-L496ZG-P NUCLEO-L552ZE-Q NUCLEO-U575ZI-Q OLIMEXINO-STM32 Raspberry Pi Pico SAMD21-MINI SAMD21-XPLAINED-PRO SAME54-XPLAINED-PRO SAME70-XPLAINED SAMG55-XPLAINED-PRO SAMV71-XPLAINED-ULTRA Smart Response XE STM32-F4VE STM32F030-DEMO THINGPLUS-RP2040 WEACT-C011F6"},{"location":"#drivers","title":"Drivers","text":"<p>We also have a number of completely target-independent drivers for external devices connected via I<sup>2</sup>C, SPI, UART, BitBang, etc. Most of these also give you access to the entire device so you can easily configure them for your specific needs.</p> AD7280A AD7928 ADIS16470 ADNS9800 ADS101X ADS7828 ADS7843 ADS816x AMS5915 APA102 AS5047 AS5600 AT24MAC402 SPI Flash BME280 BMI088 BMP085 BNO055 CAT24AA CYCLE-COUNTER DRV832X DS1302 DS1631 DS18B20 DW3110 EA-DOG Encoder Input Encoder Input BitBang Encoder Output BitBang FT245 FT6x06 Gpio Sampler HCLAx HD44780 HMC58x HMC6343 HX711 I2C-EEPROM ILI9341 IS31FL3733 ITG3200 IXM42XXX L3GD20 LAN8720A LAWICEL LIS302DL LIS3DSH LIS3MDL LM75 LP503x LSM303A LSM6DS33 LSM6DSO LTC2984 MAX31855 MAX31865 MAX6966 MAX7219 MCP23x17 MCP2515 MCP3008 MCP7941x MCP990X MMC5603 MS5611 MS5837 NOKIA5110 NRF24 TFT-DISPLAY PAT9125EL PCA8574 PCA9535 PCA9548A PCA9685 QMC5883L SH1106 SIEMENS-S65 SIEMENS-S75 SK6812 SK9822 SSD1306 ST7586S ST7789 STTS22H STUSB4500 SX1276 SX128X TCS3414 TCS3472 TLC594x TMP102 TMP12x TMP175 TOUCH2046 VL53L0 VL6180 WS2812"},{"location":"#examples","title":"Examples","text":"<p>We have a huge number of examples which are always up-to-date and compilable as enforced by our CI.</p> AVR: 1-wire/ds18b20 AVR: adc/basic AVR: adc/oversample AVR: app_can2usb AVR: assert AVR: block_device_mirror AVR: can/mcp2515 AVR: can/mcp2515_uart AVR: display/dogm128/benchmark AVR: display/dogm128/caged_ball AVR: display/dogm128/draw AVR: display/dogm128/image AVR: display/dogm128/text AVR: display/dogm128/touch AVR: display/dogm132 AVR: display/dogm163 AVR: display/hd44780 AVR: display/siemens_s65 AVR: fiber AVR: fiber_benchmark AVR: flash AVR: gpio/basic AVR: gpio/blinking AVR: gpio/button_group AVR: logger AVR: mega_pro AVR: ports AVR: pwm/pca9685 AVR: qmc5883l AVR: sab/master AVR: sab/slave AVR: timeout AVR: timer AVR: uart/basic AVR: uart/extended AVR: xpcc/receiver AVR: xpcc/sender Arduino NANO: color Arduino NANO: encoder_input_bitbang Arduino NANO: printf Arduino UNO: basic/analog_read_serial Arduino UNO: basic/blink Arduino UNO: basic/digital_read_serial Arduino UNO: basic/read_analog_voltage Black Pill F103: blink Black Pill F401: blink Black Pill F401: uart_freertos Black Pill F411: blink Black Pill F411: usbfatfs Blue Pill F103: adns_9800 Blue Pill F103: blink Blue Pill F103: can Blue Pill F103: encoder_input Blue Pill F103: encoder_input_bitbang Blue Pill F103: environment Blue Pill F103: flash Blue Pill F103: graphics Blue Pill F103: itm Blue Pill F103: servo_pwm Blue Pill F103: tlc594x Blue Pill F103: weight_scale_hx711 FEATHER-M4: blink FEATHER-M4: neopixel FEATHER-M4: usbserial FEATHER-RP2040: blink Generic: blinky Generic: delay Generic: etl Generic: fiber Generic: fiber_overflow Generic: i2c_multiplex Generic: ros/can_bridge Generic: ros/environment Generic: ros/sub_pub Generic: rtc Generic: rtc_ds1302 Generic: usb Linux: assert Linux: block_device/file Linux: block_device/mirror Linux: block_device/ram Linux: build_info Linux: can_debugger Linux: etl Linux: fiber Linux: git Linux: logger Linux: printf Linux: serial_interface Linux: static_serial_interface Linux: threads NUCLEO-C031C6: adc NUCLEO-C031C6: adc_sequence NUCLEO-C031C6: blink NUCLEO-C031C6: timer NUCLEO-F031K6: blink NUCLEO-F031K6: sk6812 NUCLEO-F042K6: adc NUCLEO-F042K6: blink NUCLEO-F042K6: lis3mdl NUCLEO-F042K6: lp503x NUCLEO-F042K6: lsm6ds33 NUCLEO-F042K6: ms5837 NUCLEO-F042K6: spi_dma NUCLEO-F042K6: tmp12x NUCLEO-F042K6: vector_table_ram NUCLEO-F072RB: blink NUCLEO-F072RB: iwdg NUCLEO-F091RC: blink NUCLEO-F103RB: blink NUCLEO-F103RB: hard_fault NUCLEO-F103RB: itm NUCLEO-F103RB: rtos NUCLEO-F103RB: stts22h NUCLEO-F103RB: undefined_irq NUCLEO-F303K8: blink NUCLEO-F303K8: rtos NUCLEO-F303RE: blink NUCLEO-F303RE: itm NUCLEO-F303RE: rtos NUCLEO-F303RE: spi_dma NUCLEO-F303RE: temperature_mcp990x NUCLEO-F334R8: blink NUCLEO-F401RE: adc_dma NUCLEO-F401RE: blink NUCLEO-F401RE: distance_vl53l0 NUCLEO-F401RE: dw3110-communication NUCLEO-F401RE: timer_register_count NUCLEO-F411RE: blink NUCLEO-F411RE: imu_bno055 NUCLEO-F411RE: radio/nrf24-basic-comm NUCLEO-F411RE: radio/nrf24-data NUCLEO-F411RE: radio/nrf24-phy-test NUCLEO-F411RE: radio/nrf24-scanner NUCLEO-F411RE: rtos NUCLEO-F411RE: sx1276_rx NUCLEO-F411RE: sx1276_tx NUCLEO-F411RE: ws2812b NUCLEO-F429ZI: adc_ads816x NUCLEO-F429ZI: blink NUCLEO-F429ZI: cmsis_dsp/bayes NUCLEO-F429ZI: cmsis_dsp/class_marks NUCLEO-F429ZI: cmsis_dsp/convolution NUCLEO-F429ZI: cmsis_dsp/dotproduct NUCLEO-F429ZI: cmsis_dsp/fft_bin NUCLEO-F429ZI: cmsis_dsp/fir NUCLEO-F429ZI: cmsis_dsp/graphic_equalizer NUCLEO-F429ZI: cmsis_dsp/linear_interp NUCLEO-F429ZI: cmsis_dsp/matrix NUCLEO-F429ZI: cmsis_dsp/signal_converge NUCLEO-F429ZI: cmsis_dsp/sin_cos NUCLEO-F429ZI: cmsis_dsp/svm NUCLEO-F429ZI: cmsis_dsp/variance NUCLEO-F429ZI: ethernet NUCLEO-F429ZI: freertos_static NUCLEO-F429ZI: imu_adis16470 NUCLEO-F429ZI: nanopb NUCLEO-F429ZI: pat9125el NUCLEO-F429ZI: rtc_mcp7941x NUCLEO-F429ZI: spi_flash NUCLEO-F429ZI: spi_flash_fatfs NUCLEO-F429ZI: spistack_flash NUCLEO-F429ZI: usb_freertos NUCLEO-F429ZI: usbfatfs NUCLEO-F439ZI: blink NUCLEO-F439ZI: spi_dma NUCLEO-F446RE: blink NUCLEO-F446RE: color NUCLEO-F446RE: flash NUCLEO-F446ZE: blink NUCLEO-F446ZE: dac_basic NUCLEO-F446ZE: dac_dma NUCLEO-F446ZE: usbserial NUCLEO-F746ZG: blink NUCLEO-F767ZI: blink NUCLEO-F767ZI: ethernet NUCLEO-F767ZI: freertos_blink NUCLEO-F767ZI: spi_dma NUCLEO-G070RB: adc_dma NUCLEO-G070RB: blink NUCLEO-G071RB: adc NUCLEO-G071RB: amnb NUCLEO-G071RB: apa102 NUCLEO-G071RB: blink NUCLEO-G071RB: custom_allocator NUCLEO-G071RB: flash NUCLEO-G071RB: matrix NUCLEO-G071RB: rtos NUCLEO-G431KB: blink NUCLEO-G431KB: flash NUCLEO-G431RB: blink NUCLEO-G431RB: flash NUCLEO-G474RE: adc_basic NUCLEO-G474RE: adc_sequence_dma NUCLEO-G474RE: ads101x NUCLEO-G474RE: ads7828 NUCLEO-G474RE: as5047 NUCLEO-G474RE: blink NUCLEO-G474RE: can NUCLEO-G474RE: dac_basic NUCLEO-G474RE: dac_dma NUCLEO-G474RE: fdcan NUCLEO-G474RE: flash NUCLEO-G474RE: flash_json NUCLEO-G474RE: imu_lsm6dso NUCLEO-G474RE: ixm42xxx NUCLEO-G474RE: ixm42xxx_fifo NUCLEO-G474RE: max31855 NUCLEO-G474RE: ms5611 NUCLEO-G474RE: servo_pwm NUCLEO-G474RE: sx128x_lora NUCLEO-G474RE: timer_input_capture NUCLEO-H723ZG: adc_injected_conversion NUCLEO-H723ZG: adc_simple NUCLEO-H723ZG: blink NUCLEO-H723ZG: bmi088/i2c NUCLEO-H723ZG: bmi088/spi NUCLEO-H723ZG: can NUCLEO-H723ZG: dac_dma NUCLEO-H743ZI: blink NUCLEO-L031K6: blink NUCLEO-L031K6: vector_table_ram NUCLEO-L053R8: blink NUCLEO-L152RE: blink NUCLEO-L432KC: blink NUCLEO-L432KC: comp NUCLEO-L432KC: gyroscope NUCLEO-L432KC: pwm NUCLEO-L432KC: pwm_advanced NUCLEO-L432KC: spi_dma NUCLEO-L432KC: uart_spi NUCLEO-L452RE: blink NUCLEO-L452RE: graphics_touch NUCLEO-L452RE: lvgl NUCLEO-L476RG: adc NUCLEO-L476RG: blink NUCLEO-L476RG: dac_dma NUCLEO-L476RG: i2c_test NUCLEO-L476RG: itm NUCLEO-L476RG: lvgl NUCLEO-L496ZG-P: blink NUCLEO-L552ZE-Q: adc_basic NUCLEO-L552ZE-Q: blink NUCLEO-L552ZE-Q: dac_dma NUCLEO-L552ZE-Q: freertos_blink NUCLEO-U575ZI-Q: blink OLIMEXINO-STM32: blink Raspberry Pi Pico: adc_simple Raspberry Pi Pico: blink Raspberry Pi Pico: fiber Raspberry Pi Pico: interrupt Raspberry Pi Pico: logger Raspberry Pi Pico: mcblink Raspberry Pi Pico: mclogger Raspberry Pi Pico: rtc_mcp7941x Raspberry Pi Pico: spi_dma Raspberry Pi Pico: st7789 SAMD21-XPLAINED-PRO: blink SAMD21-XPLAINED-PRO: usbserial SAMD: blink SAMD: interrupt SAMD: usbserial SAME54-XPLAINED-PRO: blink SAME54-XPLAINED-PRO: usbserial SAME70-XPLAINED: adc SAME70-XPLAINED: blink SAME70-XPLAINED: pwm SAME70-XPLAINED: timer SAMG55-XPLAINED-PRO: adc-uart SAMG55-XPLAINED-PRO: blink SAMG55-XPLAINED-PRO: spi-loopback SAMG55-XPLAINED-PRO: timer SAMG55-XPLAINED-PRO: usbserial SAMV71-XPLAINED-ULTRA: adc/dma SAMV71-XPLAINED-ULTRA: adc/multi-channel SAMV71-XPLAINED-ULTRA: adc/simple SAMV71-XPLAINED-ULTRA: blink SAMV71-XPLAINED-ULTRA: dac SAMV71-XPLAINED-ULTRA: dma/block_transfer SAMV71-XPLAINED-ULTRA: dma/linked_list_transfer SAMV71-XPLAINED-ULTRA: fdcan SAMV71-XPLAINED-ULTRA: i2c-eeprom/at24mac402 SAMV71-XPLAINED-ULTRA: i2c-eeprom/generic SAMV71-XPLAINED-ULTRA: mcp3008 SAMV71-XPLAINED-ULTRA: pwm SAMV71-XPLAINED-ULTRA: timer SAMV: blink STM32-F4VE: flash STM32-F4VE: gui STM32F0-DISCOVERY: blink STM32F030F4P6-DEMO-BOARD: adc STM32F030F4P6-DEMO-BOARD: blink STM32F072-DISCOVERY: blink STM32F072-DISCOVERY: can STM32F072-DISCOVERY: hard_fault STM32F072-DISCOVERY: rotation STM32F072-DISCOVERY: stusb4500 STM32F072-DISCOVERY: tmp102 STM32F072-DISCOVERY: uart STM32F072-DISCOVERY: unaligned_access STM32F1-DISCOVERY: blink STM32F3-DISCOVERY: accelerometer STM32F3-DISCOVERY: adc/continous STM32F3-DISCOVERY: adc/interrupt STM32F3-DISCOVERY: adc/simple STM32F3-DISCOVERY: blink STM32F3-DISCOVERY: can STM32F3-DISCOVERY: comp STM32F3-DISCOVERY: ft245 STM32F3-DISCOVERY: gdb STM32F3-DISCOVERY: rotation STM32F3-DISCOVERY: rtt STM32F3-DISCOVERY: timer/basic STM32F3-DISCOVERY: usb_dfu STM32F4-DISCOVERY: accelerometer STM32F4-DISCOVERY: adc/interrupt STM32F4-DISCOVERY: adc/oversample STM32F4-DISCOVERY: adc/simple STM32F4-DISCOVERY: app_uart_sniffer STM32F4-DISCOVERY: barometer_bmp085_bmp180 STM32F4-DISCOVERY: blink STM32F4-DISCOVERY: can STM32F4-DISCOVERY: can2 STM32F4-DISCOVERY: colour_tcs3414 STM32F4-DISCOVERY: display/hd44780 STM32F4-DISCOVERY: display/nokia_5110 STM32F4-DISCOVERY: display/ssd1306 STM32F4-DISCOVERY: distance_vl6180 STM32F4-DISCOVERY: encoder_output STM32F4-DISCOVERY: exti STM32F4-DISCOVERY: fpu STM32F4-DISCOVERY: fsmc STM32F4-DISCOVERY: led_matrix_display STM32F4-DISCOVERY: open407v-d/gui STM32F4-DISCOVERY: open407v-d/touchscreen STM32F4-DISCOVERY: pressure_ams5915 STM32F4-DISCOVERY: sab2 STM32F4-DISCOVERY: spi STM32F4-DISCOVERY: temperature_ltc2984 STM32F4-DISCOVERY: timer STM32F4-DISCOVERY: timer_test STM32F4-DISCOVERY: tmp102 STM32F4-DISCOVERY: uart STM32F4-DISCOVERY: uart_spi STM32F401-DISCOVERY: accelerometer STM32F401-DISCOVERY: blink STM32F401-DISCOVERY: gyroscope STM32F401-DISCOVERY: uart STM32F407VET6-DEVEBOX: blink STM32F407VET6-DEVEBOX: flash STM32F429-DISCOVERY: blink STM32F469-DISCOVERY: assert STM32F469-DISCOVERY: blink STM32F469-DISCOVERY: can STM32F469-DISCOVERY: display STM32F469-DISCOVERY: exceptions_rtti STM32F469-DISCOVERY: game_of_life STM32F469-DISCOVERY: hard_fault STM32F469-DISCOVERY: lvgl STM32F469-DISCOVERY: max31865 STM32F469-DISCOVERY: ports STM32F469-DISCOVERY: printf STM32F469-DISCOVERY: threadsafe_statics STM32F469-DISCOVERY: tlsf-allocator STM32F469-DISCOVERY: touchscreen STM32F746G-DISCOVERY: adc_ad7928 STM32F746G-DISCOVERY: blink STM32F746G-DISCOVERY: rtos STM32F746G-DISCOVERY: tmp102 STM32F769I-DISCOVERY: blink STM32F769I-DISCOVERY: dac_dma STM32H750VBT6-DEVEBOX: blink STM32L1-DISCOVERY: blink STM32L476-DISCOVERY: blink Smart Response XE: blink Smart Response XE: display THINGPLUS-RP2040: blink"},{"location":"how-modm-works/","title":"How modm works","text":"<p>modm is an umbrella project for a handful of stand-alone projects and acts as a curated toolbox for creating custom C++ libraries for embedded targets. Three of these projects form the heart of modm:</p> <ul> <li>modm-devices contains hardware descriptions like memories, peripherals and pins of many devices.</li> <li>modm provides configurable modules to translate this data into code, tests and documentation.</li> <li>lbuild links these two together using the Jinja2 template engine in Python to create a custom library for your target.</li> </ul> <p>As a developer you can use lbuild to explore the modm modules, configure them specifically for your targets and needs and generate a custom library. You can generate more than just code, in this example, lbuild also generates a build system which then compiles and links the application into a executable.</p> <p></p> <p>We've also put a lot of thought into modm-devices, about what data to extract, how to format and store it. We automated the entire process to get the high quality data we use to build our library. You can read all about modm-devices in this blog post.</p>"},{"location":"how-modm-works/#modm-is-highly-modular","title":"modm is highly modular","text":"<p>modm's modules are kept small in scope on purpose and declare their dependencies, so that lbuild can build a minimal library from the initial modules you specified. So if you only want to use our UART drivers for example, lbuild will only include code from that module and its dependencies. This makes it easier to understand what parts of modm you actually use, either by looking at the dependency graph before, or by inspecting the generated code after calling lbuild, and gives you the opportunity to only use the parts of modm you really like.</p> <p></p> <p>A lbuild module is just a few lines of Python code. Here we can see the code for the <code>modm:platform:uart</code> module from the example above. It declares its name, its dependencies and then which files it wants to generate where to using the data from modm-devices, by just setting the <code>env.substitutions</code> to the device's properties and calling <code>env.template</code> with the input and output file names.</p> <pre><code>def init(module):\n    module.name = \":platform:uart\"\n    module.description = \"UART driver\"\n\ndef prepare(module, options):\n    module.depends(\":architecture:interrupt\", \":architecture:register\",\n                   \":architecture:atomic\", \":architecture:uart\", \":platform:gpio\")\n    return True\n\ndef build(env):\n    device = env[\":target\"]\n    env.substitutions = device.properties\n    env.outbasepath = \"src/modm/platform/uart\"\n    for instance in device.get_driver(\"uart:stm32*\")[\"instance\"]:\n        env.template(\"uart.hpp.in\", \"uart_{}.hpp\".format(instance))\n        env.template(\"uart.cpp.in\", \"uart_{}.cpp\".format(instance))\n</code></pre> <p>The input template then can access all the devices properties, and generate the correct code for this device. Here the template on left is passed to the Jinja2 engine which outputs the code on the right.</p> <pre><code>void {{ name }}::write(uint8_t data)\n{\n%% if \"extended\" in driver[\"type\"]\n    {{ peripheral }}-&gt;TDR = data;\n%% else\n    {{ peripheral }}-&gt;DR = data;\n%% endif\n}\n</code></pre> <pre><code>void Uart4::write(uint8_t data)\n{\n    UART4-&gt;DR = data;\n}\n</code></pre> <p>This example is simple, but since it's based on Python, anything more complicated is possible. Looking at the data excerpt from a STM32 device the above module will generate a only three classes of this type for this target. However, a similar driver will generate classes for the four USART peripherals.</p> <pre><code>...\n&lt;driver name=\"uart\" type=\"stm32\"&gt;\n  &lt;instance value=\"4\"/&gt;\n  &lt;instance value=\"5\"/&gt;\n  &lt;instance value=\"7\"/&gt;\n&lt;/driver&gt;\n&lt;driver name=\"usart\" type=\"stm32\"&gt;\n  &lt;instance value=\"1\"/&gt;\n  &lt;instance value=\"2\"/&gt;\n  &lt;instance value=\"3\"/&gt;\n  &lt;instance value=\"6\"/&gt;\n&lt;/driver&gt;\n...\n</code></pre> <p>With these techiques we can generate a target specific HAL for hundreds of devices.</p>"},{"location":"how-modm-works/#modm-asserts-at-compile-time","title":"modm asserts at compile-time","text":"<p>modm stands out for its extensive use of generated static C++ (template) classes. Consider this data from the GPIO peripheral, which shows the signal map for the <code>PA0</code> pin on a STM32 device.</p> <pre><code>...\n&lt;driver name=\"gpio\" type=\"stm32\"&gt;\n  &lt;gpio port=\"a\" pin=\"0\"&gt;\n    &lt;signal driver=\"adc\" instance=\"1\" name=\"in0\"/&gt;\n    &lt;signal driver=\"adc\" instance=\"2\" name=\"in0\"/&gt;\n    &lt;signal driver=\"adc\" instance=\"3\" name=\"in0\"/&gt;\n    &lt;signal af=\"1\" driver=\"tim\" instance=\"2\" name=\"ch1\"/&gt;\n    &lt;signal af=\"2\" driver=\"tim\" instance=\"5\" name=\"ch1\"/&gt;\n    &lt;signal af=\"8\" driver=\"uart\" instance=\"4\" name=\"tx\"/&gt;\n    ...\n</code></pre> <p>We use this data in the <code>modm:platform:gpio</code> module to generate type-safe signal connections, which will then assert that the signal you want to connect actually exists on this pin and even gives you a helpful (!) error message at compile time.</p> <pre><code>class GpioA0\n{\n...\n    template&lt; Peripheral peripheral &gt;\n    struct Tx {\n        static_assert(\n            (peripheral == Peripheral::Uart4),\n            \"GpioA0::Tx only connects to Uart4!\");\n    };\n    template&lt; Peripheral peripheral &gt;\n    struct Ch1 {\n        static_assert(\n            (peripheral == Peripheral::Tim2) ||\n            (peripheral == Peripheral::Tim5),\n            \"GpioA0::Ch1 only connects to Tim2 or Tim5!\");\n    };\n    template&lt; Peripheral peripheral &gt;\n    struct In0 {\n        static_assert(\n            (peripheral == Peripheral::Adc1) ||\n            (peripheral == Peripheral::Adc2) ||\n            (peripheral == Peripheral::Adc3),\n            \"GpioA0::In0 only connects to Adc1 or Adc2 or Adc3!\");\n    };\n...\n};\n</code></pre> <p>Continuing with this technique, we can even check if your signal groups are conflict free of overlaps or invalid configurations and again give you a helpful error message!</p> <pre><code>Uart4::connect&lt;GpioA0::Tx&gt;();\nAdc1::connect&lt;GpioA0::In0, GpioA1::In1&gt;();\nTim2::connect&lt;GpioA0::Ch1, GpioA1::Ch2,\n              GpioA2::Ch3, GpioA3::Ch4&gt;();\nTim5::connect&lt;GpioA0::Ch1, GpioA1::Ch2,\n              GpioA2::Ch3, GpioA3::Ch4&gt;();\n</code></pre> <pre><code>Maps to GpioA0::setAlternateFunction(8);\nMaps to GpioAx::setAnalogInput();\nEach pin in group called with their\n    respective Alternate Function ID\nSame API, but for Timer5 different\n    Alternate Function IDs are used\n</code></pre> <pre><code>Uart4::connect&lt;GpioA0::Rx&gt;();\n</code></pre> <pre><code>error: 'Rx' is not a member of 'GpioA0'\n</code></pre> <pre><code>Uart4::connect&lt;GpioA2::Tx&gt;();\n</code></pre> <pre><code>error: GpioA2::Tx only connects to Usart2!\n</code></pre> <pre><code>Usart1::connect&lt;GpioA9::Tx, GpioB7::Rx&gt;();\n</code></pre> <pre><code>error: This pin set contains conflicting remap groups!\nAvailable groups for Usart1 are:\n Usart1 | 0  | 1\n--------|----|----\n   A9   | Tx |\n  A10   | Rx |\n   B6   |    | Tx\n   B7   |    | Rx\n</code></pre> <p>We use a similar technique to compute baudrates at compile time and make sure the resulting baudrates remains within the specified error tolerances. In addition the executable now only contains prescaler values which are written directly to the hardware without any computation required. This is very helpful for keeping code size in check on very resource constrained targets, like the AVRs.</p> <pre><code>Uart4::connect&lt;GpioA0::Tx, GpioA1::Rx&gt;(Gpio::InputType::PullUp); // pull-up in RX pin\nUart4::initialize&lt;Board::SystemClock, 115'200_Bd&gt;(); // Within 1% default tolerance\nUart4::initialize&lt;Board::SystemClock, 115.2_kBd, 0_pct&gt;();\n// error: The closest available baudrate exceeds the tolerance of the requested baudrate!\n</code></pre>"},{"location":"how-modm-works/#modm-is-fast-and-usable","title":"modm is fast and usable","text":"<p>modm's APIs are kept simple and fast by splitting up functionality into separate, small, static functions, which implement the same behavior on all platforms. And with our code generation capabilities, we can hide the crazy implementation details of the hardware without compromising on performance. For example, on different AVRs, simple things like enabling the internal pull-up resistor, dealing with external interrupts or even just toggling a pin is done quite dissimilarly in hardware, yet we can wrap this in the same API for every target.</p> <p>Since we\u2018re using static inlined functions that often just compile to a handful of instructions  we can call our GPIOs at ludicrous speed.</p> <pre><code>// All pin functions follow a common naming scheme\nusing Led = GpioB1;\nLed::setOutput();\nLed::set(); Led::reset();\nLed::toggle();\nusing Button = GpioA0;\nButton::setInput();\nbool state = Button::read();\n\n// Depending on your targets, additional functions are available\nLed::setOutput(Gpio::OutputType::OpenDrain);\nButton::setInput(Gpio::InputType::PullUp);\n</code></pre> <p>You can use these GPIOs as building blocks for more complex drivers and peripherals and still maintain access speed without sacrificing usability:</p> <pre><code>// Create a hardware accelerated port of 4 bit width.\nusing Port4 = GpioPort&lt; GpioC0, 4 &gt;;        // MSB -&gt; C3, C2, C1, C0 &lt;- LSB\nusing ReadWrite = GpioC4;                   // \"name\" your GPIOs.\nusing Reset = GpioOutputC5;\nusing Enable = GpioOutputC6;\n\n// Build a super fast character display driver using these inlined GPIOs.\nmodm::Hd44780&lt;Port4, ReadWrite, Reset, Enable&gt; display;\ndisplay.initialize();   // driver knows to initialize for a 4 bit bus!\ndisplay &lt;&lt; \"Hello World!\" &lt;&lt; modm::endl;    // Yes, ostreams. Deal with it.\ndisplay.printf(\"You don't really have to use %s!\", \"OStreams\");\n</code></pre> <p>All drivers in modm follow the same principle of building up your hardware drivers from other parts of the HAL by passing them as template parameters. This works surprisingly well to reduce both code size and execution time. For example, here is how you assemble and initialize a driver for the MCP23x17 GPIO expander and then use its pins.</p> <pre><code>using Transport = modm::Mcp23TransportSpi&lt; SpiMaster1, GpioA0 &gt;;\nusing GpioExpander = modm::Mcp23x17&lt; Transport &gt;;\nGpioExpander expander;\n// Connect and initialize the peripherals\nSpiMaster1::connect&lt;GpioA0::Sck, GpioA1::Mosi, GpioA2::Miso&gt;();\nSpiMaster1::initialize&lt;Board::SystemClock, 1_MHz&gt;();\nexpander.initialize();\n// Bind the expander pins to a simpler name\nusing Pin0 = GpioExpander::P0&lt; expander &gt;;\nusing Pin1 = GpioExpander::P1&lt; expander &gt;;\n// Oh, look, same API\nPin0::setOutput();\nPin0::toggle();\nPin1::setInput();\nbool state = Pin1::read();\n</code></pre>"},{"location":"how-modm-works/#modm-is-memory-efficient","title":"modm is memory-efficient","text":"<p>Our HAL does not allocate memory dynamically \u2013 everything is either statically allocated or must explicitly be allocated by the user. This is a strong requirement for running modm on AVRs, which have little if any memory to spare for dynamic allocations.</p> <p>We took great care to make sure this constraint remains usable, making configuration options first-class citizens in lbuild for you to easily discover and safely change. When we do need to allocate static memory, we choose a sensible default size for its purpose.</p> <pre><code> $ lbuild discover-module-options\n...\nmodm:platform:cortex-m:main_stack_size = 3Ki  [256 .. 3Ki .. 64Ki]\n\n  Minimum size of the application main stack\n...\nmodm:platform:uart:1:buffer.rx = 16  [0 ... 64Ki-2]\nmodm:platform:uart:1:buffer.tx = 250  [0 ... 64Ki-2]\n</code></pre> <p>We transparently show you how much static memory your application is using, so you get an idea of how much certain functionality costs you in resources. This is the size of the accelerometer example on the STM32F4 discovery board:</p> <pre><code> $ cd examples/stm32f4_discovery/accelerometer\n $ scons\n...\nMemory usage\u00b7\u00b7\u00b7 build/stm32f4_discovery/accelerometer/project.elf\n\nProgram:    8144B (0.8% used)\n(.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern +\n .table.section_heap + .table.zero.intern + .text)\n\nData:       3496B (1.8% used) = 424B static (0.2%) + 3072B stack (1.6%)\n(.bss + .fastdata + .stack)\n\nHeap:     197240B (98.2% available)\n(.heap0 + .heap1 + .heap2 + .heap5)\n</code></pre>"},{"location":"how-modm-works/#modm-does-multitasking","title":"modm does multitasking","text":"<p>modm implements stackful, cooperative fibers and provides a concurrency support library based on the C++ interface. This enables you to split up your application into separate tasks, and use synchronous APIs in all of them, without sacrificing overall responsiveness. Here is an example of reading out the accelerometer:</p> <pre><code>// This accelerometer is connected via I2C.\nmodm::Lis3dsh&lt; modm::Lis3TransportI2c&lt; I2cMaster &gt; &gt; accelerometer;\nmodm::filter::MovingAverage&lt;float, 25&gt; averageX;\nmodm::filter::MovingAverage&lt;float, 25&gt; averageY;\nmodm::Fiber fiber_sensor([]\n{\n    // The driver does several I2C transfer here to initialize and configure the\n    // external sensor. The CPU is free to do other things while this happens though.\n    accelerometer.configure(accelerometer.Scale::G2);\n\n    while (true)\n    {\n        // More I2C transfers in the background\n        accelerometer.readAcceleration();\n\n        // smooth out the acceleration data a little bit\n        averageX.update(accelerometer.getData().getX());\n        averageY.update(accelerometer.getData().getY());\n\n        // set the boards LEDs depending on the acceleration values\n        LedUp::set(   averageX.getValue() &lt; -0.2);\n        LedDown::set( averageX.getValue() &gt;  0.2);\n        LedLeft::set( averageY.getValue() &lt; -0.2);\n        LedRight::set(averageY.getValue() &gt;  0.2);\n\n        // defer back to other fiber while this one sleeps\n        modm::this_fiber::sleep_for(5ms);\n    }\n});\n\nint main()\n{\n    Board::initialize();\n    modm::fiber::Scheduler::run();\n    return 0;\n}\n</code></pre>"},{"location":"who-we-are/","title":"Who we are","text":""},{"location":"who-we-are/#who-we-are","title":"Who we are","text":"<p>The modm project is maintained by Niklas Hauser (@salkinium), Raphael Lehmann (@rleh), and Christopher Durand (@chris-durand) with significant contributions from Sascha Schade (@strongly-typed), Fabian Greif (@dergraaf), Kevin L\u00e4ufer (@ekiwi), Martin Rosekeit (@thundernail), Daniel Krebs (@daniel-k), Georgi Grinshpun (@georgi-g), David Hebbeker (@dhebbeker), Thorsten Lajewski (@TheTh0r), Mike Wolfram (@mikewolfram), and many more contributors.</p>"},{"location":"who-we-are/#history-of-modm","title":"History of modm","text":"<p>In the mid-2000s the Roboterclub Aachen e.V. has developed a software library called XPCC for communication among components that are distributed on PCs and microcontrollers. This library was initially used only in autonomous robots for the Eurobot competition.</p> <p>In 2009, XPCC became a separate project and over the years grew from a communication library to a general purpose framework (called lowercase xpcc) suitable for all kinds of embedded applications, which made it quite messy.</p> <p>Between 2016 and 2018, Niklas and Fabian refactored xpcc into modm by completely rewriting the way the library generates its HAL. This also gave us the tools to fix some larger architectural issues in xpcc's HAL as well as significantly improve customizability of the HAL and its documentation. All xpcc authors agreed to relicense their contributions from BSD to MPLv2 in modm.</p>"},{"location":"who-we-are/#eurobot-and-team-rca","title":"Eurobot and Team RCA","text":"<p>Most of our contributors are or used to be members of the Roboterclub Aachen e.V.. We've been building robots for the Eurobot competition for many years now and all of them have been running xpcc or modm successfully as their only OS on dozens of different AVR and STM32 targets each. So modm is truly battle-tested in real-world conditions and has passed through the scrutiny of many capable engineers over the years.</p> <p>Check out how we're competing in the quarter finals of the Eurobot 2015 competition.</p>"},{"location":"guide/custom-project/","title":"Starting a new Project","text":"<p>The modm library explicitly generates and copies its files from inside the modm repository into your project using the lbuild code generator. It is intended and very strongly recommended to commit all generated files from <code>lbuild build</code> into your repository. This will make any changes very clear when you run <code>lbuild build</code> again with an updated version of modm!</p> <p>We recommend adding modm into your repository as a Git submodule so that you control exactly what version of modm you're using. We recommend you place the modm repository (and all other external code) into a folder called <code>ext/</code> or similiar:</p> <pre><code> $ git submodule add https://github.com/modm-io/modm.git ext/modm\n $ tree\n.\n\u2514\u2500\u2500 ext\n    \u2514\u2500\u2500 modm\n        \u251c\u2500\u2500 repo.lb\n       ...\n</code></pre> <p>Next you want to create a folder with a <code>project.xml</code> and a <code>main.cpp</code> file. We recommend you place that in a separate <code>app/</code> folder so that all your firmwares are in the same place:</p> <pre><code> $ tree\n.\n\u251c\u2500\u2500 ext\n\u2502   \u2514\u2500\u2500 modm\n\u2502       \u251c\u2500\u2500 repo.lb\n\u2502      ...\n\u2514\u2500\u2500 app\n    \u2514\u2500\u2500 project_name\n        \u251c\u2500\u2500 main.cpp\n        \u2514\u2500\u2500 project.xml\n</code></pre> <p>Place your applications into their own folder!</p> <p>All modm build systems search recursively for application sources inside the current folder. If you place the modm library repository into your application folder you will see build errors related to building sources twice:</p> <pre><code>scons: *** Multiple ways to build the same target were specified for: ...\n</code></pre> <p>The <code>project.xml</code> must contain the (relative) path to modm's <code>repo.lb</code> file. Note that the project name is inferred from the project folder, but you can easily change it. modm also does not add a build system by default, so you want to choose one at this point. Add the <code>modm:docs</code> module to generate custom API docs:</p> <pre><code>&lt;library&gt;\n  &lt;repositories&gt;\n    &lt;repository&gt;&lt;path&gt;../../ext/modm/repo.lb&lt;/path&gt;&lt;/repository&gt;\n  &lt;/repositories&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:build:project.name\"&gt;custom_name&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:build:scons&lt;/module&gt;\n    &lt;module&gt;modm:docs&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre> <p>You should now be able to discover modm from inside your project folder:</p> <pre><code> $ cd app/project_name\n $ lbuild discover\nParser(lbuild)\n\u2570\u2500\u2500 Repository(modm @ ../../ext/modm)   modm: a barebone embedded library generator\n    \u251c\u2500\u2500 Option(target) = REQUIRED in [stm32f469ngh6, stm32f469nih6, stm32f469vet6, ...\n   ...\n</code></pre> <p>Note that we've not yet declared the <code>modm:target</code> option, so you cannot discover all of modm yet. You can now choose from two levels of customization:</p> <ol> <li> <p>Inherit and extend a board support package from modm. This is particularly    useful if your project is based on an existing development board.</p> </li> <li> <p>Define your own <code>modm:target</code> option and required modules. This is necessary    for using modm on a custom hardware design.</p> </li> </ol>"},{"location":"guide/custom-project/#using-a-board-support-package","title":"Using a Board Support Package","text":"<p>Use lbuild to discover the specific BSP configuration you want to use. Some board configurations support different hardware revisions, so check your hardware to select the right one. For this example, we are going to use the DISCO-F469NI Rev B-03 board config.</p> <pre><code> $ lbuild discover\nParser(lbuild)\n\u2570\u2500\u2500 Repository(modm @ ../../ext/modm)   modm: a barebone embedded library generator\n    \u251c\u2500\u2500 Option(target) = REQUIRED in [stm32f469ngh6, stm32f469nih6, stm32f469vet6, ...\n    \u251c\u2500\u2500 Config(modm:disco-f469ni:b-03) in [b-01, b-03]   STM32F469IDISCOVERY\n   ...\n</code></pre> <p>Then inherit from this configuration in your <code>project.xml</code>. This will add the <code>modm:target</code> option and give you a set of modules that the BSP depends on. Note that you can overwrite any options you don't agree with, however, you cannot remove any inherited modules.</p> <pre><code>&lt;library&gt;\n  &lt;repositories&gt;...&lt;/repositories&gt;\n\n  &lt;extends&gt;modm:disco-f469ni:b-03&lt;/extends&gt;\n\n  &lt;options&gt;...&lt;/options&gt;\n  &lt;modules&gt;...&lt;/modules&gt;\n&lt;/library&gt;\n</code></pre> <p>You can now <code>lbuild discover</code> all of modm. Note that the selected modules are now marked underlined as a subtle hint.</p> <p>Our board support packages provide their configuration in the <code>Board</code> namespace, which you can use to initialize the target and several board subsystems. If a serial connection is available on the board, you can directly use the modm logging functions.</p> <p>A minimal <code>main.cpp</code> can look like this:</p> <pre><code>#include &lt;modm/board.hpp&gt;\n\nint main()\n{\n    Board::initialize();\n    Board::Leds::setOutput();\n\n    while (true)\n    {\n        Board::Leds::toggle();\n        modm::delay(Board::Button::read() ? 250ms : 500ms);\n#ifdef MODM_BOARD_HAS_LOGGER\n        static uint32_t counter(0);\n        MODM_LOG_INFO &lt;&lt; \"Loop counter: \" &lt;&lt; (counter++) &lt;&lt; modm::endl;\n#endif\n    }\n    return 0;\n}\n</code></pre> <p>You can find more details about the BSPs capabilities on docs.modm.io which contains the full API documentation for all BSPs. Alternatively you can generate your own API docs locally:</p> <pre><code>(cd modm/docs &amp;&amp; doxypress doxypress.json)\n# open modm/docs/html/index.html\n</code></pre> <p>Please note that the BSPs contain an opinionated set of pre-defined functionality and settings. This is great for getting started quickly, however, if you want to change some hardcoded things (like which UART to use for logging), it's better to use your own BSP:</p> <ol> <li> <p>Generate the BSP closest to your custom hardware, then copy the files from    <code>modm/src/modm/board/{name}</code> to your own project and modify them.</p> </li> <li> <p>In your <code>project.xml</code> remove the board config inheritance (<code>&lt;extends&gt;</code>) and    instead copy the pre-defined options into your own config.</p> </li> <li> <p>Check what modm modules you need to depend on and add them to your own    project (check for <code>module.depends(...)</code> in the BSPs <code>module.lb</code>).</p> </li> <li> <p>You may need to manually add the pre-defined collector values to your project    configuration    (check for <code>env.collect(...)</code> in the BSPs <code>module.lb</code>).</p> </li> </ol>"},{"location":"guide/custom-project/#custom-configuration","title":"Custom Configuration","text":"<p>For completely custom hardware, you start by defining the <code>modm:target</code> option and then adding the modules with their options as needed. For example, a basic configuration for the STM32F469NIH6 with startup, GPIO and clock modules looks like this:</p> <pre><code>&lt;library&gt;\n  &lt;repositories&gt;\n    &lt;repository&gt;&lt;path&gt;../../ext/modm/repo.lb&lt;/path&gt;&lt;/repository&gt;\n  &lt;/repositories&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f469nih6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:platform:clock&lt;/module&gt;\n    &lt;module&gt;modm:platform:core&lt;/module&gt;\n    &lt;module&gt;modm:platform:gpio&lt;/module&gt;\n    &lt;module&gt;modm:architecture:delay&lt;/module&gt;\n    &lt;module&gt;modm:build:scons&lt;/module&gt;\n    &lt;module&gt;modm:docs&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre> <p>Remember to include the <code>modm:docs</code> module, since you need to generate your own API docs from your specific configuration:</p> <pre><code>(cd modm/docs &amp;&amp; doxypress doxypress.json)\n# open modm/docs/html/index.html\n</code></pre> <p>A minimal <code>main.cpp</code> for this configuration can look like this. Since there is no BSP, you need to <code>#include &lt;modm/platform.hpp&gt;</code> and add the <code>modm::platform</code> namespace manually.</p> <pre><code>#include &lt;modm/platform.hpp&gt;\nusing namespace modm::platform;\nusing namespace std::chrono_literals;\n\nint main()\n{\n    GpioA0::setOutput();\n    while (true)\n    {\n        GpioA0::toggle();\n        modm::delay(0.5s);\n    }\n}\n</code></pre> <p>We recommend to start your custom projects with a known-good configuration from one of our examples and then work your way into your specialization.</p> <p>Visualize your dependencies</p> <p>You can create a dependency graph with <code>lbuild dependencies | dot -Tsvg -Grankdir=BT -o dependencies.svg</code> to help you understand what code is pulled in when you generate your library.</p>"},{"location":"guide/custom-project/#generate-compile-and-upload","title":"Generate, Compile and Upload","text":"<p>Once you have your <code>project.xml</code> set up, you can call <code>lbuild build</code>, which generates the target and configuration specific library from modm. This will create a few files and folders:</p> <pre><code> $ cd app/project_name\n $ ls\nmain.cpp    project.xml\n $ lbuild build\n $ ls\nSConstruct      main.cpp        modm            project.xml     project.xml.log\n</code></pre> <p>For this project we included the <code>modm:build:scons</code> generator, so we can just call <code>scons build</code>, which will compile the entire source code and output the resource consumption:</p> <pre><code> $ scons build -j8\nscons: Reading SConscript files ...\nscons: done reading SConscript files.\nscons: Building targets ...\nCompiling C++\u00b7\u00b7 build/main.o\n...\nIndexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/libmodm.a\nLinking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/project.elf\nMemory usage\u00b7\u00b7\u00b7 build/project.elf\n\nProgram:    3612B (0.3% used)\n(.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern +\n .table.section_heap + .table.zero.intern + .text)\n\nData:       3184B (1.6% used) = 144B static (0.1%) + 3040B stack (1.5%)\n(.bss + .fastdata + .stack)\n\nHeap:     197520B (98.4% available)\n(.heap0 + .heap1 + .heap2 + .heap5)\n</code></pre> <p>You can upload this firmware to your target by calling <code>scons program</code>.</p> <p>Additional tools are documented in the SCons module documentation.</p> <p>Enable parallel builds</p> <p>Remember to add the <code>-j8</code> flag to your <code>scons build</code> call to enable parallel builds, which are significantly faster than sequential builds. To make this permanent you can add <code>export SCONSFLAGS=\"-j8\"</code> or <code>export MAKEFLAGS=\"-j8\"</code> to your <code>.bashrc</code>!</p> <p>If you have any questions, open an issue or ping @salkinium.</p>"},{"location":"guide/discover/","title":"Discover modm","text":"<p>modm uses the lbuild code generator to discover available modules and their configuration options. Let's use the lbuild CLI to poke around modm!</p> <p>Make sure you've installed all tools required for building modm and you've cloned the modm repository recursively and change directory into modm:</p> <pre><code>git clone --recurse-submodules --jobs 8 https://github.com/modm-io/modm.git\ncd modm\n</code></pre> <p>lbuild operates on repositories which contain modules and options in a tree format. The <code>modm/repo.lb</code> file must be declared to find all modm modules:</p> <pre><code> $ lbuild --repository repo.lb discover\nParser(lbuild)\n\u2570\u2500\u2500 Repository(modm @ .)   modm: a barebone embedded library generator\n    \u251c\u2500\u2500 Option(target) = REQUIRED in [stm32f469ngh6, stm32f469nih6, stm32f469vet6, ...\n    \u251c\u2500\u2500 Config(modm:disco-f469ni:b-03) in [b-01, b-03]   STM32F469IDISCOVERY\n   ...\n</code></pre> <p>This gives you an overview of the repositories and their options and configurations. Here you can see the <code>modm:target</code> option is marked as REQUIRED, since the HAL modules obviously depend on the target device, so we need to discover the option in detail:</p> <pre><code> $ lbuild -r repo.lb discover modm:target\n&gt;&gt; modm:target  [TargetOption]\n\nMeta-HAL target device\n\nValue: REQUIRED\nInputs: [at90can128-16ai, at90can128-16au, at90can128-16mi, at90can128-16mu,\n         ... a really long list ...\n        stm32l4s9aii6, stm32l4s9vit6, stm32l4s9zij6, stm32l4s9zit6, stm32l4s9ziy6]\n</code></pre> <p>Options are checked</p> <p>lbuild checks all your project options against the possible values in the module and outputs an error if they are incorrect. Try passing a wrong value to see what happens.</p> <p>You can now choose a value for this repository option and discover the available modules for this specific target. We will choose the <code>stm32f469nih6</code> device:</p> <pre><code> $ lbuild -r repo.lb --option modm:target=stm32f469nih6 discover\nParser(lbuild)\n\u2570\u2500\u2500 Repository(modm @ .)   modm: a barebone embedded library generator\n    \u251c\u2500\u2500 Option(target) = stm32f469nih6 in [stm32f407vgt6, stm32f469nih6, ...\n    \u251c\u2500\u2500 Config(modm:disco-f469ni:b-03) in [b-01, b-03]   STM32F469IDISCOVERY\n   ...\n    \u251c\u2500\u2500 Module(modm:board)   Board Support Packages\n    \u2502   \u2570\u2500\u2500 Module(modm:board:disco-f469ni)   STM32F469IDISCOVERY\n   ...\n    \u251c\u2500\u2500 Module(modm:build)   Build System Generators\n    \u2502   \u251c\u2500\u2500 Option(build.path) = build/parent-folder in [String]\n    \u2502   \u251c\u2500\u2500 Option(project.name) = parent-folder in [String]\n    \u2502   \u2570\u2500\u2500 Module(modm:build:scons)  SCons Build Script Generator\n   ...\n    \u251c\u2500\u2500 Module(modm:platform)   Platform HAL\n    \u2502   \u251c\u2500\u2500 Module(modm:platform:cortex-m)   ARM Cortex-M Core\n    \u2502   \u2502   \u251c\u2500\u2500 Option(float-abi) = hard in [hard, soft, softfp]   Floating point ABI\n    \u2502   \u2502   \u251c\u2500\u2500 Option(main_stack_size) = 3Ki (3072) in [256 .. 3Ki .. 64Ki]\n    \u2502   \u2502   \u251c\u2500\u2500 Option(vector_table_location) = rom in [ram, rom]   Vector table location\n   ... ...\n    \u2502   \u251c\u2500\u2500 Module(modm:platform:uart)   Universal Asynchronous Receiver Transmitter (UART)\n    \u2502   \u2502   \u251c\u2500\u2500 Module(modm:platform:uart:1)   Instance 1\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 Option(buffer.rx) = 0 in [0 ... 64Ki-2]\n    \u2502   \u2502   \u2502   \u2570\u2500\u2500 Option(buffer.tx) = 0 in [0 ... 64Ki-2]\n</code></pre> <p>Since there are no more REQUIRED options, you can now discover all module and option descriptions. Let's have a look at the <code>modm:platform:cortex-m</code> module, which deals with the startup code of Cortex-M devices. Note that you can leave out parts of any name as long as it remains unique:</p> <pre><code> $ lbuild -r repo.lb -D :target=stm32f469nih6 discover ::cortex-m\n&gt;&gt; modm:platform:cortex-m  [Module]\n\n# ARM Cortex-M Core\n\nThis module generates the startup code, vector table, linkerscript as well as\ninitialize the heap, deal with assertions, provide blocking delay functions,\natomic and unaligned access and the GNU build ID.\n\n&gt;&gt;&gt;&gt; modm:platform:cortex-m:vector_table_location  [EnumerationOption]\n\n# Vector table location in ROM or RAM\n\nThe vector table is always stored in ROM and copied to RAM by the startup script\nif required. You can modify the RAM vector table using the CMSIS NVIC functions:\n\n- `void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)`\n- `uint32_t NVIC_GetVector(IRQn_Type IRQn)`\n\nValue: rom\nInputs: [ram, rom]\n</code></pre> <p>Once you've made your choices about which modules and options you want, you can generate a custom modm library using the build command:</p> <pre><code>lbuild -r repo.lb -D :target=stm32f469nih6 -D :::vector_table_location=ram \\\n    build --module ::cortex-m\n</code></pre> <p>Which will create a folder <code>modm</code> at the callsite which contains the minimal startup code for the STM32F469NIH6 device.</p> <pre><code> $ tree modm\nmodm\n\u251c\u2500\u2500 ext\n\u2502   \u2514\u2500\u2500 cmsis\n\u2502       \u2514\u2500\u2500 device\n\u2502           \u251c\u2500\u2500 stm32f469xx.h\n\u2502           \u2514\u2500\u2500 system_stm32f4xx.h\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 modm\n        \u251c\u2500\u2500 platform\n        \u2502   \u251c\u2500\u2500 core\n        \u2502   \u2502   \u251c\u2500\u2500 reset_handler.sx\n        \u2502   \u2502   \u251c\u2500\u2500 startup.c\n        \u2502   \u2502   \u2514\u2500\u2500 vectors.c\n        \u2502   \u2514\u2500\u2500 device.hpp\n        \u2514\u2500\u2500 platform.hpp\n</code></pre> <p>However, declaring everything on the command line is a bit annoying, so instead we can create a <code>project.xml</code> with the same information:</p> <pre><code>&lt;library&gt;\n\n  &lt;repositories&gt;\n    &lt;repository&gt;\n      &lt;path&gt;repo.lb&lt;/path&gt;\n    &lt;/repository&gt;\n  &lt;/repositories&gt;\n\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f469nih6&lt;/option&gt;\n    &lt;option name=\"modm:platform:cortex-m:vector_table_location\"&gt;ram&lt;/option&gt;\n  &lt;/options&gt;\n\n  &lt;modules&gt;\n    &lt;module&gt;modm:platform:cortex-m&lt;/module&gt;\n  &lt;/modules&gt;\n\n&lt;/library&gt;\n</code></pre> <p>This file is now automatically used for all calls to lbuild:</p> <pre><code>lbuild discover\nlbuild build\n</code></pre> <p>You can read the lbuild reference manual if you want to know the details about config inheritance, collectors and queries. You can discover the whole repository view with the <code>--developer</code> option:</p> <pre><code>lbuild discover --developer\n</code></pre>"},{"location":"guide/examples/","title":"Explore the Examples","text":"<p>To get a quick feel about modm's APIs you can look at and experiment with our examples, especially if you have a development board that modm supports out-of-box.</p> <p>Make sure you've installed all tools required for building modm and you've cloned the modm repository recursively:</p> <pre><code>git clone --recurse-submodules --jobs 8 https://github.com/modm-io/modm.git\n</code></pre>"},{"location":"guide/examples/#tldr","title":"TL;DR","text":"<p>Change directory into any of the examples and compile it:</p> <pre><code># cd into any example you like\ncd modm/examples/generic/blinky\n# generate modm library (call only once)\nlbuild build\n# compile the example\nscons -j8\n# Connect your development board and upload the firmware\nscons program\n</code></pre> <p>To debug with GDB in TUI mode. Make sure to change to the debug profile:</p> <pre><code># compile and upload debug profile\nscons program profile=debug\n# launch OpenOCD and GDB for debugging\nscons debug profile=debug\n</code></pre> <p>To generate your target specific Doxypress documentation:</p> <pre><code>(cd modm/docs &amp;&amp; doxypress doxypress.json)\n# open modm/docs/html/index.html\n</code></pre> <p>To remove it all:</p> <pre><code># Remove build artifacts\nscons -c\n# Remove generated files\nlbuild clean\n</code></pre> <p>Have a look at the build system documentation and the online documentation.</p>"},{"location":"guide/examples/#interesting-examples","title":"Interesting Examples","text":"<p>We have hundreds of examples but here are some of our favorite ones for our supported development boards:</p> <ul> <li>Arduino Uno: Blinky, Button &amp; Serial, Analog &amp; Serial.</li> <li>NUCLEO-F031K6: Blinky &amp; Serial.</li> <li>NUCLEO-F103RB: Blinky &amp; Serial, Undefined IRQ Handler, Logging via ITM.</li> <li>NUCLEO-F429ZI: CMSIS DSP.</li> <li>NUCLEO-F446RE: Internal Flash Programming.</li> <li>STM32F072 Discovery: Blinky, CAN, Gyroscope.</li> <li>STM32F3 Discovery: Blinky, CAN, Accelerometer, Gyroscope, TinyUSB DFU, Logging via RTT.</li> <li>STM32F4 Discovery: Blinky, CAN, Accelerometer, Timer &amp; LED Animations.</li> <li>STM32F469 Discovery: Blinky, Drawing on display, Touchscreen inputs, Multi-heap with external 16MB memory, Game of Life in Color with Multitouch, Hard Fault with CrashCatcher</li> <li>STM32F769 Discovery: FPU with double precision</li> </ul> <p>Here are some additional examples of displays and sensors we like:</p> <ul> <li>SSD1306 OLED display: Draws text and graphics onto I2C display.</li> <li>BMP085/BMP180 barometer: Reads atmospheric pressure and temperature from I2C sensor.</li> <li>BMP180/BME280 barometer: Reads atmospheric pressure and temperature from multiple I2C sensors.</li> <li>VL6180 time-of-flight distance sensor: Reads distance and ambient light from I2C sensor.</li> <li>VL53L0  time-of-flight distance sensor: Much improved version of the VL6180 sensor.</li> <li>ADNS9800 motion sensor: Reads 2D motion from SPI sensor used in gaming mice.</li> <li>TCS3414 color sensor: Reads RGB color from I2C sensor.</li> <li>HD44780 over I2C-GPIO expander: Draws text via native GPIO port or I2C-GPIO expander port onto character display.</li> </ul>"},{"location":"guide/examples/#copy-carefully","title":"Copy Carefully","text":"<p>When copying from our examples make sure to set the repository path correctly! All example <code>modm/examples/**/project.xml</code> files are missing this path, since we set it in the inherited base <code>modm/examples/lbuild.xml</code> configuration. You must also add the <code>modm:docs</code> module manually if you want it.</p> <p>The <code>modm/examples/lbuild.xml</code> file:</p> <pre><code>&lt;library&gt;\n  &lt;!-- This is the default lbuild configuration file for every\n       example in this folder. It only defaults the common settings,\n       so that this isn't duplicated in every single example.\n       When you write your own application, you must set this\n       path yourself! --&gt;\n  &lt;repositories&gt;\n    &lt;repository&gt;&lt;path&gt;../repo.lb&lt;/path&gt;&lt;/repository&gt;\n  &lt;/repositories&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:docs&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"guide/installation/","title":"Installation","text":"<p>This is the required software for generating, compiling and programming projects with modm:</p> <ul> <li>Python 3.</li> <li>Software Construct or CMake.</li> <li>Library Builder.</li> <li>AVR toolchain: avr-gcc and avrdude.</li> <li>ARM toolchain: toolchain-arm-xpack and OpenOCD (at least v0.12!).</li> <li>Optional: Doxypress.</li> <li>Optional: gdbgui for IDE-independent debugging.</li> </ul> <p>Note that the modm examples use the SCons build system by default, however, you are not required to use it. See the reference manual for additional build system documentation.</p> <p>Use GCC 13 or newer</p> <p>modm uses C++23, so you need at least GCC 13, we recommend GCC 14.</p> <p>Beware of AVRs</p> <p>We strongly discourage using AVRs for new designs, due to a significant lack of commitment from Atmel on keeping their AVR toolchain up-to-date.</p> <p>Check your Locale</p> <p>If you get a <code>UnicodeEncodeError</code> when calling <code>lbuild</code>, you may need to add <code>export LC_ALL=C.UTF-8</code> to your <code>.bashrc</code>. Consult the internet until <code>python3 -c \"import sys; print(sys.stdout.encoding)\"</code> returns <code>UTF-8</code>.</p> <p>Please help us keep these instructions up-to-date!</p>"},{"location":"guide/installation/#linux","title":"Linux","text":"<p>For Ubuntu 24.04LTS, these commands install the minimal build system:</p> <pre><code>sudo apt install python3 python3-pip scons git libncursesw6\npip3 install modm\n</code></pre> <p>We recommend using a graphical frontend for GDB called gdbgui:</p> <pre><code>pip3 install gdbgui\n</code></pre> <p>Python Packages in PATH</p> <p>The pip3 command installs executables into <code>~/.local/bin</code>, which must be added to PATH if it is not already the case. Add the following line to the end of your <code>~/.bashrc</code> file:</p> <pre><code>export PATH=\"$HOME/.local/bin:$PATH\"\n</code></pre> <p>We use Doxypress to generate the API documentation:</p> <pre><code>sudo mkdir /opt/doxypress\nwget -O- https://github.com/copperspice/doxypress/releases/download/dp-2.0.0/doxypress-2.0.0-ubuntu24.04-x64.tar.bz2 | sudo tar xj -C /opt/doxypress\n</code></pre> <p>Add the directory to your <code>PATH</code> variable in <code>~/.bashrc</code>:</p> <pre><code>export PATH=\"/opt/doxypress:$PATH\"\n</code></pre>"},{"location":"guide/installation/#arm-cortex-m","title":"ARM Cortex-M","text":"<p>Install the GNU toolchain for <code>arm-none-eabi</code> target in version 12 (or higher). If your Linux distribution provides up-to-date packages, we recommend using them. Otherwise, including Ubuntu 24.04, we recommend using the xPack GNU Arm Embedded GCC binary distribution:</p> <pre><code>wget -O- https://github.com/xpack-dev-tools/arm-none-eabi-gcc-xpack/releases/download/v14.2.1-1.1/xpack-arm-none-eabi-gcc-14.2.1-1.1-linux-x64.tar.gz | sudo tar xz -C /opt/\n</code></pre> <p>Add it to your <code>PATH</code> variable in <code>~/.bashrc</code>:</p> <pre><code>export PATH=\"/opt/xpack-arm-none-eabi-gcc-14.2.1-1.1/bin:$PATH\"\n</code></pre> <p>Install the OpenOCD tool:</p> <pre><code>sudo apt install openocd\n</code></pre> <p>OpenOCD &lt; v0.12</p> <p>Make sure to get at least OpenOCD release v0.12, since v0.11 is too old for some targets (STM32L5, STM32U5). You can manually install an up-to-date version of OpenOCD by following the instructions here.</p>"},{"location":"guide/installation/#microchip-avr","title":"Microchip AVR","text":"<p>Download and extract the pre-built AVR toolchain:</p> <pre><code>wget -O- https://github.com/modm-io/avr-gcc/releases/download/v14.2.0/modm-avr-gcc.tar.bz2 | sudo tar xj -C /opt\n</code></pre> <p>AVR toolchain install directory</p> <p>It is unfortunately not possible to install the AVR toolchain into a directory other than directly into <code>/opt</code>.</p> <p>Add the <code>bin</code> directory to your <code>PATH</code> variable in <code>~/.bashrc</code>:</p> <pre><code>export PATH=\"/opt/avr-gcc/bin:$PATH\"\n</code></pre> <p>Install the AvrDude tool:</p> <pre><code>sudo apt install avrdude\n</code></pre>"},{"location":"guide/installation/#hosted","title":"Hosted","text":"<p>To compile modm for host system targets (x86_64/arm64):</p> <pre><code>sudo apt install gcc build-essential libboost-all-dev\n</code></pre>"},{"location":"guide/installation/#macos","title":"macOS","text":"<p>Install the minimal build system via Homebrew:</p> <pre><code>brew update\nbrew install python3 scons git doxygen\npip3 install modm\n</code></pre> <p>Missing pyelftools</p> <p>If you get errors about missing <code>pyelftools</code> when calling <code>scons</code>, you may be using the system Python, rather than the Homebrew Python. In that case, you can add this line to your <code>.bashrc</code> or <code>.zshrc</code>:</p> <pre><code>alias scons=\"/usr/bin/env python3 $(which scons)\"\n</code></pre> <p>We recommend using a graphical frontend for GDB called gdbgui:</p> <pre><code>pip3 install gdbgui\n</code></pre> <p>We use Doxypress to generate the API documentation:</p> <pre><code>brew tap modm-ext/modm\nbrew install doxypress\n</code></pre>"},{"location":"guide/installation/#arm-cortex-m_1","title":"ARM Cortex-M","text":"<p>Install the pre-built ARM toolchain:</p> <pre><code>brew tap osx-cross/arm\nbrew install arm-gcc-bin@14 openocd\nbrew link --force arm-gcc-bin@14\n</code></pre> <p>To program Microchip SAM devices via the bootloader, install the <code>bossac</code> tool:</p> <pre><code>brew cask install bossa\n</code></pre>"},{"location":"guide/installation/#microchip-avr_1","title":"Microchip AVR","text":"<p>Install the AVR toolchain from source:</p> <pre><code>brew tap osx-cross/avr\nbrew install avr-gcc@14\nbrew link --force avr-gcc@14\n</code></pre>"},{"location":"guide/installation/#hosted_1","title":"Hosted","text":"<p>To compile modm for x86_64 macOS you need to install these tools too:</p> <pre><code>brew install boost gcc@14\n</code></pre>"},{"location":"guide/installation/#windows","title":"Windows","text":"<p>In general, Windows is not a great fit for the command line tools that modm is built on. Consider using the Windows subsystem for Linux 2 (WSL2) instead. Alternatively consider using a better terminal emulator than command prompt (<code>cmd</code>) or PowerShell, perhaps use the official Windows Terminal.</p> <p>Debugging with <code>arm-none-eabi-gdb</code></p> <p>We could not get <code>arm-none-eabi-gdb</code> to work on Windows, it seems not to support TUI mode and the web-based GDBGUI does not support Windows either. If you find a solution, please open a PR so we can fix this.</p> <p>These instructions assume a vanilla Windows 10 installation.</p> <p>Install Git via the official installer. Make sure to unselect vim as the default Git editor and instead choose at least the Wordpad editor or better.</p> <p>Install Python3 via the full installer. Make sure to select Add Python to PATH during installation!</p> <p>Test the installation by opening the command prompt (<code>cmd</code>):</p> <pre><code>python -c \"print('Hello World')\"\n</code></pre> <p>Then install the necessary Python packages:</p> <pre><code>pip install modm scons\n</code></pre> <p>Test that you have access to the <code>lbuild</code> and <code>scons</code> tools inside the command prompt:</p> <pre><code>lbuild --version\nscons --version\n</code></pre> <p>We use Doxypress to generate the API documentation. Download and run the Installer.</p> <p>Please use the free and open-source 7-Zip file archiver to extract the files in the next steps.</p>"},{"location":"guide/installation/#arm-cortex-m_2","title":"ARM Cortex-M","text":"<p>Install the pre-built ARM toolchain via the 64-bit installer and make sure you select Add path to environment variable at the end! Open a new command prompt to test the compiler:</p> <pre><code>arm-none-eabi-gcc --version\n</code></pre> <p>Install the  and then download the latest pre-built OpenOCD tool:</p> <p>Unpack the <code>.7z</code> file using <code>7-Zip &gt; Extract to \"OpenOCD-20240916...\"</code>.</p> <p>Then rename and move the extracted folder to <code>C:\\Program Files (x86)\\openocd</code>. Open PowerShell to add the <code>\\bin</code> folder to the <code>Path</code>:</p> <pre><code>[Environment]::SetEnvironmentVariable(\"Path\", $env:Path + \";C:\\Program Files (x86)\\openocd\\bin\", \"User\")\n</code></pre> <p>Close the PowerShell and open a new command prompt to test openocd:</p> <pre><code>openocd --version\n</code></pre>"},{"location":"guide/installation/#microchip-avr_2","title":"Microchip AVR","text":"<p>Download the pre-built AVR toolchain and unpack the <code>.zip</code> file using the context menu <code>7-Zip &gt; Extract to \"avr-gcc-14.2.0-...\"</code> Then rename and move the extracted folder to <code>C:\\Program Files\\avr-gcc</code>. Open PowerShell to add the <code>\\bin</code> folder to the <code>Path</code>:</p> <pre><code>[Environment]::SetEnvironmentVariable(\"Path\", $env:Path + \";C:\\Program Files\\avr-gcc\\bin\", \"User\")\n</code></pre> <p>Close the PowerShell and open a new command prompt to test avr-gcc and avrdude:</p> <pre><code>avr-gcc --version\navrdude --version\n</code></pre> <p>For non-English speakers</p> <p>For now project and build paths containing non-ASCII characters are not parsed correctly. Please open an issue if this is a problem.</p> <p>Windows paths</p> <p>Windows created several compatibility issues with its <code>\\</code> path separator. Even though we try hard to not hardcode the path separator, there may still be issues related to this. Please open an issue in that case.</p> <p>Dear Windows users</p> <p>We don't regularly use Windows with modm, so please give us some feedback about the quality of these instructions.</p>"},{"location":"guide/installation/#windows-with-wsl2","title":"Windows with WSL2","text":"<p>The Windows Subsystem for Linux 2 allows you to run a Linux distribution in parallel to Windows. For a pure Windows installation see above.</p> <p>Install Ubuntu-22.04 LTS as WSL2 distribution: See the general WSL doc, but as of this writing <code>wsl --list --online</code> will not list Ubuntu 22.04.1 LTS, but it is available in the Microsoft Store. Install it from there via mouse clicks. Make sure the WSL2 instance is running by opening a terminal via start menu.</p> <p>Physically attach your microcontroller development board or your debugger to a USB port and bridge the USB hub to which the device is attached. Also bridge the USB device to Linux using usbipd:</p> <pre><code>PS C:\\Windows\\system32&gt; usbipd wsl list\nBUSID  VID:PID    DEVICE                                STATE\n3-2    1bcf:0005  USB-Eingabeger\u00e4t                      Not attached\n3-3    0483:374b  ST-Link Debug, USB-...                Attached - Ubuntu-22.04\n4-1    138a:003d  Synaptics FP Sensors (WBF) (PID=003d) Not attached\n4-3    04f2:b370  HP HD Webcam [Fixed]                  Not attached\n</code></pre> <p>Check the BUSID parameter and use the one that corresponds to your device in further commands. In this example it is the <code>3-3</code>.</p> <pre><code>PS C:\\Windows\\system32&gt; usbipd wsl attach --busid 3-3\nusbipd: info: Using default distribution 'Ubuntu-22.04'.\n</code></pre> <p>Unreliable connection</p> <p>If the connection is not reliable, it might be necessary to detach/attach several times until the connection is established:</p> <pre><code>PS C:\\Windows\\system32&gt; usbipd wsl detach --busid 3-3\nPS C:\\Windows\\system32&gt; usbipd wsl attach --busid 3-3\nusbipd: info: Using default distribution 'Ubuntu-22.04'.\n</code></pre> <p>Either reboot the machine or be lucky that a combination of the following commands is sufficient:</p> <pre><code>sudo udevadm trigger\nsudo udevadm control --reload\n</code></pre> <p>Remove the USB connector, reattach it, then issue the command <code>usbipd wsl attach --busid 3-3</code>.</p> <p>On WSL2 Linux follow the Linux installation instructions and additionally install a terminal emulator such as picocom:</p> <pre><code>sudo apt install picocom\n</code></pre> <p>Explore the examples and compile and upload a suitable one with <code>scons program</code>. Try to debug it with GDB using <code>scons debug</code> and listen on the serial output:</p> <pre><code>picocom --baud 115200 --imap lfcrlf --echo /dev/ttyACM0\n</code></pre> <p>VSCode support</p> <p>You can also install the remote extensions for WSL and use the VSCode integrated terminal to access WSL2.</p>"},{"location":"reference/build-systems/","title":"Build Systems","text":"<p>For modm, build systems are not special and are treated as just another module that generates the build system configuration as part of your custom library.</p> <p>The required data for this is a list of generated files provided by lbuild itself, and lots of metadata like header include paths, compile flags, preprocessor definitions, libraries to be linked, that is collected from each module.</p> <p>This information is then assembled by the <code>modm:build</code> module which generates generic support files and data for providing compilation, uploading and debugging functionality.</p> <p>This alone is not enough to compile your project though, so you have to select one or more <code>modm:build:*</code> submodules, that translates this data for the specific build system.</p> <p>Build systems do not interoperate</p> <p>While you can generate and use multiple build systems at the same time, they do not have the same feature set and do not interoperate. So you cannot compile your program with one build system and expect to upload the firmware to your target with another.</p> <p>Add your build system</p> <p>Most of the difficult work is done by the <code>modm:build</code> module, so adding another build system generator is a manageable feat. Feel free to open up an PR that adds support for your build system and we'll give you lots of tips during the review.</p> <p>Enable parallel builds</p> <p>Remember to add the <code>-j8</code> flag to your <code>scons/make build</code> call to enable parallel builds, which are significantly faster than sequential builds. To make this a permanent setting you can add <code>export SCONSFLAGS=\"-j8\"</code> or <code>export MAKEFLAGS=\"-j8\"</code> to your <code>.bashrc</code>!</p>"},{"location":"reference/build-systems/#scons","title":"SCons","text":"<p>The <code>modm:build:scons</code> build system generator is our preferred and recommended one and features many very useful modm- and embedded-specific tools. However, it is more optimized for terminal use and not for integration into IDEs.</p> <p>See the <code>modm:build:scons</code> documentation.</p>"},{"location":"reference/build-systems/#make","title":"Make","text":"<p>The <code>modm:build:make</code> generator creates a stand-alone, but feature-complete, Makefile build system. The embedded-specific tooling is provided by wrapping separate Python3 scripts in <code>.PHONY</code> targets. It is intended as a simple, hackable build system without standardized IDE integration.</p> <p>See the <code>modm:build:make</code> documentation.</p>"},{"location":"reference/build-systems/#cmake","title":"CMake","text":"<p>The <code>modm:build:cmake</code> module generates a CMake build script, which you can import into a lot of IDEs and compile it from there.</p> <p>See the <code>modm:build:cmake</code> documentation.</p>"},{"location":"reference/build-systems/#customization","title":"Customization","text":"<p>All build system modules have many options, which you can set in your <code>project.xml</code> configuration file. However, there are also lbuild collectors, which are the mechanism used by the library modules themselves to communicate the required metadata to the build modules.</p> <p>You can specify additional collector values in your <code>project.xml</code> file to customize your build! For example, if you disagree with our compile flags you can extend them like so:</p> <pre><code>&lt;library&gt;\n  &lt;collectors&gt;\n    &lt;!-- Warn about strict ISO C and C++ usage --&gt;\n    &lt;collect name=\"modm:build:ccflags\"&gt;-Wpedantic&lt;/collect&gt;\n    &lt;!-- Don't warn about double promotion, I know what I'm doing (no, you don't) --&gt;\n    &lt;collect name=\"modm:build:ccflags\"&gt;-Wno-double-promotion&lt;/collect&gt;\n  &lt;/collectors&gt;\n&lt;/library&gt;\n</code></pre> <p>This can be significantly easier than manually editing the generated build scripts, and is also persistent across library regeneration. Please see the <code>modm:build</code> documentation for the available collectors and their inputs.</p>"},{"location":"reference/documentation/","title":"Documentation","text":"<p>Since modm is so highly configurable with its many options and selectable modules, it can generate wildly different code for different project configurations. However we've taken great care to keep modm discoverable by making documentation a first-class citizen of our code generation engine <code>lbuild</code>.</p> <p>modm's documentation is split into two parts:</p> <ol> <li>The module documentation available during library discovery via <code>lbuild discover</code>.</li> <li>The Doxygen API documentation available after generating the library with the    <code>modm:docs</code> module via <code>lbuild build</code>.</li> </ol>"},{"location":"reference/documentation/#modules","title":"Modules","text":"<p>The modm modules and their options are shown by <code>lbuild discover</code>. These descriptions advertise the modules capabilities and gives a high-level overview of how to use it.</p> <p>You can search for keywords in all modules using <code>lbuild search QUERIES [QUERIES ...]</code>:</p> <pre><code> $ lbuild search animation\nParser(lbuild)\n\u2570\u2500\u2500 Repository(modm @ ../../..)   modm: a barebone embedded library generator\n    \u2570\u2500\u2500 Module(modm:ui)   User interface\n        \u251c\u2500\u2500 Module(modm:ui:animation)   Animators\n        \u2570\u2500\u2500 Module(modm:ui:led)   LED Animation and Gamma Correction\n\n\n&gt;&gt; modm:ui  [Module]\n\n  4  Contains code for Graphics, Buttons, LEDs, Animations, Menu Structures.\n\n\n&gt;&gt; modm:ui:led  [Module]\n\n  1  # LED Animation and Gamma Correction\n  6  `modm:ui:animation` module and providing look-up tables for performing\n 12  wraps an 8-bit `modm::ui::Animation` and a 8-bit value.\n 38  Depending on how smooth you require your animation to be, you may call the\n 42  `modm::ui::KeyFrameAnimation` class and it's derivatives, to animate it's\n 83  use the `modm::ui::table22_16_256` table to map the linear LED animation values\n</code></pre> <p>To make discovery even easier we have created a superimposed view of all available modules on this homepage. Try searching for your keywords in the search bar above.</p> <p>Note that in this superimposed view, some Modules and Options are only available for certain targets. These are then labels as \"{Module, Option, Collector} only available for {target}\". Additionally the view does not show peripheral instance submodule to reduce visual noise.</p>"},{"location":"reference/documentation/#doxypress-doxygen","title":"Doxypress / Doxygen","text":"<p>The generated C/C++ API is documented using Doxypress and therefore only available after code generation.</p> <p>To view this documentation, include the <code>modm:docs</code> module in your <code>project.xml</code> configuration and run <code>lbuild build</code>. A <code>modm/docs</code> folder is created containing the <code>doxypress.json</code> for modm as well as all the <code>@defgroup</code>s mirroring the module structure.</p> <p>You must then run Doxypress manually, which can take several minutes, and compiles the target-specific documentation into <code>modm/docs/html</code>:</p> <pre><code>lbuild build -m \"modm:docs\"\n\n# With Doxypress\n(cd modm/docs &amp;&amp; doxypress doxypress.json)\n\n# then open: modm/docs/html/index.html\n</code></pre> <p>The generated Doxypress/Doxygen documentation contains the original module documentation including the option choices you made. This makes it easier to map the lbuild options to changes in the generated source code.</p>"},{"location":"reference/documentation/#online-api-docs","title":"Online API Docs","text":"<p>API documentation is available at docs.modm.io for a large and representative number of targets with all modules enabled.</p>"},{"location":"reference/targets/","title":"Supported Targets","text":"<p>modm supports a total of 3892 targets by setting the <code>modm:target</code> repository option with the device identifier string.</p> <p>This is the long string written on your microcontroller that uniquely identifies the target device for which to generate the modm HAL.</p> <p>You can optionally add the hardware revision to the identifier string by appending <code>/revX</code> where X is the revision. This can help modm apply workarounds for specific hardware bugs as recommended by the errata sheet.</p>"},{"location":"reference/targets/#hosted-os","title":"Hosted OS","text":"<p>The hosted targets are for compiling modm on an operating system, usually to run our unit tests locally or in the CI.</p> <p>Identifier format example for <code>Hosted-Linux</code>:</p> <pre><code>  hosted    linux\n{platform}-{family}\n</code></pre> <p><code>hosted-darwin</code>, <code>hosted-darwin-arm64</code>, <code>hosted-linux</code>, <code>hosted-linux-arm64</code>, <code>hosted-windows</code>.</p>"},{"location":"reference/targets/#microchip-avr","title":"Microchip AVR","text":"<p>Identifier format example for <code>ATmega328P-AU</code>: <pre><code>    avr     mega   328    p              au\n{platform}{family}{name}{type}-{speed}{package}\n</code></pre> Note that the platform is mapped to <code>avr</code> not <code>at</code> and that some AVRs have an optional device speed.</p> <p>Identifier format example for <code>AT90CAN128-16AU</code>: <pre><code>    avr      90    can   128     16      au\n{platform}{family}{type}{name}-{speed}{package}\n</code></pre> Note that the type and name are switched here to normalize the identifier schema.</p>"},{"location":"reference/targets/#at90can","title":"AT90CAN","text":"<p><code>at90can128-16ai</code>, <code>at90can128-16au</code>, <code>at90can128-16mi</code>, <code>at90can128-16mu</code>, <code>at90can32-16ai</code>, <code>at90can32-16au</code>, <code>at90can32-16mi</code>, <code>at90can32-16mu</code>, <code>at90can64-16ai</code>, <code>at90can64-16au</code>, <code>at90can64-16mi</code>, <code>at90can64-16mu</code>.</p>"},{"location":"reference/targets/#atmega","title":"ATmega","text":""},{"location":"reference/targets/#atmega128","title":"ATmega128","text":"<p><code>atmega128-16an</code>, <code>atmega128-16au</code>, <code>atmega128-16mn</code>, <code>atmega128-16mu</code>, <code>atmega128a-au</code>, <code>atmega128a-mu</code>, <code>atmega128l-8an</code>, <code>atmega128l-8au</code>, <code>atmega128l-8mn</code>, <code>atmega128l-8mu</code>, <code>atmega128rfa1-zf</code>, <code>atmega128rfa1-zfr</code>, <code>atmega128rfa1-zu</code>, <code>atmega128rfa1-zu00</code>, <code>atmega128rfa1-zur</code>, <code>atmega128rfa1-zur00</code>.</p>"},{"location":"reference/targets/#atmega1280","title":"ATmega1280","text":"<p><code>atmega1280-16au</code>, <code>atmega1280-16cu</code>, <code>atmega1280v-8au</code>, <code>atmega1280v-8cu</code>.</p>"},{"location":"reference/targets/#atmega1281","title":"ATmega1281","text":"<p><code>atmega1281-16au</code>, <code>atmega1281-16mu</code>, <code>atmega1281v-8au</code>, <code>atmega1281v-8mu</code>.</p>"},{"location":"reference/targets/#atmega1284","title":"ATmega1284","text":"<p><code>atmega1284-au</code>, <code>atmega1284-mu</code>, <code>atmega1284-pu</code>, <code>atmega1284p-an</code>, <code>atmega1284p-au</code>, <code>atmega1284p-mn</code>, <code>atmega1284p-mu</code>, <code>atmega1284p-pn</code>, <code>atmega1284p-pu</code>.</p>"},{"location":"reference/targets/#atmega16","title":"ATmega16","text":"<p><code>atmega16a-au</code>, <code>atmega16a-mu</code>, <code>atmega16a-pu</code>, <code>atmega16l-8au</code>, <code>atmega16l-8mu</code>, <code>atmega16l-8pu</code>.</p>"},{"location":"reference/targets/#atmega161","title":"ATmega161","text":"<p><code>atmega16-16au</code>, <code>atmega16-16mu</code>, <code>atmega16-16pu</code>.</p>"},{"location":"reference/targets/#atmega162","title":"ATmega162","text":"<p><code>atmega16u2-au</code>, <code>atmega16u2-mu</code>.</p>"},{"location":"reference/targets/#atmega164","title":"ATmega164","text":"<p><code>atmega164a-au</code>, <code>atmega164a-cu</code>, <code>atmega164a-mch</code>, <code>atmega164a-mu</code>, <code>atmega164a-pu</code>, <code>atmega164p-20an</code>, <code>atmega164p-20au</code>, <code>atmega164p-20mn</code>, <code>atmega164p-20mu</code>, <code>atmega164p-20pn</code>, <code>atmega164p-20pu</code>, <code>atmega164pv-10an</code>, <code>atmega164pv-10au</code>, <code>atmega164pv-10mu</code>, <code>atmega164pv-10pn</code>, <code>atmega164pv-10pu</code>, <code>atmega16u4-au</code>, <code>atmega16u4-mu</code>, <code>atmega16u4rc-au</code>, <code>atmega16u4rc-mu</code>.</p>"},{"location":"reference/targets/#atmega168","title":"ATmega168","text":"<p><code>atmega168-20au</code>, <code>atmega168-20mu</code>, <code>atmega168-20pu</code>, <code>atmega168a-au</code>, <code>atmega168a-ccu</code>, <code>atmega168a-mmh</code>, <code>atmega168a-mu</code>, <code>atmega168a-pu</code>, <code>atmega168p-20au</code>, <code>atmega168p-20mu</code>, <code>atmega168p-20pu</code>, <code>atmega168pa-an</code>, <code>atmega168pa-au</code>, <code>atmega168pa-ccu</code>, <code>atmega168pa-mmh</code>, <code>atmega168pa-mn</code>, <code>atmega168pa-mu</code>, <code>atmega168pa-pn</code>, <code>atmega168pa-pu</code>, <code>atmega168pv-10au</code>, <code>atmega168pv-10mu</code>, <code>atmega168pv-10pu</code>, <code>atmega168v-10au</code>, <code>atmega168v-10mu</code>, <code>atmega168v-10pu</code>.</p>"},{"location":"reference/targets/#atmega169","title":"ATmega169","text":"<p><code>atmega169a-an</code>, <code>atmega169a-au</code>, <code>atmega169a-mch</code>, <code>atmega169a-mn</code>, <code>atmega169a-mu</code>, <code>atmega169p-16au</code>, <code>atmega169p-16mch</code>, <code>atmega169p-16mu</code>, <code>atmega169pa-an</code>, <code>atmega169pa-au</code>, <code>atmega169pa-mch</code>, <code>atmega169pa-mn</code>, <code>atmega169pa-mu</code>, <code>atmega169pv-8au</code>, <code>atmega169pv-8mch</code>, <code>atmega169pv-8mu</code>.</p>"},{"location":"reference/targets/#atmega2560","title":"ATmega2560","text":"<p><code>atmega2560-16au</code>, <code>atmega2560-16cu</code>, <code>atmega2560v-8au</code>, <code>atmega2560v-8cu</code>.</p>"},{"location":"reference/targets/#atmega2561","title":"ATmega2561","text":"<p><code>atmega2561-16au</code>, <code>atmega2561-16mu</code>, <code>atmega2561v-8au</code>, <code>atmega2561v-8mu</code>.</p>"},{"location":"reference/targets/#atmega32","title":"ATmega32","text":"<p><code>atmega32a-an</code>, <code>atmega32a-au</code>, <code>atmega32a-mn</code>, <code>atmega32a-mu</code>, <code>atmega32a-pu</code>, <code>atmega32l-8au</code>, <code>atmega32l-8mu</code>, <code>atmega32l-8pu</code>.</p>"},{"location":"reference/targets/#atmega321","title":"ATmega321","text":"<p><code>atmega32-16au</code>, <code>atmega32-16mu</code>, <code>atmega32-16pu</code>.</p>"},{"location":"reference/targets/#atmega322","title":"ATmega322","text":"<p><code>atmega32u2-au</code>, <code>atmega32u2-mu</code>.</p>"},{"location":"reference/targets/#atmega324","title":"ATmega324","text":"<p><code>atmega324a-au</code>, <code>atmega324a-cu</code>, <code>atmega324a-mch</code>, <code>atmega324a-mu</code>, <code>atmega324a-pu</code>, <code>atmega324p-20an</code>, <code>atmega324p-20au</code>, <code>atmega324p-20mn</code>, <code>atmega324p-20mu</code>, <code>atmega324p-20pn</code>, <code>atmega324p-20pu</code>, <code>atmega324pv-10an</code>, <code>atmega324pv-10au</code>, <code>atmega324pv-10mn</code>, <code>atmega324pv-10mu</code>, <code>atmega324pv-10pn</code>, <code>atmega324pv-10pu</code>, <code>atmega32u4-au</code>, <code>atmega32u4-mu</code>, <code>atmega32u4rc-au</code>, <code>atmega32u4rc-mu</code>.</p>"},{"location":"reference/targets/#atmega328","title":"ATmega328","text":"<p><code>atmega328-au</code>, <code>atmega328-mmh</code>, <code>atmega328-mu</code>, <code>atmega328-pu</code>, <code>atmega328p-an</code>, <code>atmega328p-au</code>, <code>atmega328p-mmh</code>, <code>atmega328p-mn</code>, <code>atmega328p-mu</code>, <code>atmega328p-pn</code>, <code>atmega328p-pu</code>.</p>"},{"location":"reference/targets/#atmega329","title":"ATmega329","text":"<p><code>atmega329-16au</code>, <code>atmega329-16mu</code>, <code>atmega329a-an</code>, <code>atmega329a-au</code>, <code>atmega329a-mn</code>, <code>atmega329a-mu</code>, <code>atmega329p-20an</code>, <code>atmega329p-20au</code>, <code>atmega329p-20mn</code>, <code>atmega329p-20mu</code>, <code>atmega329pa-an</code>, <code>atmega329pa-au</code>, <code>atmega329pa-mn</code>, <code>atmega329pa-mu</code>, <code>atmega329pv-10au</code>, <code>atmega329pv-10mu</code>, <code>atmega329v-8au</code>, <code>atmega329v-8mu</code>.</p>"},{"location":"reference/targets/#atmega48","title":"ATmega48","text":"<p><code>atmega48a-au</code>, <code>atmega48a-ccu</code>, <code>atmega48a-mmh</code>, <code>atmega48a-mu</code>, <code>atmega48a-pu</code>, <code>atmega48p-20au</code>, <code>atmega48p-20mmu</code>, <code>atmega48p-20mu</code>, <code>atmega48p-20pu</code>, <code>atmega48pa-an</code>, <code>atmega48pa-au</code>, <code>atmega48pa-ccu</code>, <code>atmega48pa-mmh</code>, <code>atmega48pa-mmn</code>, <code>atmega48pa-mn</code>, <code>atmega48pa-mu</code>, <code>atmega48pa-pn</code>, <code>atmega48pa-pu</code>, <code>atmega48pb-an</code>, <code>atmega48pb-au</code>, <code>atmega48pb-mn</code>, <code>atmega48pb-mu</code>, <code>atmega48pv-10au</code>, <code>atmega48pv-10mmu</code>, <code>atmega48pv-10mu</code>, <code>atmega48pv-10pu</code>, <code>atmega48v-10au</code>, <code>atmega48v-10mmh</code>, <code>atmega48v-10mmu</code>, <code>atmega48v-10mu</code>, <code>atmega48v-10pu</code>.</p>"},{"location":"reference/targets/#atmega482","title":"ATmega482","text":"<p><code>atmega48-20au</code>, <code>atmega48-20mmh</code>, <code>atmega48-20mmu</code>, <code>atmega48-20mu</code>, <code>atmega48-20pu</code>.</p>"},{"location":"reference/targets/#atmega64","title":"ATmega64","text":"<p><code>atmega64a-an</code>, <code>atmega64a-au</code>, <code>atmega64a-mn</code>, <code>atmega64a-mu</code>, <code>atmega64l-8an</code>, <code>atmega64l-8au</code>, <code>atmega64l-8mn</code>, <code>atmega64l-8mu</code>.</p>"},{"location":"reference/targets/#atmega640","title":"ATmega640","text":"<p><code>atmega640-16au</code>, <code>atmega640-16cu</code>, <code>atmega640v-8au</code>, <code>atmega640v-8cu</code>.</p>"},{"location":"reference/targets/#atmega641","title":"ATmega641","text":"<p><code>atmega64-16an</code>, <code>atmega64-16au</code>, <code>atmega64-16mn</code>, <code>atmega64-16mu</code>, <code>atmega64c1-au</code>, <code>atmega64c1-mu</code>, <code>atmega64m1-au</code>, <code>atmega64m1-mu</code>.</p>"},{"location":"reference/targets/#atmega644","title":"ATmega644","text":"<p><code>atmega644-20au</code>, <code>atmega644-20mu</code>, <code>atmega644-20pu</code>, <code>atmega644a-au</code>, <code>atmega644a-mu</code>, <code>atmega644a-pu</code>, <code>atmega644p-20an</code>, <code>atmega644p-20au</code>, <code>atmega644p-20mn</code>, <code>atmega644p-20mu</code>, <code>atmega644p-20pn</code>, <code>atmega644p-20pu</code>, <code>atmega644pa-an</code>, <code>atmega644pa-au</code>, <code>atmega644pa-mn</code>, <code>atmega644pa-mu</code>, <code>atmega644pa-pn</code>, <code>atmega644pa-pu</code>, <code>atmega644pv-10an</code>, <code>atmega644pv-10au</code>, <code>atmega644pv-10mn</code>, <code>atmega644pv-10mu</code>, <code>atmega644pv-10pn</code>, <code>atmega644pv-10pu</code>, <code>atmega644v-10au</code>, <code>atmega644v-10mu</code>, <code>atmega644v-10pu</code>.</p>"},{"location":"reference/targets/#atmega649","title":"ATmega649","text":"<p><code>atmega649-16au</code>, <code>atmega649-16mu</code>, <code>atmega649a-au</code>, <code>atmega649a-mu</code>, <code>atmega649p-au</code>, <code>atmega649p-mu</code>, <code>atmega649v-8au</code>, <code>atmega649v-8mu</code>.</p>"},{"location":"reference/targets/#atmega8","title":"ATmega8","text":"<p><code>atmega8a-an</code>, <code>atmega8a-au</code>, <code>atmega8a-mn</code>, <code>atmega8a-mu</code>, <code>atmega8a-pn</code>, <code>atmega8a-pu</code>.</p>"},{"location":"reference/targets/#atmega816","title":"ATmega816","text":"<p><code>atmega8-16an</code>, <code>atmega8-16au</code>, <code>atmega8-16mn</code>, <code>atmega8-16mu</code>, <code>atmega8-16pn</code>, <code>atmega8-16pu</code>.</p>"},{"location":"reference/targets/#atmega82","title":"ATmega82","text":"<p><code>atmega8u2-au</code>, <code>atmega8u2-mu</code>.</p>"},{"location":"reference/targets/#atmega88","title":"ATmega88","text":"<p><code>atmega88a-au</code>, <code>atmega88a-ccu</code>, <code>atmega88a-mmh</code>, <code>atmega88a-mu</code>, <code>atmega88a-pu</code>, <code>atmega88p-20au</code>, <code>atmega88p-20mu</code>, <code>atmega88p-20pu</code>, <code>atmega88pa-an</code>, <code>atmega88pa-au</code>, <code>atmega88pa-ccu</code>, <code>atmega88pa-mmh</code>, <code>atmega88pa-mmn</code>, <code>atmega88pa-mn</code>, <code>atmega88pa-mu</code>, <code>atmega88pa-pn</code>, <code>atmega88pa-pu</code>, <code>atmega88pb-an</code>, <code>atmega88pb-au</code>, <code>atmega88pb-mn</code>, <code>atmega88pb-mu</code>, <code>atmega88pv-10au</code>, <code>atmega88pv-10mu</code>, <code>atmega88pv-10pu</code>, <code>atmega88v-10au</code>, <code>atmega88v-10mu</code>, <code>atmega88v-10pu</code>, <code>atmega8l-8an</code>, <code>atmega8l-8au</code>, <code>atmega8l-8mn</code>, <code>atmega8l-8mu</code>, <code>atmega8l-8pn</code>, <code>atmega8l-8pu</code>.</p>"},{"location":"reference/targets/#atmega882","title":"ATmega882","text":"<p><code>atmega88-20au</code>, <code>atmega88-20mu</code>, <code>atmega88-20pu</code>.</p>"},{"location":"reference/targets/#attiny","title":"ATtiny","text":""},{"location":"reference/targets/#attiny13","title":"ATtiny13","text":"<p><code>attiny13a-mmf</code>, <code>attiny13a-mmu</code>, <code>attiny13a-mu</code>, <code>attiny13a-pu</code>, <code>attiny13a-sf</code>, <code>attiny13a-sh</code>, <code>attiny13a-sn</code>, <code>attiny13a-ss7</code>, <code>attiny13a-ssh</code>, <code>attiny13a-ssu</code>, <code>attiny13a-su</code>, <code>attiny13v-10mmu</code>, <code>attiny13v-10mu</code>, <code>attiny13v-10pu</code>, <code>attiny13v-10ssu</code>, <code>attiny13v-10su</code>.</p>"},{"location":"reference/targets/#attiny132","title":"ATtiny132","text":"<p><code>attiny13-20mmu</code>, <code>attiny13-20mu</code>, <code>attiny13-20pu</code>, <code>attiny13-20ssu</code>, <code>attiny13-20su</code>.</p>"},{"location":"reference/targets/#attiny25","title":"ATtiny25","text":"<p><code>attiny25v-10mf</code>, <code>attiny25v-10mu</code>, <code>attiny25v-10pu</code>, <code>attiny25v-10sh</code>, <code>attiny25v-10sn</code>, <code>attiny25v-10ssh</code>, <code>attiny25v-10ssn</code>, <code>attiny25v-10ssu</code>, <code>attiny25v-10su</code>, <code>attiny25v-20mf</code>, <code>attiny25v-20mu</code>, <code>attiny25v-20pu</code>, <code>attiny25v-20sh</code>, <code>attiny25v-20sn</code>, <code>attiny25v-20ssh</code>, <code>attiny25v-20ssn</code>, <code>attiny25v-20ssu</code>, <code>attiny25v-20su</code>.</p>"},{"location":"reference/targets/#attiny85","title":"ATtiny85","text":"<p><code>attiny85v-10mu</code>, <code>attiny85v-10pu</code>, <code>attiny85v-10sh</code>, <code>attiny85v-10su</code>, <code>attiny85v-20mu</code>, <code>attiny85v-20pu</code>, <code>attiny85v-20sh</code>, <code>attiny85v-20su</code>.</p>"},{"location":"reference/targets/#attiny861","title":"ATtiny861","text":"<p><code>attiny861-20mu</code>, <code>attiny861-20pu</code>, <code>attiny861-20su</code>, <code>attiny861v-10mu</code>, <code>attiny861v-10pu</code>, <code>attiny861v-10su</code>.</p>"},{"location":"reference/targets/#attiny88","title":"ATtiny88","text":"<p><code>attiny88-au</code>, <code>attiny88-ccu</code>, <code>attiny88-mmh</code>, <code>attiny88-mmu</code>, <code>attiny88-mu</code>, <code>attiny88-pu</code>.</p>"},{"location":"reference/targets/#microchip-sam","title":"Microchip SAM","text":"<p>Identifier format example for <code>SAMD21G18A-AU</code>: <pre><code>   sam      d21     g    18       a         a       u\n{platform}{series}{pin}{flash}{variant}-{package}{grade}\n</code></pre></p>"},{"location":"reference/targets/#samd","title":"SAMD","text":""},{"location":"reference/targets/#samd21","title":"SAMD21","text":"<p><code>samd21e15a-af</code>, <code>samd21e15a-au</code>, <code>samd21e15a-az</code>, <code>samd21e15a-mf</code>, <code>samd21e15a-mu</code>, <code>samd21e15a-mz</code>, <code>samd21e15b-af</code>, <code>samd21e15b-au</code>, <code>samd21e15b-az</code>, <code>samd21e15b-mf</code>, <code>samd21e15b-mu</code>, <code>samd21e15b-mz</code>, <code>samd21e15b-uf</code>, <code>samd21e15b-uu</code>, <code>samd21e15l-af</code>, <code>samd21e15l-an</code>, <code>samd21e15l-mf</code>, <code>samd21e15l-mn</code>, <code>samd21e16a-af</code>, <code>samd21e16a-au</code>, <code>samd21e16a-az</code>, <code>samd21e16a-mf</code>, <code>samd21e16a-mu</code>, <code>samd21e16a-mz</code>, <code>samd21e16b-af</code>, <code>samd21e16b-au</code>, <code>samd21e16b-az</code>, <code>samd21e16b-mf</code>, <code>samd21e16b-mu</code>, <code>samd21e16b-mz</code>, <code>samd21e16b-uf</code>, <code>samd21e16b-uu</code>, <code>samd21e16l-af</code>, <code>samd21e16l-an</code>, <code>samd21e16l-mf</code>, <code>samd21e16l-mn</code>, <code>samd21e17a-af</code>, <code>samd21e17a-au</code>, <code>samd21e17a-az</code>, <code>samd21e17a-mf</code>, <code>samd21e17a-mu</code>, <code>samd21e17a-mz</code>, <code>samd21e17d-af</code>, <code>samd21e17d-au</code>, <code>samd21e17d-az</code>, <code>samd21e17d-mf</code>, <code>samd21e17d-mu</code>, <code>samd21e17d-mz</code>, <code>samd21e17d-uu</code>, <code>samd21e17l-af</code>, <code>samd21e17l-an</code>, <code>samd21e17l-mf</code>, <code>samd21e17l-mn</code>, <code>samd21e17l-sf</code>, <code>samd21e17l-sn</code>, <code>samd21e18a-af</code>, <code>samd21e18a-au</code>, <code>samd21e18a-az</code>, <code>samd21e18a-mf</code>, <code>samd21e18a-mu</code>, <code>samd21e18a-mz</code>, <code>samd21g15a-af</code>, <code>samd21g15a-au</code>, <code>samd21g15a-az</code>, <code>samd21g15a-mf</code>, <code>samd21g15a-mu</code>, <code>samd21g15a-mz</code>, <code>samd21g15b-af</code>, <code>samd21g15b-au</code>, <code>samd21g15b-az</code>, <code>samd21g15b-mf</code>, <code>samd21g15b-mu</code>, <code>samd21g15b-mz</code>, <code>samd21g15l-mn</code>, <code>samd21g15l-mu</code>, <code>samd21g16a-af</code>, <code>samd21g16a-au</code>, <code>samd21g16a-az</code>, <code>samd21g16a-mf</code>, <code>samd21g16a-mu</code>, <code>samd21g16a-mz</code>, <code>samd21g16b-af</code>, <code>samd21g16b-au</code>, <code>samd21g16b-az</code>, <code>samd21g16b-mf</code>, <code>samd21g16b-mu</code>, <code>samd21g16b-mz</code>, <code>samd21g16l-mn</code>, <code>samd21g16l-mu</code>, <code>samd21g17a-af</code>, <code>samd21g17a-au</code>, <code>samd21g17a-az</code>, <code>samd21g17a-mf</code>, <code>samd21g17a-mu</code>, <code>samd21g17a-mz</code>, <code>samd21g17a-uu</code>, <code>samd21g17d-af</code>, <code>samd21g17d-au</code>, <code>samd21g17d-az</code>, <code>samd21g17d-mf</code>, <code>samd21g17d-mu</code>, <code>samd21g17d-mz</code>, <code>samd21g17l-mf</code>, <code>samd21g17l-mn</code>, <code>samd21g17l-mu</code>, <code>samd21g18a-af</code>, <code>samd21g18a-au</code>, <code>samd21g18a-az</code>, <code>samd21g18a-mf</code>, <code>samd21g18a-mu</code>, <code>samd21g18a-mz</code>, <code>samd21g18a-uu</code>, <code>samd21j15a-af</code>, <code>samd21j15a-au</code>, <code>samd21j15a-az</code>, <code>samd21j15a-mf</code>, <code>samd21j15a-mu</code>, <code>samd21j15a-mz</code>, <code>samd21j15b-af</code>, <code>samd21j15b-au</code>, <code>samd21j15b-az</code>, <code>samd21j15b-cf</code>, <code>samd21j15b-cu</code>, <code>samd21j15b-mf</code>, <code>samd21j15b-mu</code>, <code>samd21j15b-mz</code>, <code>samd21j16a-af</code>, <code>samd21j16a-au</code>, <code>samd21j16a-az</code>, <code>samd21j16a-cu</code>, <code>samd21j16a-mf</code>, <code>samd21j16a-mu</code>, <code>samd21j16a-mz</code>, <code>samd21j16b-af</code>, <code>samd21j16b-au</code>, <code>samd21j16b-az</code>, <code>samd21j16b-cf</code>, <code>samd21j16b-cu</code>, <code>samd21j16b-mf</code>, <code>samd21j16b-mu</code>, <code>samd21j16b-mz</code>, <code>samd21j17a-af</code>, <code>samd21j17a-au</code>, <code>samd21j17a-az</code>, <code>samd21j17a-cu</code>, <code>samd21j17a-mf</code>, <code>samd21j17a-mu</code>, <code>samd21j17a-mz</code>, <code>samd21j17d-af</code>, <code>samd21j17d-au</code>, <code>samd21j17d-az</code>, <code>samd21j17d-cf</code>, <code>samd21j17d-cu</code>, <code>samd21j17d-mf</code>, <code>samd21j17d-mu</code>, <code>samd21j17d-mz</code>, <code>samd21j18a-af</code>, <code>samd21j18a-au</code>, <code>samd21j18a-az</code>, <code>samd21j18a-cu</code>, <code>samd21j18a-mf</code>, <code>samd21j18a-mu</code>, <code>samd21j18a-mz</code>.</p>"},{"location":"reference/targets/#samd51","title":"SAMD51","text":"<p><code>samd51g18a-mf</code>, <code>samd51g18a-mu</code>, <code>samd51g18a-mz</code>, <code>samd51g19a-mf</code>, <code>samd51g19a-mu</code>, <code>samd51g19a-mz</code>, <code>samd51j18a-af</code>, <code>samd51j18a-au</code>, <code>samd51j18a-az</code>, <code>samd51j18a-mf</code>, <code>samd51j18a-mu</code>, <code>samd51j18a-mz</code>, <code>samd51j19a-af</code>, <code>samd51j19a-au</code>, <code>samd51j19a-az</code>, <code>samd51j19a-mf</code>, <code>samd51j19a-mu</code>, <code>samd51j19a-mz</code>, <code>samd51j19a-un</code>, <code>samd51j19a-uu</code>, <code>samd51j20a-af</code>, <code>samd51j20a-au</code>, <code>samd51j20a-az</code>, <code>samd51j20a-mf</code>, <code>samd51j20a-mu</code>, <code>samd51j20a-mz</code>, <code>samd51j20a-un</code>, <code>samd51j20a-uu</code>, <code>samd51n19a-af</code>, <code>samd51n19a-au</code>, <code>samd51n19a-az</code>, <code>samd51n20a-af</code>, <code>samd51n20a-au</code>, <code>samd51n20a-az</code>, <code>samd51p19a-af</code>, <code>samd51p19a-au</code>, <code>samd51p19a-az</code>, <code>samd51p19a-ctf</code>, <code>samd51p19a-ctu</code>, <code>samd51p20a-af</code>, <code>samd51p20a-au</code>, <code>samd51p20a-az</code>, <code>samd51p20a-ctf</code>, <code>samd51p20a-ctu</code>.</p>"},{"location":"reference/targets/#same","title":"SAME","text":""},{"location":"reference/targets/#same51","title":"SAME51","text":"<p><code>same51g18a-mf</code>, <code>same51g18a-mu</code>, <code>same51g18a-mz</code>, <code>same51g19a-mf</code>, <code>same51g19a-mu</code>, <code>same51g19a-mz</code>, <code>same51j18a-af</code>, <code>same51j18a-au</code>, <code>same51j18a-az</code>, <code>same51j18a-mf</code>, <code>same51j18a-mu</code>, <code>same51j18a-mz</code>, <code>same51j19a-af</code>, <code>same51j19a-au</code>, <code>same51j19a-az</code>, <code>same51j19a-mf</code>, <code>same51j19a-mu</code>, <code>same51j19a-mz</code>, <code>same51j20a-af</code>, <code>same51j20a-au</code>, <code>same51j20a-az</code>, <code>same51j20a-mf</code>, <code>same51j20a-mu</code>, <code>same51j20a-mz</code>, <code>same51n19a-af</code>, <code>same51n19a-au</code>, <code>same51n19a-az</code>, <code>same51n20a-af</code>, <code>same51n20a-au</code>, <code>same51n20a-az</code>.</p>"},{"location":"reference/targets/#same53","title":"SAME53","text":"<p><code>same53j18a-af</code>, <code>same53j18a-au</code>, <code>same53j18a-az</code>, <code>same53j18a-mf</code>, <code>same53j18a-mu</code>, <code>same53j18a-mz</code>, <code>same53j19a-af</code>, <code>same53j19a-au</code>, <code>same53j19a-az</code>, <code>same53j19a-mf</code>, <code>same53j19a-mu</code>, <code>same53j19a-mz</code>, <code>same53j20a-af</code>, <code>same53j20a-au</code>, <code>same53j20a-az</code>, <code>same53j20a-mf</code>, <code>same53j20a-mu</code>, <code>same53j20a-mz</code>, <code>same53n19a-af</code>, <code>same53n19a-au</code>, <code>same53n19a-az</code>, <code>same53n20a-af</code>, <code>same53n20a-au</code>, <code>same53n20a-az</code>.</p>"},{"location":"reference/targets/#same54","title":"SAME54","text":"<p><code>same54n19a-af</code>, <code>same54n19a-au</code>, <code>same54n19a-az</code>, <code>same54n20a-af</code>, <code>same54n20a-au</code>, <code>same54n20a-az</code>, <code>same54p19a-af</code>, <code>same54p19a-au</code>, <code>same54p19a-az</code>, <code>same54p19a-ctf</code>, <code>same54p19a-ctu</code>, <code>same54p20a-af</code>, <code>same54p20a-au</code>, <code>same54p20a-az</code>, <code>same54p20a-ctf</code>, <code>same54p20a-ctu</code>.</p>"},{"location":"reference/targets/#same70","title":"SAME70","text":"<p><code>same70j19a-an</code>, <code>same70j19b-an</code>, <code>same70j20a-an</code>, <code>same70j20b-an</code>, <code>same70j21a-an</code>, <code>same70j21b-an</code>, <code>same70n19a-an</code>, <code>same70n19a-cn</code>, <code>same70n19b-an</code>, <code>same70n19b-cn</code>, <code>same70n20a-an</code>, <code>same70n20a-cn</code>, <code>same70n20b-an</code>, <code>same70n20b-cn</code>, <code>same70n21a-an</code>, <code>same70n21a-cn</code>, <code>same70n21b-an</code>, <code>same70n21b-cn</code>, <code>same70q19a-an</code>, <code>same70q19a-cfn</code>, <code>same70q19a-cn</code>, <code>same70q19b-an</code>, <code>same70q19b-cfn</code>, <code>same70q19b-cn</code>, <code>same70q20a-an</code>, <code>same70q20a-cfn</code>, <code>same70q20a-cn</code>, <code>same70q20b-an</code>, <code>same70q20b-cfn</code>, <code>same70q20b-cn</code>, <code>same70q21a-an</code>, <code>same70q21a-cfn</code>, <code>same70q21a-cn</code>, <code>same70q21b-an</code>, <code>same70q21b-cfn</code>, <code>same70q21b-cn</code>.</p>"},{"location":"reference/targets/#samg55","title":"SAMG55","text":"<p><code>samg55g19a-uut</code>, <code>samg55j19a-au</code>, <code>samg55j19a-aut</code>, <code>samg55j19a-mu</code>, <code>samg55j19a-mut</code>.</p>"},{"location":"reference/targets/#sams70","title":"SAMS70","text":"<p><code>sams70j19a-an</code>, <code>sams70j19a-mn</code>, <code>sams70j19b-an</code>, <code>sams70j19b-mn</code>, <code>sams70j20a-an</code>, <code>sams70j20a-mn</code>, <code>sams70j20b-an</code>, <code>sams70j20b-mn</code>, <code>sams70j21a-an</code>, <code>sams70j21a-mn</code>, <code>sams70j21b-an</code>, <code>sams70j21b-mn</code>, <code>sams70n19a-an</code>, <code>sams70n19a-cfn</code>, <code>sams70n19a-cn</code>, <code>sams70n19b-an</code>, <code>sams70n19b-cfn</code>, <code>sams70n19b-cn</code>, <code>sams70n20a-an</code>, <code>sams70n20a-cfn</code>, <code>sams70n20a-cn</code>, <code>sams70n20b-an</code>, <code>sams70n20b-cfn</code>, <code>sams70n20b-cn</code>, <code>sams70n21a-an</code>, <code>sams70n21a-cfn</code>, <code>sams70n21a-cn</code>, <code>sams70n21b-an</code>, <code>sams70n21b-cfn</code>, <code>sams70n21b-cn</code>, <code>sams70q19a-an</code>, <code>sams70q19a-cfn</code>, <code>sams70q19a-cn</code>, <code>sams70q19b-an</code>, <code>sams70q19b-cfn</code>, <code>sams70q19b-cn</code>, <code>sams70q20a-an</code>, <code>sams70q20a-cfn</code>, <code>sams70q20a-cn</code>, <code>sams70q20b-an</code>, <code>sams70q20b-cfn</code>, <code>sams70q20b-cn</code>, <code>sams70q21a-an</code>, <code>sams70q21a-cfn</code>, <code>sams70q21a-cn</code>, <code>sams70q21b-an</code>, <code>sams70q21b-cfn</code>, <code>sams70q21b-cn</code>.</p>"},{"location":"reference/targets/#samv","title":"SAMV","text":""},{"location":"reference/targets/#samv70","title":"SAMV70","text":"<p><code>samv70j19a-aab</code>, <code>samv70j19b-aab</code>, <code>samv70j20a-aab</code>, <code>samv70j20b-aab</code>, <code>samv70n19a-aab</code>, <code>samv70n19a-cb</code>, <code>samv70n19b-aab</code>, <code>samv70n19b-cb</code>, <code>samv70n20a-aab</code>, <code>samv70n20a-cb</code>, <code>samv70n20b-aab</code>, <code>samv70n20b-cb</code>, <code>samv70q19a-aab</code>, <code>samv70q19a-cb</code>, <code>samv70q19b-aab</code>, <code>samv70q19b-cb</code>, <code>samv70q20a-aab</code>, <code>samv70q20a-cb</code>, <code>samv70q20b-aab</code>, <code>samv70q20b-cb</code>.</p>"},{"location":"reference/targets/#samv71","title":"SAMV71","text":"<p><code>samv71j19a-aab</code>, <code>samv71j19b-aab</code>, <code>samv71j20a-aab</code>, <code>samv71j20b-aab</code>, <code>samv71j21a-aab</code>, <code>samv71j21b-aab</code>, <code>samv71n19a-aab</code>, <code>samv71n19a-cb</code>, <code>samv71n19b-aab</code>, <code>samv71n19b-cb</code>, <code>samv71n20a-aab</code>, <code>samv71n20a-cb</code>, <code>samv71n20b-aab</code>, <code>samv71n20b-cb</code>, <code>samv71n21a-aab</code>, <code>samv71n21a-cb</code>, <code>samv71n21b-aab</code>, <code>samv71n21b-cb</code>, <code>samv71q19a-aab</code>, <code>samv71q19a-cb</code>, <code>samv71q19b-aab</code>, <code>samv71q19b-cb</code>, <code>samv71q20a-aab</code>, <code>samv71q20a-cb</code>, <code>samv71q20b-aab</code>, <code>samv71q20b-cb</code>, <code>samv71q21a-aab</code>, <code>samv71q21a-cb</code>, <code>samv71q21b-aab</code>, <code>samv71q21b-cb</code>.</p>"},{"location":"reference/targets/#raspberry-pi","title":"Raspberry Pi","text":"<p>Identifier format example for <code>RP2040</code>: <pre><code>    rp       2     0     4     0\n{platform}{cores}{type}{ram}{flash}\n</code></pre></p> <p><code>rp2040</code>.</p>"},{"location":"reference/targets/#stmicroelectronics-stm32","title":"STMicroelectronics STM32","text":"<p>Identifier format example for <code>STM32G071GBU6N/revY</code>: <pre><code>   stm32     g0     71    g    b       u          6          n        y\n{platform}{family}{name}{pin}{size}{package}{temperature}{variant}{revision}\n</code></pre> The revision is optional, however, the device variant often means significant differences in pinout or peripherals, so check your device's identifier twice!</p>"},{"location":"reference/targets/#stm32c0","title":"STM32C0","text":""},{"location":"reference/targets/#stm32c011","title":"STM32C011","text":"<p><code>stm32c011d6y6</code>, <code>stm32c011f4p6</code>, <code>stm32c011f4u6</code>, <code>stm32c011f6p6</code>, <code>stm32c011f6u6</code>, <code>stm32c011j4m6</code>, <code>stm32c011j6m6</code>.</p>"},{"location":"reference/targets/#stm32c031","title":"STM32C031","text":"<p><code>stm32c031c4t6</code>, <code>stm32c031c4u6</code>, <code>stm32c031c6t6</code>, <code>stm32c031c6u6</code>, <code>stm32c031f4p6</code>, <code>stm32c031f6p6</code>, <code>stm32c031g4u6</code>, <code>stm32c031g6u6</code>, <code>stm32c031k4t6</code>, <code>stm32c031k4u6</code>, <code>stm32c031k6t6</code>, <code>stm32c031k6u6</code>.</p>"},{"location":"reference/targets/#stm32c051","title":"STM32C051","text":"<p><code>stm32c051c6t6</code>, <code>stm32c051c6u6</code>, <code>stm32c051c8t6</code>, <code>stm32c051c8u6</code>, <code>stm32c051d8y6</code>, <code>stm32c051f6p6</code>, <code>stm32c051f8p6</code>, <code>stm32c051g6u6</code>, <code>stm32c051g8u6</code>, <code>stm32c051k6t6</code>, <code>stm32c051k6u6</code>, <code>stm32c051k8t6</code>.</p>"},{"location":"reference/targets/#stm32c071","title":"STM32C071","text":"<p><code>stm32c071c8t6</code>, <code>stm32c071c8t6n</code>, <code>stm32c071c8u6</code>, <code>stm32c071c8u6n</code>, <code>stm32c071cbt6</code>, <code>stm32c071cbt6n</code>, <code>stm32c071cbu6</code>, <code>stm32c071cbu6n</code>, <code>stm32c071f8p6</code>, <code>stm32c071f8p6n</code>, <code>stm32c071fbp6</code>, <code>stm32c071fbp6n</code>, <code>stm32c071fby6</code>, <code>stm32c071g8u6</code>, <code>stm32c071g8u6n</code>, <code>stm32c071gbu6</code>, <code>stm32c071gbu6n</code>, <code>stm32c071k8t6</code>, <code>stm32c071k8t6n</code>, <code>stm32c071k8u6</code>, <code>stm32c071k8u6n</code>, <code>stm32c071kbt6</code>, <code>stm32c071kbt6n</code>, <code>stm32c071kbu6</code>, <code>stm32c071kbu6n</code>, <code>stm32c071r8t6</code>, <code>stm32c071r8t6n</code>, <code>stm32c071rbi6n</code>, <code>stm32c071rbt6</code>, <code>stm32c071rbt6n</code>.</p>"},{"location":"reference/targets/#stm32c091","title":"STM32C091","text":"<p><code>stm32c091cbt6</code>, <code>stm32c091cbu6</code>, <code>stm32c091cct6</code>, <code>stm32c091ccu6</code>, <code>stm32c091ecy6</code>, <code>stm32c091fbp6</code>, <code>stm32c091fcp6</code>, <code>stm32c091gbu6</code>, <code>stm32c091gcu6</code>, <code>stm32c091kbt6</code>, <code>stm32c091kbu6</code>, <code>stm32c091kct6</code>, <code>stm32c091kcu6</code>, <code>stm32c091rbt6</code>, <code>stm32c091rci6</code>, <code>stm32c091rct6</code>.</p>"},{"location":"reference/targets/#stm32c092","title":"STM32C092","text":"<p><code>stm32c092cbt6</code>, <code>stm32c092cbu6</code>, <code>stm32c092cct6</code>, <code>stm32c092ccu6</code>, <code>stm32c092ecy6</code>, <code>stm32c092fbp6</code>, <code>stm32c092fcp6</code>, <code>stm32c092gbu6</code>, <code>stm32c092gcu6</code>, <code>stm32c092kbt6</code>, <code>stm32c092kbu6</code>, <code>stm32c092kct6</code>, <code>stm32c092kcu6</code>, <code>stm32c092rbt6</code>, <code>stm32c092rci6</code>, <code>stm32c092rct6</code>.</p>"},{"location":"reference/targets/#stm32f0","title":"STM32F0","text":""},{"location":"reference/targets/#stm32f030","title":"STM32F030","text":"<p><code>stm32f030c6t6</code>, <code>stm32f030c8t6</code>, <code>stm32f030cct6</code>, <code>stm32f030f4p6</code>, <code>stm32f030k6t6</code>, <code>stm32f030r8t6</code>, <code>stm32f030rct6</code>.</p>"},{"location":"reference/targets/#stm32f031","title":"STM32F031","text":"<p><code>stm32f031c4t6</code>, <code>stm32f031c6t6</code>, <code>stm32f031c6t7</code>, <code>stm32f031e6y6</code>, <code>stm32f031f4p6</code>, <code>stm32f031f4p7</code>, <code>stm32f031f6p6</code>, <code>stm32f031f6p7</code>, <code>stm32f031g4u6</code>, <code>stm32f031g4u7</code>, <code>stm32f031g6u6</code>, <code>stm32f031g6u7</code>, <code>stm32f031k4u6</code>, <code>stm32f031k6t6</code>, <code>stm32f031k6t7</code>, <code>stm32f031k6u6</code>, <code>stm32f031k6u7</code>.</p>"},{"location":"reference/targets/#stm32f038","title":"STM32F038","text":"<p><code>stm32f038c6t6</code>, <code>stm32f038c6t7</code>, <code>stm32f038e6y6</code>, <code>stm32f038f6p6</code>, <code>stm32f038g6u6</code>, <code>stm32f038k6u6</code>.</p>"},{"location":"reference/targets/#stm32f042","title":"STM32F042","text":"<p><code>stm32f042c4t6</code>, <code>stm32f042c4u6</code>, <code>stm32f042c6t6</code>, <code>stm32f042c6t7</code>, <code>stm32f042c6u6</code>, <code>stm32f042c6u7</code>, <code>stm32f042f4p6</code>, <code>stm32f042f6p6</code>, <code>stm32f042f6p7</code>, <code>stm32f042g4u6</code>, <code>stm32f042g6u6</code>, <code>stm32f042g6u7</code>, <code>stm32f042k4t6</code>, <code>stm32f042k4u6</code>, <code>stm32f042k6t6</code>, <code>stm32f042k6t7</code>, <code>stm32f042k6u6</code>, <code>stm32f042k6u7</code>, <code>stm32f042t6y6</code>.</p>"},{"location":"reference/targets/#stm32f048","title":"STM32F048","text":"<p><code>stm32f048c6u6</code>, <code>stm32f048g6u6</code>, <code>stm32f048t6y6</code>.</p>"},{"location":"reference/targets/#stm32f051","title":"STM32F051","text":"<p><code>stm32f051c4t6</code>, <code>stm32f051c4u6</code>, <code>stm32f051c6t6</code>, <code>stm32f051c6t7</code>, <code>stm32f051c6u6</code>, <code>stm32f051c6u7</code>, <code>stm32f051c8t6</code>, <code>stm32f051c8t7</code>, <code>stm32f051c8u6</code>, <code>stm32f051c8u7</code>, <code>stm32f051k4t6</code>, <code>stm32f051k4t7</code>, <code>stm32f051k4u6</code>, <code>stm32f051k4u7</code>, <code>stm32f051k6t6</code>, <code>stm32f051k6t7</code>, <code>stm32f051k6u6</code>, <code>stm32f051k6u7</code>, <code>stm32f051k8t6</code>, <code>stm32f051k8t7</code>, <code>stm32f051k8u6</code>, <code>stm32f051k8u7</code>, <code>stm32f051r4t6</code>, <code>stm32f051r6t6</code>, <code>stm32f051r6t7</code>, <code>stm32f051r8h6</code>, <code>stm32f051r8h7</code>, <code>stm32f051r8t6</code>, <code>stm32f051r8t7</code>, <code>stm32f051t8y6</code>.</p>"},{"location":"reference/targets/#stm32f058","title":"STM32F058","text":"<p><code>stm32f058c8u6</code>, <code>stm32f058r8h6</code>, <code>stm32f058r8h7</code>, <code>stm32f058r8t6</code>, <code>stm32f058r8t7</code>, <code>stm32f058t8y6</code>.</p>"},{"location":"reference/targets/#stm32f070","title":"STM32F070","text":"<p><code>stm32f070c6t6</code>, <code>stm32f070cbt6</code>, <code>stm32f070f6p6</code>, <code>stm32f070rbt6</code>.</p>"},{"location":"reference/targets/#stm32f071","title":"STM32F071","text":"<p><code>stm32f071c8t6</code>, <code>stm32f071c8u6</code>, <code>stm32f071cbt6</code>, <code>stm32f071cbt7</code>, <code>stm32f071cbu6</code>, <code>stm32f071cbu7</code>, <code>stm32f071cby6</code>, <code>stm32f071cby7</code>, <code>stm32f071rbt6</code>, <code>stm32f071rbt7</code>, <code>stm32f071v8h6</code>, <code>stm32f071v8h7</code>, <code>stm32f071v8t6</code>, <code>stm32f071v8t7</code>, <code>stm32f071vbh6</code>, <code>stm32f071vbt6</code>.</p>"},{"location":"reference/targets/#stm32f072","title":"STM32F072","text":"<p><code>stm32f072c8t6</code>, <code>stm32f072c8t7</code>, <code>stm32f072c8u6</code>, <code>stm32f072c8u7</code>, <code>stm32f072cbt6</code>, <code>stm32f072cbt7</code>, <code>stm32f072cbu6</code>, <code>stm32f072cbu7</code>, <code>stm32f072cby6</code>, <code>stm32f072cby7</code>, <code>stm32f072r8t6</code>, <code>stm32f072r8t7</code>, <code>stm32f072rbh6</code>, <code>stm32f072rbh7</code>, <code>stm32f072rbi6</code>, <code>stm32f072rbi7</code>, <code>stm32f072rbt6</code>, <code>stm32f072rbt7</code>, <code>stm32f072v8h6</code>, <code>stm32f072v8t6</code>, <code>stm32f072vbh6</code>, <code>stm32f072vbt6</code>.</p>"},{"location":"reference/targets/#stm32f078","title":"STM32F078","text":"<p><code>stm32f078cbt6</code>, <code>stm32f078cbu6</code>, <code>stm32f078cby6</code>, <code>stm32f078rbh6</code>, <code>stm32f078rbh7</code>, <code>stm32f078rbt6</code>, <code>stm32f078rbt7</code>, <code>stm32f078vbh6</code>, <code>stm32f078vbt6</code>.</p>"},{"location":"reference/targets/#stm32f091","title":"STM32F091","text":"<p><code>stm32f091cbt6</code>, <code>stm32f091cbt7</code>, <code>stm32f091cbu6</code>, <code>stm32f091cbu7</code>, <code>stm32f091cct6</code>, <code>stm32f091cct7</code>, <code>stm32f091ccu6</code>, <code>stm32f091ccu7</code>, <code>stm32f091rbt6</code>, <code>stm32f091rch6</code>, <code>stm32f091rch7</code>, <code>stm32f091rct6</code>, <code>stm32f091rct7</code>, <code>stm32f091rcy6</code>, <code>stm32f091rcy7</code>, <code>stm32f091vbt6</code>, <code>stm32f091vbt7</code>, <code>stm32f091vch6</code>, <code>stm32f091vch7</code>, <code>stm32f091vct6</code>, <code>stm32f091vct7</code>.</p>"},{"location":"reference/targets/#stm32f098","title":"STM32F098","text":"<p><code>stm32f098cct6</code>, <code>stm32f098cct7</code>, <code>stm32f098ccu6</code>, <code>stm32f098ccu7</code>, <code>stm32f098rch6</code>, <code>stm32f098rct6</code>, <code>stm32f098rcy6</code>, <code>stm32f098vch6</code>, <code>stm32f098vct6</code>.</p>"},{"location":"reference/targets/#stm32f1","title":"STM32F1","text":""},{"location":"reference/targets/#stm32f100","title":"STM32F100","text":"<p><code>stm32f100c4t6</code>, <code>stm32f100c6t6</code>, <code>stm32f100c8t6</code>, <code>stm32f100cbt6</code>, <code>stm32f100r4h6</code>, <code>stm32f100r4t6</code>, <code>stm32f100r6h6</code>, <code>stm32f100r6t6</code>, <code>stm32f100r8h6</code>, <code>stm32f100r8t6</code>, <code>stm32f100rbh6</code>, <code>stm32f100rbt6</code>, <code>stm32f100rct6</code>, <code>stm32f100rdt6</code>, <code>stm32f100ret6</code>, <code>stm32f100v8t6</code>, <code>stm32f100vbt6</code>, <code>stm32f100vct6</code>, <code>stm32f100vdt6</code>, <code>stm32f100vet6</code>, <code>stm32f100zct6</code>, <code>stm32f100zdt6</code>, <code>stm32f100zet6</code>.</p>"},{"location":"reference/targets/#stm32f101","title":"STM32F101","text":"<p><code>stm32f101c4t6</code>, <code>stm32f101c6t6</code>, <code>stm32f101c8t6</code>, <code>stm32f101c8u6</code>, <code>stm32f101cbt6</code>, <code>stm32f101cbu6</code>, <code>stm32f101r4t6</code>, <code>stm32f101r6t6</code>, <code>stm32f101r8t6</code>, <code>stm32f101rbh6</code>, <code>stm32f101rbt6</code>, <code>stm32f101rct6</code>, <code>stm32f101rdt6</code>, <code>stm32f101ret6</code>, <code>stm32f101rft6</code>, <code>stm32f101rgt6</code>, <code>stm32f101t4u6</code>, <code>stm32f101t6u6</code>, <code>stm32f101t8u6</code>, <code>stm32f101tbu6</code>, <code>stm32f101v8t6</code>, <code>stm32f101vbt6</code>, <code>stm32f101vct6</code>, <code>stm32f101vdt6</code>, <code>stm32f101vet6</code>, <code>stm32f101vft6</code>, <code>stm32f101vgt6</code>, <code>stm32f101zct6</code>, <code>stm32f101zdt6</code>, <code>stm32f101zet6</code>, <code>stm32f101zft6</code>, <code>stm32f101zgt6</code>.</p>"},{"location":"reference/targets/#stm32f102","title":"STM32F102","text":"<p><code>stm32f102c4t6</code>, <code>stm32f102c6t6</code>, <code>stm32f102c8t6</code>, <code>stm32f102cbt6</code>, <code>stm32f102r4t6</code>, <code>stm32f102r6t6</code>, <code>stm32f102r8t6</code>, <code>stm32f102rbt6</code>.</p>"},{"location":"reference/targets/#stm32f103","title":"STM32F103","text":"<p><code>stm32f103c4t6</code>, <code>stm32f103c6t6</code>, <code>stm32f103c6u6</code>, <code>stm32f103c8t6</code>, <code>stm32f103c8t7</code>, <code>stm32f103cbt6</code>, <code>stm32f103cbt7</code>, <code>stm32f103cbu6</code>, <code>stm32f103cbu7</code>, <code>stm32f103r4h6</code>, <code>stm32f103r4t6</code>, <code>stm32f103r6h6</code>, <code>stm32f103r6t6</code>, <code>stm32f103r8h6</code>, <code>stm32f103r8h7</code>, <code>stm32f103r8t6</code>, <code>stm32f103r8t7</code>, <code>stm32f103rbh6</code>, <code>stm32f103rbh7</code>, <code>stm32f103rbt6</code>, <code>stm32f103rbt7</code>, <code>stm32f103rct6</code>, <code>stm32f103rct7</code>, <code>stm32f103rcy6</code>, <code>stm32f103rcy7</code>, <code>stm32f103rdt6</code>, <code>stm32f103rdy6</code>, <code>stm32f103ret6</code>, <code>stm32f103ret7</code>, <code>stm32f103rey6</code>, <code>stm32f103rey7</code>, <code>stm32f103rft6</code>, <code>stm32f103rft7</code>, <code>stm32f103rgt6</code>, <code>stm32f103rgt7</code>, <code>stm32f103t4u6</code>, <code>stm32f103t6u6</code>, <code>stm32f103t8u6</code>, <code>stm32f103t8u7</code>, <code>stm32f103tbu6</code>, <code>stm32f103tbu7</code>, <code>stm32f103v8h6</code>, <code>stm32f103v8t6</code>, <code>stm32f103vbh6</code>, <code>stm32f103vbh7</code>, <code>stm32f103vbi6</code>, <code>stm32f103vbi7</code>, <code>stm32f103vbt6</code>, <code>stm32f103vbt7</code>, <code>stm32f103vch6</code>, <code>stm32f103vch7</code>, <code>stm32f103vct6</code>, <code>stm32f103vct7</code>, <code>stm32f103vdh6</code>, <code>stm32f103vdh7</code>, <code>stm32f103vdt6</code>, <code>stm32f103vdt7</code>, <code>stm32f103veh6</code>, <code>stm32f103veh7</code>, <code>stm32f103vet6</code>, <code>stm32f103vet7</code>, <code>stm32f103vft6</code>, <code>stm32f103vft7</code>, <code>stm32f103vgt6</code>, <code>stm32f103vgt7</code>, <code>stm32f103zch6</code>, <code>stm32f103zch7</code>, <code>stm32f103zct6</code>, <code>stm32f103zct7</code>, <code>stm32f103zdh6</code>, <code>stm32f103zdh7</code>, <code>stm32f103zdt6</code>, <code>stm32f103zdt7</code>, <code>stm32f103zeh6</code>, <code>stm32f103zeh7</code>, <code>stm32f103zet6</code>, <code>stm32f103zet7</code>, <code>stm32f103zfh6</code>, <code>stm32f103zfh7</code>, <code>stm32f103zft6</code>, <code>stm32f103zft7</code>, <code>stm32f103zgh6</code>, <code>stm32f103zgh7</code>, <code>stm32f103zgt6</code>, <code>stm32f103zgt7</code>.</p>"},{"location":"reference/targets/#stm32f105","title":"STM32F105","text":"<p><code>stm32f105r8t6</code>, <code>stm32f105r8t7</code>, <code>stm32f105rbt6</code>, <code>stm32f105rbt7</code>, <code>stm32f105rct6</code>, <code>stm32f105rct7</code>, <code>stm32f105v8h6</code>, <code>stm32f105v8h7</code>, <code>stm32f105v8t6</code>, <code>stm32f105v8t7</code>, <code>stm32f105vbh6</code>, <code>stm32f105vbh7</code>, <code>stm32f105vbt6</code>, <code>stm32f105vbt7</code>, <code>stm32f105vct6</code>, <code>stm32f105vct7</code>.</p>"},{"location":"reference/targets/#stm32f107","title":"STM32F107","text":"<p><code>stm32f107rbt6</code>, <code>stm32f107rbt7</code>, <code>stm32f107rct6</code>, <code>stm32f107rct7</code>, <code>stm32f107vbt6</code>, <code>stm32f107vbt7</code>, <code>stm32f107vch6</code>, <code>stm32f107vch7</code>, <code>stm32f107vct6</code>, <code>stm32f107vct7</code>.</p>"},{"location":"reference/targets/#stm32f2","title":"STM32F2","text":""},{"location":"reference/targets/#stm32f205","title":"STM32F205","text":"<p><code>stm32f205rbt6</code>, <code>stm32f205rbt7</code>, <code>stm32f205rct6</code>, <code>stm32f205rct7</code>, <code>stm32f205ret6</code>, <code>stm32f205ret7</code>, <code>stm32f205rey6</code>, <code>stm32f205rey7</code>, <code>stm32f205rft6</code>, <code>stm32f205rge6</code>, <code>stm32f205rge7</code>, <code>stm32f205rgt6</code>, <code>stm32f205rgt7</code>, <code>stm32f205rgy6</code>, <code>stm32f205rgy7</code>, <code>stm32f205vbt6</code>, <code>stm32f205vct6</code>, <code>stm32f205vct7</code>, <code>stm32f205vet6</code>, <code>stm32f205vet7</code>, <code>stm32f205vft6</code>, <code>stm32f205vgt6</code>, <code>stm32f205vgt7</code>, <code>stm32f205zct6</code>, <code>stm32f205zct7</code>, <code>stm32f205zet6</code>, <code>stm32f205zet7</code>, <code>stm32f205zft6</code>, <code>stm32f205zgt6</code>, <code>stm32f205zgt7</code>.</p>"},{"location":"reference/targets/#stm32f207","title":"STM32F207","text":"<p><code>stm32f207ich6</code>, <code>stm32f207ict6</code>, <code>stm32f207ieh6</code>, <code>stm32f207iet6</code>, <code>stm32f207ifh6</code>, <code>stm32f207ift6</code>, <code>stm32f207igh6</code>, <code>stm32f207igh7</code>, <code>stm32f207igt6</code>, <code>stm32f207igt7</code>, <code>stm32f207vct6</code>, <code>stm32f207vct7</code>, <code>stm32f207vet6</code>, <code>stm32f207vft6</code>, <code>stm32f207vgt6</code>, <code>stm32f207vgt7</code>, <code>stm32f207zct6</code>, <code>stm32f207zct7</code>, <code>stm32f207zet6</code>, <code>stm32f207zft6</code>, <code>stm32f207zgt6</code>, <code>stm32f207zgt7</code>.</p>"},{"location":"reference/targets/#stm32f215","title":"STM32F215","text":"<p><code>stm32f215ret6</code>, <code>stm32f215rgt6</code>, <code>stm32f215vet6</code>, <code>stm32f215vgt6</code>, <code>stm32f215vgt7</code>, <code>stm32f215zet6</code>, <code>stm32f215zgt6</code>, <code>stm32f215zgt7</code>.</p>"},{"location":"reference/targets/#stm32f217","title":"STM32F217","text":"<p><code>stm32f217ieh6</code>, <code>stm32f217iet6</code>, <code>stm32f217igh6</code>, <code>stm32f217igh7</code>, <code>stm32f217igt6</code>, <code>stm32f217igt7</code>, <code>stm32f217vet6</code>, <code>stm32f217vgt6</code>, <code>stm32f217zet6</code>, <code>stm32f217zet7</code>, <code>stm32f217zgt6</code>.</p>"},{"location":"reference/targets/#stm32f3","title":"STM32F3","text":""},{"location":"reference/targets/#stm32f301","title":"STM32F301","text":"<p><code>stm32f301c6t6</code>, <code>stm32f301c6t7</code>, <code>stm32f301c8t6</code>, <code>stm32f301c8t7</code>, <code>stm32f301c8y6</code>, <code>stm32f301c8y7</code>, <code>stm32f301k6t6</code>, <code>stm32f301k6t7</code>, <code>stm32f301k6u6</code>, <code>stm32f301k6u7</code>, <code>stm32f301k8t6</code>, <code>stm32f301k8t7</code>, <code>stm32f301k8u6</code>, <code>stm32f301k8u7</code>, <code>stm32f301r6t6</code>, <code>stm32f301r8t6</code>.</p>"},{"location":"reference/targets/#stm32f302","title":"STM32F302","text":"<p><code>stm32f302c6t6</code>, <code>stm32f302c8t6</code>, <code>stm32f302c8t7</code>, <code>stm32f302c8y6</code>, <code>stm32f302c8y7</code>, <code>stm32f302cbt6</code>, <code>stm32f302cbt7</code>, <code>stm32f302cct6</code>, <code>stm32f302cct7</code>, <code>stm32f302k6u6</code>, <code>stm32f302k8u6</code>, <code>stm32f302k8u7</code>, <code>stm32f302r6t6</code>, <code>stm32f302r8t6</code>, <code>stm32f302r8t7</code>, <code>stm32f302rbt6</code>, <code>stm32f302rbt7</code>, <code>stm32f302rct6</code>, <code>stm32f302rct7</code>, <code>stm32f302rdt6</code>, <code>stm32f302rdt7</code>, <code>stm32f302ret6</code>, <code>stm32f302ret7</code>, <code>stm32f302vbt6</code>, <code>stm32f302vct6</code>, <code>stm32f302vct7</code>, <code>stm32f302vcy6</code>, <code>stm32f302vcy7</code>, <code>stm32f302vdh6</code>, <code>stm32f302vdt6</code>, <code>stm32f302veh6</code>, <code>stm32f302vet6</code>, <code>stm32f302zdt6</code>, <code>stm32f302zet6</code>, <code>stm32f302zet7</code>.</p>"},{"location":"reference/targets/#stm32f303","title":"STM32F303","text":"<p><code>stm32f303c6t6</code>, <code>stm32f303c8t6</code>, <code>stm32f303c8y6</code>, <code>stm32f303cbt6</code>, <code>stm32f303cbt7</code>, <code>stm32f303cct6</code>, <code>stm32f303cct7</code>, <code>stm32f303k6t6</code>, <code>stm32f303k6u6</code>, <code>stm32f303k8t6</code>, <code>stm32f303k8u6</code>, <code>stm32f303r6t6</code>, <code>stm32f303r8t6</code>, <code>stm32f303r8t7</code>, <code>stm32f303rbt6</code>, <code>stm32f303rbt7</code>, <code>stm32f303rct6</code>, <code>stm32f303rct7</code>, <code>stm32f303rdt6</code>, <code>stm32f303rdt7</code>, <code>stm32f303ret6</code>, <code>stm32f303ret7</code>, <code>stm32f303vbt6</code>, <code>stm32f303vbt7</code>, <code>stm32f303vct6</code>, <code>stm32f303vct7</code>, <code>stm32f303vcy6</code>, <code>stm32f303vcy7</code>, <code>stm32f303vdh6</code>, <code>stm32f303vdt6</code>, <code>stm32f303veh6</code>, <code>stm32f303veh7</code>, <code>stm32f303vet6</code>, <code>stm32f303vet7</code>, <code>stm32f303vey6</code>, <code>stm32f303vey7</code>, <code>stm32f303zdt6</code>, <code>stm32f303zdt7</code>, <code>stm32f303zet6</code>, <code>stm32f303zet7</code>.</p>"},{"location":"reference/targets/#stm32f318","title":"STM32F318","text":"<p><code>stm32f318c8t6</code>, <code>stm32f318c8y6</code>, <code>stm32f318k8u6</code>, <code>stm32f318k8u7</code>.</p>"},{"location":"reference/targets/#stm32f328","title":"STM32F328","text":"<p><code>stm32f328c8t6</code>.</p>"},{"location":"reference/targets/#stm32f334","title":"STM32F334","text":"<p><code>stm32f334c4t6</code>, <code>stm32f334c6t6</code>, <code>stm32f334c6t7</code>, <code>stm32f334c8t6</code>, <code>stm32f334c8t7</code>, <code>stm32f334c8y6</code>, <code>stm32f334c8y7</code>, <code>stm32f334k4t6</code>, <code>stm32f334k4u6</code>, <code>stm32f334k4u7</code>, <code>stm32f334k6t6</code>, <code>stm32f334k6t7</code>, <code>stm32f334k6u6</code>, <code>stm32f334k6u7</code>, <code>stm32f334k8t6</code>, <code>stm32f334k8t7</code>, <code>stm32f334k8u6</code>, <code>stm32f334k8u7</code>, <code>stm32f334r6t6</code>, <code>stm32f334r8t6</code>, <code>stm32f334r8t7</code>.</p>"},{"location":"reference/targets/#stm32f358","title":"STM32F358","text":"<p><code>stm32f358cct6</code>, <code>stm32f358rct6</code>, <code>stm32f358vct6</code>.</p>"},{"location":"reference/targets/#stm32f373","title":"STM32F373","text":"<p><code>stm32f373c8t6</code>, <code>stm32f373cbt6</code>, <code>stm32f373cbt7</code>, <code>stm32f373cct6</code>, <code>stm32f373cct7</code>, <code>stm32f373r8t6</code>, <code>stm32f373rbt6</code>, <code>stm32f373rbt7</code>, <code>stm32f373rct6</code>, <code>stm32f373v8h6</code>, <code>stm32f373v8t6</code>, <code>stm32f373vbh6</code>, <code>stm32f373vbh7</code>, <code>stm32f373vbt6</code>, <code>stm32f373vbt7</code>, <code>stm32f373vch6</code>, <code>stm32f373vch7</code>, <code>stm32f373vct6</code>, <code>stm32f373vct7</code>.</p>"},{"location":"reference/targets/#stm32f378","title":"STM32F378","text":"<p><code>stm32f378cct6</code>, <code>stm32f378rct6</code>, <code>stm32f378rcy6</code>, <code>stm32f378vch6</code>, <code>stm32f378vct6</code>.</p>"},{"location":"reference/targets/#stm32f398","title":"STM32F398","text":"<p><code>stm32f398vet6</code>.</p>"},{"location":"reference/targets/#stm32f4","title":"STM32F4","text":""},{"location":"reference/targets/#stm32f401","title":"STM32F401","text":"<p><code>stm32f401cbu3</code>, <code>stm32f401cbu6</code>, <code>stm32f401cbu7</code>, <code>stm32f401cby6</code>, <code>stm32f401ccf6</code>, <code>stm32f401ccf7</code>, <code>stm32f401ccu6</code>, <code>stm32f401ccu7</code>, <code>stm32f401ccy6</code>, <code>stm32f401ccy7</code>, <code>stm32f401cdu6</code>, <code>stm32f401cdy6</code>, <code>stm32f401ceu6</code>, <code>stm32f401cey6</code>, <code>stm32f401rbt6</code>, <code>stm32f401rct6</code>, <code>stm32f401rct7</code>, <code>stm32f401rdt6</code>, <code>stm32f401rdt7</code>, <code>stm32f401ret6</code>, <code>stm32f401ret7</code>, <code>stm32f401vbh3</code>, <code>stm32f401vbh6</code>, <code>stm32f401vbh7</code>, <code>stm32f401vbt3</code>, <code>stm32f401vbt6</code>, <code>stm32f401vbt7</code>, <code>stm32f401vch6</code>, <code>stm32f401vch7</code>, <code>stm32f401vct6</code>, <code>stm32f401vct7</code>, <code>stm32f401vdh6</code>, <code>stm32f401vdt6</code>, <code>stm32f401veh6</code>, <code>stm32f401veh7</code>, <code>stm32f401vet6</code>, <code>stm32f401vet7</code>.</p>"},{"location":"reference/targets/#stm32f405","title":"STM32F405","text":"<p><code>stm32f405oey6</code>, <code>stm32f405ogy6</code>, <code>stm32f405rgt6</code>, <code>stm32f405rgt7</code>, <code>stm32f405vgt6</code>, <code>stm32f405vgt7</code>, <code>stm32f405zgt6</code>, <code>stm32f405zgt7</code>.</p>"},{"location":"reference/targets/#stm32f407","title":"STM32F407","text":"<p><code>stm32f407ieh6</code>, <code>stm32f407ieh7</code>, <code>stm32f407iet6</code>, <code>stm32f407iet7</code>, <code>stm32f407igh6</code>, <code>stm32f407igh7</code>, <code>stm32f407igt6</code>, <code>stm32f407igt7</code>, <code>stm32f407vet6</code>, <code>stm32f407vgt6</code>, <code>stm32f407vgt7</code>, <code>stm32f407zet6</code>, <code>stm32f407zet7</code>, <code>stm32f407zgt6</code>, <code>stm32f407zgt7</code>.</p>"},{"location":"reference/targets/#stm32f410","title":"STM32F410","text":"<p><code>stm32f410c8t3</code>, <code>stm32f410c8t6</code>, <code>stm32f410c8t7</code>, <code>stm32f410c8u6</code>, <code>stm32f410c8u7</code>, <code>stm32f410cbt3</code>, <code>stm32f410cbt6</code>, <code>stm32f410cbt7</code>, <code>stm32f410cbu3</code>, <code>stm32f410cbu6</code>, <code>stm32f410cbu7</code>, <code>stm32f410r8i3</code>, <code>stm32f410r8i6</code>, <code>stm32f410r8i7</code>, <code>stm32f410r8t6</code>, <code>stm32f410rbi3</code>, <code>stm32f410rbi6</code>, <code>stm32f410rbi7</code>, <code>stm32f410rbt3</code>, <code>stm32f410rbt6</code>, <code>stm32f410rbt7</code>, <code>stm32f410t8y6</code>, <code>stm32f410tby3</code>, <code>stm32f410tby6</code>, <code>stm32f410tby7</code>.</p>"},{"location":"reference/targets/#stm32f411","title":"STM32F411","text":"<p><code>stm32f411ccu6</code>, <code>stm32f411ccu7</code>, <code>stm32f411ccy6</code>, <code>stm32f411ccy7</code>, <code>stm32f411ceu3</code>, <code>stm32f411ceu6</code>, <code>stm32f411ceu7</code>, <code>stm32f411cey3</code>, <code>stm32f411cey6</code>, <code>stm32f411cey7</code>, <code>stm32f411rct6</code>, <code>stm32f411rct7</code>, <code>stm32f411ret6</code>, <code>stm32f411ret7</code>, <code>stm32f411vch6</code>, <code>stm32f411vct6</code>, <code>stm32f411veh6</code>, <code>stm32f411vet6</code>.</p>"},{"location":"reference/targets/#stm32f412","title":"STM32F412","text":"<p><code>stm32f412ceu6</code>, <code>stm32f412cgu6</code>, <code>stm32f412ret6</code>, <code>stm32f412ret7</code>, <code>stm32f412rey6</code>, <code>stm32f412rey6p</code>, <code>stm32f412rey7</code>, <code>stm32f412rey7p</code>, <code>stm32f412rgt6</code>, <code>stm32f412rgy6</code>, <code>stm32f412rgy6p</code>, <code>stm32f412veh3</code>, <code>stm32f412veh6</code>, <code>stm32f412veh7</code>, <code>stm32f412vet3</code>, <code>stm32f412vet6</code>, <code>stm32f412vet7</code>, <code>stm32f412vgh6</code>, <code>stm32f412vgh7</code>, <code>stm32f412vgt6</code>, <code>stm32f412vgt7</code>, <code>stm32f412zej3</code>, <code>stm32f412zej6</code>, <code>stm32f412zej7</code>, <code>stm32f412zet3</code>, <code>stm32f412zet6</code>, <code>stm32f412zet7</code>, <code>stm32f412zgj6</code>, <code>stm32f412zgj7</code>, <code>stm32f412zgt6</code>, <code>stm32f412zgt7</code>.</p>"},{"location":"reference/targets/#stm32f413","title":"STM32F413","text":"<p><code>stm32f413cgu3</code>, <code>stm32f413cgu6</code>, <code>stm32f413cgu7</code>, <code>stm32f413chu3</code>, <code>stm32f413chu6</code>, <code>stm32f413chu7</code>, <code>stm32f413mgy3</code>, <code>stm32f413mgy6</code>, <code>stm32f413mgy7</code>, <code>stm32f413mhy3</code>, <code>stm32f413mhy6</code>, <code>stm32f413mhy7</code>, <code>stm32f413rgt3</code>, <code>stm32f413rgt6</code>, <code>stm32f413rgt7</code>, <code>stm32f413rht3</code>, <code>stm32f413rht6</code>, <code>stm32f413rht7</code>, <code>stm32f413vgh3</code>, <code>stm32f413vgh6</code>, <code>stm32f413vgh7</code>, <code>stm32f413vgt3</code>, <code>stm32f413vgt6</code>, <code>stm32f413vgt7</code>, <code>stm32f413vhh3</code>, <code>stm32f413vhh6</code>, <code>stm32f413vhh7</code>, <code>stm32f413vht3</code>, <code>stm32f413vht6</code>, <code>stm32f413vht7</code>, <code>stm32f413zgj3</code>, <code>stm32f413zgj6</code>, <code>stm32f413zgj7</code>, <code>stm32f413zgt3</code>, <code>stm32f413zgt6</code>, <code>stm32f413zgt7</code>, <code>stm32f413zhj3</code>, <code>stm32f413zhj6</code>, <code>stm32f413zhj7</code>, <code>stm32f413zht3</code>, <code>stm32f413zht6</code>, <code>stm32f413zht7</code>.</p>"},{"location":"reference/targets/#stm32f415","title":"STM32F415","text":"<p><code>stm32f415ogy6</code>, <code>stm32f415rgt6</code>, <code>stm32f415vgt6</code>, <code>stm32f415zgt6</code>.</p>"},{"location":"reference/targets/#stm32f417","title":"STM32F417","text":"<p><code>stm32f417ieh6</code>, <code>stm32f417iet6</code>, <code>stm32f417igh6</code>, <code>stm32f417igh7</code>, <code>stm32f417igt6</code>, <code>stm32f417igt7</code>, <code>stm32f417vet6</code>, <code>stm32f417vgt6</code>, <code>stm32f417vgt7</code>, <code>stm32f417zet6</code>, <code>stm32f417zgt6</code>.</p>"},{"location":"reference/targets/#stm32f423","title":"STM32F423","text":"<p><code>stm32f423chu3</code>, <code>stm32f423chu6</code>, <code>stm32f423chu7</code>, <code>stm32f423mhy3</code>, <code>stm32f423mhy6</code>, <code>stm32f423mhy7</code>, <code>stm32f423rht3</code>, <code>stm32f423rht6</code>, <code>stm32f423rht7</code>, <code>stm32f423vhh3</code>, <code>stm32f423vhh6</code>, <code>stm32f423vhh7</code>, <code>stm32f423vht3</code>, <code>stm32f423vht6</code>, <code>stm32f423vht7</code>, <code>stm32f423zhj3</code>, <code>stm32f423zhj6</code>, <code>stm32f423zhj7</code>, <code>stm32f423zht3</code>, <code>stm32f423zht6</code>, <code>stm32f423zht7</code>.</p>"},{"location":"reference/targets/#stm32f427","title":"STM32F427","text":"<p><code>stm32f427agh6</code>, <code>stm32f427aih6</code>, <code>stm32f427igh6</code>, <code>stm32f427igt6</code>, <code>stm32f427iih6</code>, <code>stm32f427iih7</code>, <code>stm32f427iit6</code>, <code>stm32f427iit7</code>, <code>stm32f427vgt6</code>, <code>stm32f427vit6</code>, <code>stm32f427vit7</code>, <code>stm32f427zgt6</code>, <code>stm32f427zit6</code>, <code>stm32f427zit7</code>.</p>"},{"location":"reference/targets/#stm32f429","title":"STM32F429","text":"<p><code>stm32f429agh6</code>, <code>stm32f429aih6</code>, <code>stm32f429bet6</code>, <code>stm32f429bgt6</code>, <code>stm32f429bit6</code>, <code>stm32f429bit7</code>, <code>stm32f429ieh6</code>, <code>stm32f429iet6</code>, <code>stm32f429igh6</code>, <code>stm32f429igt6</code>, <code>stm32f429iih6</code>, <code>stm32f429iit6</code>, <code>stm32f429neh6</code>, <code>stm32f429ngh6</code>, <code>stm32f429nih6</code>, <code>stm32f429nih7</code>, <code>stm32f429vet6</code>, <code>stm32f429vgt6</code>, <code>stm32f429vit6</code>, <code>stm32f429zet6</code>, <code>stm32f429zgt6</code>, <code>stm32f429zgy6</code>, <code>stm32f429zit6</code>, <code>stm32f429zit7</code>, <code>stm32f429ziy6</code>, <code>stm32f429ziy7</code>.</p>"},{"location":"reference/targets/#stm32f437","title":"STM32F437","text":"<p><code>stm32f437aih6</code>, <code>stm32f437igh6</code>, <code>stm32f437igt6</code>, <code>stm32f437iih6</code>, <code>stm32f437iih7</code>, <code>stm32f437iit6</code>, <code>stm32f437iit7</code>, <code>stm32f437vgt6</code>, <code>stm32f437vgt7</code>, <code>stm32f437vit6</code>, <code>stm32f437vit7</code>, <code>stm32f437zgt6</code>, <code>stm32f437zit6</code>, <code>stm32f437zit7</code>.</p>"},{"location":"reference/targets/#stm32f439","title":"STM32F439","text":"<p><code>stm32f439aih6</code>, <code>stm32f439bgt6</code>, <code>stm32f439bit6</code>, <code>stm32f439bit7</code>, <code>stm32f439igh6</code>, <code>stm32f439igt6</code>, <code>stm32f439iih6</code>, <code>stm32f439iih7</code>, <code>stm32f439iit6</code>, <code>stm32f439iit7</code>, <code>stm32f439ngh6</code>, <code>stm32f439nih6</code>, <code>stm32f439vgt6</code>, <code>stm32f439vit6</code>, <code>stm32f439zgt6</code>, <code>stm32f439zgt7</code>, <code>stm32f439zgy6</code>, <code>stm32f439zgy7</code>, <code>stm32f439zit6</code>, <code>stm32f439ziy6</code>.</p>"},{"location":"reference/targets/#stm32f446","title":"STM32F446","text":"<p><code>stm32f446mcy6</code>, <code>stm32f446mey6</code>, <code>stm32f446rct6</code>, <code>stm32f446rct7</code>, <code>stm32f446ret6</code>, <code>stm32f446ret7</code>, <code>stm32f446vct6</code>, <code>stm32f446vct7</code>, <code>stm32f446vet6</code>, <code>stm32f446vet7</code>, <code>stm32f446zch6</code>, <code>stm32f446zch7</code>, <code>stm32f446zcj6</code>, <code>stm32f446zcj7</code>, <code>stm32f446zct6</code>, <code>stm32f446zct7</code>, <code>stm32f446zeh6</code>, <code>stm32f446zeh7</code>, <code>stm32f446zej6</code>, <code>stm32f446zej7</code>, <code>stm32f446zet6</code>, <code>stm32f446zet7</code>.</p>"},{"location":"reference/targets/#stm32f469","title":"STM32F469","text":"<p><code>stm32f469aeh6</code>, <code>stm32f469aeh7</code>, <code>stm32f469aey6</code>, <code>stm32f469agh6</code>, <code>stm32f469agy6</code>, <code>stm32f469aih6</code>, <code>stm32f469aiy6</code>, <code>stm32f469bet6</code>, <code>stm32f469bgt6</code>, <code>stm32f469bit6</code>, <code>stm32f469bit7</code>, <code>stm32f469ieh6</code>, <code>stm32f469iet6</code>, <code>stm32f469igh6</code>, <code>stm32f469igt6</code>, <code>stm32f469iih6</code>, <code>stm32f469iit6</code>, <code>stm32f469neh6</code>, <code>stm32f469ngh6</code>, <code>stm32f469nih6</code>, <code>stm32f469nih7</code>, <code>stm32f469vet6</code>, <code>stm32f469vgt6</code>, <code>stm32f469vit6</code>, <code>stm32f469zet6</code>, <code>stm32f469zgt6</code>, <code>stm32f469zit6</code>.</p>"},{"location":"reference/targets/#stm32f479","title":"STM32F479","text":"<p><code>stm32f479agh6</code>, <code>stm32f479agy6</code>, <code>stm32f479aih6</code>, <code>stm32f479aiy6</code>, <code>stm32f479bgt6</code>, <code>stm32f479bit6</code>, <code>stm32f479igh6</code>, <code>stm32f479igt6</code>, <code>stm32f479igt7</code>, <code>stm32f479iih6</code>, <code>stm32f479iih7</code>, <code>stm32f479iit6</code>, <code>stm32f479iit7</code>, <code>stm32f479ngh6</code>, <code>stm32f479nih6</code>, <code>stm32f479vgt6</code>, <code>stm32f479vit6</code>, <code>stm32f479zgt6</code>, <code>stm32f479zit6</code>.</p>"},{"location":"reference/targets/#stm32f7","title":"STM32F7","text":""},{"location":"reference/targets/#stm32f722","title":"STM32F722","text":"<p><code>stm32f722ick6</code>, <code>stm32f722ict6</code>, <code>stm32f722iek6</code>, <code>stm32f722iek7</code>, <code>stm32f722iet6</code>, <code>stm32f722iet7</code>, <code>stm32f722rct6</code>, <code>stm32f722ret6</code>, <code>stm32f722ret7</code>, <code>stm32f722vct6</code>, <code>stm32f722vet6</code>, <code>stm32f722vet7</code>, <code>stm32f722zct6</code>, <code>stm32f722zet6</code>, <code>stm32f722zet7</code>.</p>"},{"location":"reference/targets/#stm32f723","title":"STM32F723","text":"<p><code>stm32f723ick6</code>, <code>stm32f723ict6</code>, <code>stm32f723iek6</code>, <code>stm32f723iek7</code>, <code>stm32f723iet6</code>, <code>stm32f723iet7</code>, <code>stm32f723vct6</code>, <code>stm32f723vcy6</code>, <code>stm32f723vet6</code>, <code>stm32f723vey6</code>, <code>stm32f723zci6</code>, <code>stm32f723zct6</code>, <code>stm32f723zei6</code>, <code>stm32f723zei7</code>, <code>stm32f723zet6</code>, <code>stm32f723zet7</code>.</p>"},{"location":"reference/targets/#stm32f730","title":"STM32F730","text":"<p><code>stm32f730i8k6</code>, <code>stm32f730i8k7</code>, <code>stm32f730r8t6</code>, <code>stm32f730r8t7</code>, <code>stm32f730v8t6</code>, <code>stm32f730v8t7</code>, <code>stm32f730z8t6</code>, <code>stm32f730z8t7</code>.</p>"},{"location":"reference/targets/#stm32f732","title":"STM32F732","text":"<p><code>stm32f732iek6</code>, <code>stm32f732iek7</code>, <code>stm32f732iet6</code>, <code>stm32f732iet7</code>, <code>stm32f732ret6</code>, <code>stm32f732ret7</code>, <code>stm32f732vet6</code>, <code>stm32f732vet7</code>, <code>stm32f732zet6</code>, <code>stm32f732zet7</code>.</p>"},{"location":"reference/targets/#stm32f733","title":"STM32F733","text":"<p><code>stm32f733iek6</code>, <code>stm32f733iek7</code>, <code>stm32f733iet6</code>, <code>stm32f733iet7</code>, <code>stm32f733vet6</code>, <code>stm32f733vey6</code>, <code>stm32f733zei6</code>, <code>stm32f733zei7</code>, <code>stm32f733zet6</code>, <code>stm32f733zet7</code>.</p>"},{"location":"reference/targets/#stm32f745","title":"STM32F745","text":"<p><code>stm32f745iek6</code>, <code>stm32f745iek7</code>, <code>stm32f745iet6</code>, <code>stm32f745iet7</code>, <code>stm32f745igk6</code>, <code>stm32f745igk7</code>, <code>stm32f745igt6</code>, <code>stm32f745igt7</code>, <code>stm32f745veh6</code>, <code>stm32f745veh7</code>, <code>stm32f745vet6</code>, <code>stm32f745vet7</code>, <code>stm32f745vgh6</code>, <code>stm32f745vgt6</code>, <code>stm32f745zet6</code>, <code>stm32f745zgt6</code>, <code>stm32f745zgt7</code>.</p>"},{"location":"reference/targets/#stm32f746","title":"STM32F746","text":"<p><code>stm32f746bet6</code>, <code>stm32f746bgt6</code>, <code>stm32f746bgt7</code>, <code>stm32f746iek6</code>, <code>stm32f746iet6</code>, <code>stm32f746igk6</code>, <code>stm32f746igk7</code>, <code>stm32f746igt6</code>, <code>stm32f746igt7</code>, <code>stm32f746neh6</code>, <code>stm32f746ngh6</code>, <code>stm32f746ngh7</code>, <code>stm32f746veh6</code>, <code>stm32f746vet6</code>, <code>stm32f746vgh6</code>, <code>stm32f746vgh7</code>, <code>stm32f746vgt6</code>, <code>stm32f746vgt7</code>, <code>stm32f746zet6</code>, <code>stm32f746zey6</code>, <code>stm32f746zgt6</code>, <code>stm32f746zgt7</code>, <code>stm32f746zgy6</code>, <code>stm32f746zgy7</code>.</p>"},{"location":"reference/targets/#stm32f750","title":"STM32F750","text":"<p><code>stm32f750n8h6</code>, <code>stm32f750n8h7</code>, <code>stm32f750v8t6</code>, <code>stm32f750v8t7</code>, <code>stm32f750z8t6</code>, <code>stm32f750z8t7</code>.</p>"},{"location":"reference/targets/#stm32f756","title":"STM32F756","text":"<p><code>stm32f756bgt6</code>, <code>stm32f756igk6</code>, <code>stm32f756igt6</code>, <code>stm32f756ngh6</code>, <code>stm32f756vgh6</code>, <code>stm32f756vgt6</code>, <code>stm32f756zgt6</code>, <code>stm32f756zgy6</code>.</p>"},{"location":"reference/targets/#stm32f765","title":"STM32F765","text":"<p><code>stm32f765bgt6</code>, <code>stm32f765bit6</code>, <code>stm32f765igk6</code>, <code>stm32f765igt6</code>, <code>stm32f765iik6</code>, <code>stm32f765iik7</code>, <code>stm32f765iit6</code>, <code>stm32f765iit7</code>, <code>stm32f765ngh6</code>, <code>stm32f765ngh7</code>, <code>stm32f765nih6</code>, <code>stm32f765nih7</code>, <code>stm32f765vgh6</code>, <code>stm32f765vgh7</code>, <code>stm32f765vgt6</code>, <code>stm32f765vgt7</code>, <code>stm32f765vih6</code>, <code>stm32f765vit6</code>, <code>stm32f765zgt6</code>, <code>stm32f765zgt7</code>, <code>stm32f765zit6</code>, <code>stm32f765zit7</code>.</p>"},{"location":"reference/targets/#stm32f767","title":"STM32F767","text":"<p><code>stm32f767bgt6</code>, <code>stm32f767bit6</code>, <code>stm32f767igk6</code>, <code>stm32f767igt6</code>, <code>stm32f767iik6</code>, <code>stm32f767iit6</code>, <code>stm32f767ngh6</code>, <code>stm32f767nih6</code>, <code>stm32f767nih7</code>, <code>stm32f767vgh6</code>, <code>stm32f767vgh7</code>, <code>stm32f767vgt6</code>, <code>stm32f767vgt7</code>, <code>stm32f767vih6</code>, <code>stm32f767vih7</code>, <code>stm32f767vit6</code>, <code>stm32f767vit7</code>, <code>stm32f767zgt6</code>, <code>stm32f767zit6</code>.</p>"},{"location":"reference/targets/#stm32f768","title":"STM32F768","text":"<p><code>stm32f768aiy6</code>.</p>"},{"location":"reference/targets/#stm32f769","title":"STM32F769","text":"<p><code>stm32f769agy6</code>, <code>stm32f769aiy6</code>, <code>stm32f769bgt6</code>, <code>stm32f769bit6</code>, <code>stm32f769igt6</code>, <code>stm32f769iit6</code>, <code>stm32f769ngh6</code>, <code>stm32f769nih6</code>.</p>"},{"location":"reference/targets/#stm32f777","title":"STM32F777","text":"<p><code>stm32f777bit6</code>, <code>stm32f777iik6</code>, <code>stm32f777iik7</code>, <code>stm32f777iit6</code>, <code>stm32f777iit7</code>, <code>stm32f777nih6</code>, <code>stm32f777nih7</code>, <code>stm32f777vih6</code>, <code>stm32f777vih7</code>, <code>stm32f777vit6</code>, <code>stm32f777vit7</code>, <code>stm32f777zit6</code>.</p>"},{"location":"reference/targets/#stm32f778","title":"STM32F778","text":"<p><code>stm32f778aiy6</code>.</p>"},{"location":"reference/targets/#stm32f779","title":"STM32F779","text":"<p><code>stm32f779aiy6</code>, <code>stm32f779bit6</code>, <code>stm32f779iit6</code>, <code>stm32f779nih6</code>.</p>"},{"location":"reference/targets/#stm32g0","title":"STM32G0","text":""},{"location":"reference/targets/#stm32g030","title":"STM32G030","text":"<p><code>stm32g030c6t6</code>, <code>stm32g030c8t6</code>, <code>stm32g030f6p6</code>, <code>stm32g030j6m6</code>, <code>stm32g030k6t6</code>, <code>stm32g030k8t6</code>.</p>"},{"location":"reference/targets/#stm32g031","title":"STM32G031","text":"<p><code>stm32g031c4t6</code>, <code>stm32g031c4u6</code>, <code>stm32g031c6t6</code>, <code>stm32g031c6u6</code>, <code>stm32g031c8t6</code>, <code>stm32g031c8t7</code>, <code>stm32g031c8u6</code>, <code>stm32g031c8u7</code>, <code>stm32g031f4p3</code>, <code>stm32g031f4p6</code>, <code>stm32g031f4p7</code>, <code>stm32g031f6p6</code>, <code>stm32g031f6p7</code>, <code>stm32g031f8p6</code>, <code>stm32g031g4u6</code>, <code>stm32g031g6u3</code>, <code>stm32g031g6u6</code>, <code>stm32g031g6u7</code>, <code>stm32g031g8u3</code>, <code>stm32g031g8u6</code>, <code>stm32g031g8u7</code>, <code>stm32g031j4m6</code>, <code>stm32g031j6m3</code>, <code>stm32g031j6m6</code>, <code>stm32g031j6m7</code>, <code>stm32g031k4t3</code>, <code>stm32g031k4t6</code>, <code>stm32g031k4t7</code>, <code>stm32g031k4u3</code>, <code>stm32g031k4u6</code>, <code>stm32g031k4u7</code>, <code>stm32g031k6t6</code>, <code>stm32g031k6u6</code>, <code>stm32g031k8t3</code>, <code>stm32g031k8t6</code>, <code>stm32g031k8t7</code>, <code>stm32g031k8u3</code>, <code>stm32g031k8u6</code>, <code>stm32g031k8u7</code>, <code>stm32g031y8y6</code>.</p>"},{"location":"reference/targets/#stm32g041","title":"STM32G041","text":"<p><code>stm32g041c6t6</code>, <code>stm32g041c6u6</code>, <code>stm32g041c8t6</code>, <code>stm32g041c8u6</code>, <code>stm32g041f6p6</code>, <code>stm32g041f8p6</code>, <code>stm32g041g6u6</code>, <code>stm32g041g8u6</code>, <code>stm32g041j6m6</code>, <code>stm32g041k6t6</code>, <code>stm32g041k6u6</code>, <code>stm32g041k8t6</code>, <code>stm32g041k8u6</code>, <code>stm32g041y8y6</code>.</p>"},{"location":"reference/targets/#stm32g050","title":"STM32G050","text":"<p><code>stm32g050c6t6</code>, <code>stm32g050c8t6</code>, <code>stm32g050f6p6</code>, <code>stm32g050k6t6</code>, <code>stm32g050k8t6</code>.</p>"},{"location":"reference/targets/#stm32g051","title":"STM32G051","text":"<p><code>stm32g051c6t6</code>, <code>stm32g051c6u6</code>, <code>stm32g051c8t6</code>, <code>stm32g051c8u6</code>, <code>stm32g051f6p6</code>, <code>stm32g051f8p6</code>, <code>stm32g051f8y6</code>, <code>stm32g051g6u6</code>, <code>stm32g051g8u3</code>, <code>stm32g051g8u6</code>, <code>stm32g051g8u7</code>, <code>stm32g051k6t6</code>, <code>stm32g051k6t7</code>, <code>stm32g051k6u6</code>, <code>stm32g051k6u7</code>, <code>stm32g051k8t6</code>, <code>stm32g051k8t7</code>, <code>stm32g051k8u6</code>, <code>stm32g051k8u7</code>.</p>"},{"location":"reference/targets/#stm32g061","title":"STM32G061","text":"<p><code>stm32g061c6t6</code>, <code>stm32g061c6u6</code>, <code>stm32g061c8t6</code>, <code>stm32g061c8u6</code>, <code>stm32g061f6p6</code>, <code>stm32g061f8p6</code>, <code>stm32g061f8y6</code>, <code>stm32g061g6u6</code>, <code>stm32g061g8u6</code>, <code>stm32g061k6t6</code>, <code>stm32g061k6u6</code>, <code>stm32g061k8t6</code>, <code>stm32g061k8u6</code>.</p>"},{"location":"reference/targets/#stm32g070","title":"STM32G070","text":"<p><code>stm32g070cbt6</code>, <code>stm32g070kbt6</code>, <code>stm32g070rbt6</code>.</p>"},{"location":"reference/targets/#stm32g071","title":"STM32G071","text":"<p><code>stm32g071c6t6</code>, <code>stm32g071c6u3</code>, <code>stm32g071c6u6</code>, <code>stm32g071c6u7</code>, <code>stm32g071c8t3</code>, <code>stm32g071c8t6</code>, <code>stm32g071c8t7</code>, <code>stm32g071c8u3</code>, <code>stm32g071c8u6</code>, <code>stm32g071c8u7</code>, <code>stm32g071cbt3</code>, <code>stm32g071cbt6</code>, <code>stm32g071cbt7</code>, <code>stm32g071cbu3</code>, <code>stm32g071cbu6</code>, <code>stm32g071cbu7</code>, <code>stm32g071eby6</code>, <code>stm32g071g6u3</code>, <code>stm32g071g6u6</code>, <code>stm32g071g6u7</code>, <code>stm32g071g8u6</code>, <code>stm32g071g8u6n</code>, <code>stm32g071gbu3</code>, <code>stm32g071gbu3n</code>, <code>stm32g071gbu6</code>, <code>stm32g071gbu6n</code>, <code>stm32g071gbu7</code>, <code>stm32g071gbu7n</code>, <code>stm32g071k6t6</code>, <code>stm32g071k6u3</code>, <code>stm32g071k6u6</code>, <code>stm32g071k6u7</code>, <code>stm32g071k8t3</code>, <code>stm32g071k8t3n</code>, <code>stm32g071k8t6</code>, <code>stm32g071k8t6n</code>, <code>stm32g071k8t7</code>, <code>stm32g071k8t7n</code>, <code>stm32g071k8u3</code>, <code>stm32g071k8u3n</code>, <code>stm32g071k8u6</code>, <code>stm32g071k8u6n</code>, <code>stm32g071k8u7</code>, <code>stm32g071k8u7n</code>, <code>stm32g071kbt3</code>, <code>stm32g071kbt3n</code>, <code>stm32g071kbt6</code>, <code>stm32g071kbt6n</code>, <code>stm32g071kbt7</code>, <code>stm32g071kbt7n</code>, <code>stm32g071kbu3</code>, <code>stm32g071kbu3n</code>, <code>stm32g071kbu6</code>, <code>stm32g071kbu6n</code>, <code>stm32g071kbu7</code>, <code>stm32g071kbu7n</code>, <code>stm32g071r6t6</code>, <code>stm32g071r8t6</code>, <code>stm32g071rbi6</code>, <code>stm32g071rbt6</code>.</p>"},{"location":"reference/targets/#stm32g081","title":"STM32G081","text":"<p><code>stm32g081cbt6</code>, <code>stm32g081cbu6</code>, <code>stm32g081eby6</code>, <code>stm32g081gbu6</code>, <code>stm32g081gbu6n</code>, <code>stm32g081kbt6</code>, <code>stm32g081kbt6n</code>, <code>stm32g081kbu6</code>, <code>stm32g081kbu6n</code>, <code>stm32g081rbi3</code>, <code>stm32g081rbi6</code>, <code>stm32g081rbi7</code>, <code>stm32g081rbt3</code>, <code>stm32g081rbt6</code>, <code>stm32g081rbt7</code>.</p>"},{"location":"reference/targets/#stm32g0b0","title":"STM32G0B0","text":"<p><code>stm32g0b0cet6</code>, <code>stm32g0b0ket6</code>, <code>stm32g0b0ret6</code>, <code>stm32g0b0vet6</code>.</p>"},{"location":"reference/targets/#stm32g0b1","title":"STM32G0B1","text":"<p><code>stm32g0b1cbt6</code>, <code>stm32g0b1cbt6n</code>, <code>stm32g0b1cbu6</code>, <code>stm32g0b1cbu6n</code>, <code>stm32g0b1cct6</code>, <code>stm32g0b1cct6n</code>, <code>stm32g0b1ccu6</code>, <code>stm32g0b1ccu6n</code>, <code>stm32g0b1cet6</code>, <code>stm32g0b1cet6n</code>, <code>stm32g0b1ceu6</code>, <code>stm32g0b1ceu6n</code>, <code>stm32g0b1kbt3</code>, <code>stm32g0b1kbt3n</code>, <code>stm32g0b1kbt6</code>, <code>stm32g0b1kbt6n</code>, <code>stm32g0b1kbt7</code>, <code>stm32g0b1kbt7n</code>, <code>stm32g0b1kbu3</code>, <code>stm32g0b1kbu3n</code>, <code>stm32g0b1kbu6</code>, <code>stm32g0b1kbu6n</code>, <code>stm32g0b1kbu7</code>, <code>stm32g0b1kbu7n</code>, <code>stm32g0b1kct6</code>, <code>stm32g0b1kct6n</code>, <code>stm32g0b1kcu6</code>, <code>stm32g0b1kcu6n</code>, <code>stm32g0b1ket6</code>, <code>stm32g0b1ket6n</code>, <code>stm32g0b1keu6</code>, <code>stm32g0b1keu6n</code>, <code>stm32g0b1mbt6</code>, <code>stm32g0b1mct6</code>, <code>stm32g0b1met6</code>, <code>stm32g0b1ney6</code>, <code>stm32g0b1rbi6n</code>, <code>stm32g0b1rbt6</code>, <code>stm32g0b1rbt6n</code>, <code>stm32g0b1rci6n</code>, <code>stm32g0b1rci7n</code>, <code>stm32g0b1rct6</code>, <code>stm32g0b1rct6n</code>, <code>stm32g0b1rct7</code>, <code>stm32g0b1rct7n</code>, <code>stm32g0b1rei6n</code>, <code>stm32g0b1ret6</code>, <code>stm32g0b1ret6n</code>, <code>stm32g0b1vbi6</code>, <code>stm32g0b1vbt6</code>, <code>stm32g0b1vci6</code>, <code>stm32g0b1vct6</code>, <code>stm32g0b1vei6</code>, <code>stm32g0b1vet6</code>.</p>"},{"location":"reference/targets/#stm32g0c1","title":"STM32G0C1","text":"<p><code>stm32g0c1cct6</code>, <code>stm32g0c1cct6n</code>, <code>stm32g0c1ccu6</code>, <code>stm32g0c1ccu6n</code>, <code>stm32g0c1cet6</code>, <code>stm32g0c1cet6n</code>, <code>stm32g0c1ceu6</code>, <code>stm32g0c1ceu6n</code>, <code>stm32g0c1kct6</code>, <code>stm32g0c1kct6n</code>, <code>stm32g0c1kcu6</code>, <code>stm32g0c1kcu6n</code>, <code>stm32g0c1ket6</code>, <code>stm32g0c1ket6n</code>, <code>stm32g0c1keu6</code>, <code>stm32g0c1keu6n</code>, <code>stm32g0c1mct6</code>, <code>stm32g0c1met6</code>, <code>stm32g0c1ney6</code>, <code>stm32g0c1rci6n</code>, <code>stm32g0c1rct6</code>, <code>stm32g0c1rct6n</code>, <code>stm32g0c1rei6n</code>, <code>stm32g0c1ret6</code>, <code>stm32g0c1ret6n</code>, <code>stm32g0c1vci6</code>, <code>stm32g0c1vct6</code>, <code>stm32g0c1vei6</code>, <code>stm32g0c1vet6</code>.</p>"},{"location":"reference/targets/#stm32g4","title":"STM32G4","text":""},{"location":"reference/targets/#stm32g431","title":"STM32G431","text":"<p><code>stm32g431c6t6</code>, <code>stm32g431c6u6</code>, <code>stm32g431c8t3</code>, <code>stm32g431c8t6</code>, <code>stm32g431c8t7</code>, <code>stm32g431c8u3</code>, <code>stm32g431c8u6</code>, <code>stm32g431c8u7</code>, <code>stm32g431cbt3</code>, <code>stm32g431cbt3z</code>, <code>stm32g431cbt6</code>, <code>stm32g431cbt6z</code>, <code>stm32g431cbt7</code>, <code>stm32g431cbt7z</code>, <code>stm32g431cbu3</code>, <code>stm32g431cbu6</code>, <code>stm32g431cbu7</code>, <code>stm32g431cby3</code>, <code>stm32g431cby6</code>, <code>stm32g431cby7</code>, <code>stm32g431k6t3</code>, <code>stm32g431k6t6</code>, <code>stm32g431k6t7</code>, <code>stm32g431k6u3</code>, <code>stm32g431k6u6</code>, <code>stm32g431k6u7</code>, <code>stm32g431k8t3</code>, <code>stm32g431k8t6</code>, <code>stm32g431k8t7</code>, <code>stm32g431k8u3</code>, <code>stm32g431k8u6</code>, <code>stm32g431k8u7</code>, <code>stm32g431kbt3</code>, <code>stm32g431kbt6</code>, <code>stm32g431kbt7</code>, <code>stm32g431kbu3</code>, <code>stm32g431kbu6</code>, <code>stm32g431kbu7</code>, <code>stm32g431m6t6</code>, <code>stm32g431m8t6</code>, <code>stm32g431mbt3</code>, <code>stm32g431mbt6</code>, <code>stm32g431mbt7</code>, <code>stm32g431r6i6</code>, <code>stm32g431r6t6</code>, <code>stm32g431r8i6</code>, <code>stm32g431r8t6</code>, <code>stm32g431rbi3</code>, <code>stm32g431rbi6</code>, <code>stm32g431rbi7</code>, <code>stm32g431rbt3</code>, <code>stm32g431rbt3z</code>, <code>stm32g431rbt6</code>, <code>stm32g431rbt6z</code>, <code>stm32g431rbt7</code>, <code>stm32g431rbt7z</code>, <code>stm32g431v6t6</code>, <code>stm32g431v8t6</code>, <code>stm32g431vbt3</code>, <code>stm32g431vbt6</code>, <code>stm32g431vbt7</code>.</p>"},{"location":"reference/targets/#stm32g441","title":"STM32G441","text":"<p><code>stm32g441cbt3</code>, <code>stm32g441cbt6</code>, <code>stm32g441cbt7</code>, <code>stm32g441cbu3</code>, <code>stm32g441cbu6</code>, <code>stm32g441cbu7</code>, <code>stm32g441cby3</code>, <code>stm32g441cby6</code>, <code>stm32g441cby7</code>, <code>stm32g441kbt3</code>, <code>stm32g441kbt6</code>, <code>stm32g441kbt7</code>, <code>stm32g441kbu3</code>, <code>stm32g441kbu6</code>, <code>stm32g441kbu7</code>, <code>stm32g441mbt6</code>, <code>stm32g441rbi3</code>, <code>stm32g441rbi6</code>, <code>stm32g441rbi7</code>, <code>stm32g441rbt3</code>, <code>stm32g441rbt6</code>, <code>stm32g441rbt7</code>, <code>stm32g441vbt3</code>, <code>stm32g441vbt6</code>, <code>stm32g441vbt7</code>.</p>"},{"location":"reference/targets/#stm32g471","title":"STM32G471","text":"<p><code>stm32g471cct6</code>, <code>stm32g471ccu3</code>, <code>stm32g471ccu6</code>, <code>stm32g471ccu7</code>, <code>stm32g471cet3</code>, <code>stm32g471cet6</code>, <code>stm32g471cet7</code>, <code>stm32g471ceu3</code>, <code>stm32g471ceu6</code>, <code>stm32g471ceu7</code>, <code>stm32g471mct6</code>, <code>stm32g471met3</code>, <code>stm32g471met6</code>, <code>stm32g471met7</code>, <code>stm32g471mey6</code>, <code>stm32g471qct6</code>, <code>stm32g471qet6</code>, <code>stm32g471rct6</code>, <code>stm32g471ret3</code>, <code>stm32g471ret6</code>, <code>stm32g471ret7</code>, <code>stm32g471vch6</code>, <code>stm32g471vci6</code>, <code>stm32g471vct6</code>, <code>stm32g471veh3</code>, <code>stm32g471veh6</code>, <code>stm32g471veh7</code>, <code>stm32g471vei3</code>, <code>stm32g471vei6</code>, <code>stm32g471vei7</code>, <code>stm32g471vet3</code>, <code>stm32g471vet6</code>, <code>stm32g471vet7</code>.</p>"},{"location":"reference/targets/#stm32g473","title":"STM32G473","text":"<p><code>stm32g473cbt3</code>, <code>stm32g473cbt6</code>, <code>stm32g473cbt7</code>, <code>stm32g473cbu3</code>, <code>stm32g473cbu6</code>, <code>stm32g473cbu7</code>, <code>stm32g473cct3</code>, <code>stm32g473cct6</code>, <code>stm32g473cct7</code>, <code>stm32g473ccu3</code>, <code>stm32g473ccu6</code>, <code>stm32g473ccu7</code>, <code>stm32g473cet3</code>, <code>stm32g473cet6</code>, <code>stm32g473cet7</code>, <code>stm32g473ceu3</code>, <code>stm32g473ceu6</code>, <code>stm32g473ceu7</code>, <code>stm32g473mbt6</code>, <code>stm32g473mct3</code>, <code>stm32g473mct6</code>, <code>stm32g473mct7</code>, <code>stm32g473met3</code>, <code>stm32g473met6</code>, <code>stm32g473met7</code>, <code>stm32g473mey3</code>, <code>stm32g473mey6</code>, <code>stm32g473mey7</code>, <code>stm32g473pbi6</code>, <code>stm32g473pci6</code>, <code>stm32g473pei6</code>, <code>stm32g473qbt6</code>, <code>stm32g473qct6</code>, <code>stm32g473qet6</code>, <code>stm32g473qet6z</code>, <code>stm32g473rbt6</code>, <code>stm32g473rct6</code>, <code>stm32g473ret3</code>, <code>stm32g473ret3z</code>, <code>stm32g473ret6</code>, <code>stm32g473ret6z</code>, <code>stm32g473ret7</code>, <code>stm32g473ret7z</code>, <code>stm32g473vbh3</code>, <code>stm32g473vbh6</code>, <code>stm32g473vbh7</code>, <code>stm32g473vbt3</code>, <code>stm32g473vbt6</code>, <code>stm32g473vbt7</code>, <code>stm32g473vch3</code>, <code>stm32g473vch6</code>, <code>stm32g473vch7</code>, <code>stm32g473vct3</code>, <code>stm32g473vct6</code>, <code>stm32g473vct7</code>, <code>stm32g473veh3</code>, <code>stm32g473veh6</code>, <code>stm32g473veh7</code>, <code>stm32g473vet3</code>, <code>stm32g473vet6</code>, <code>stm32g473vet7</code>.</p>"},{"location":"reference/targets/#stm32g474","title":"STM32G474","text":"<p><code>stm32g474cbt3</code>, <code>stm32g474cbt6</code>, <code>stm32g474cbt7</code>, <code>stm32g474cbu3</code>, <code>stm32g474cbu6</code>, <code>stm32g474cbu7</code>, <code>stm32g474cct3</code>, <code>stm32g474cct6</code>, <code>stm32g474cct7</code>, <code>stm32g474ccu3</code>, <code>stm32g474ccu6</code>, <code>stm32g474ccu7</code>, <code>stm32g474cet3</code>, <code>stm32g474cet6</code>, <code>stm32g474cet7</code>, <code>stm32g474ceu3</code>, <code>stm32g474ceu6</code>, <code>stm32g474ceu7</code>, <code>stm32g474mbt6</code>, <code>stm32g474mct6</code>, <code>stm32g474met3</code>, <code>stm32g474met6</code>, <code>stm32g474met7</code>, <code>stm32g474mey3</code>, <code>stm32g474mey6</code>, <code>stm32g474mey7</code>, <code>stm32g474pbi6</code>, <code>stm32g474pci6</code>, <code>stm32g474pei6</code>, <code>stm32g474qbt6</code>, <code>stm32g474qct6</code>, <code>stm32g474qet6</code>, <code>stm32g474rbt3</code>, <code>stm32g474rbt6</code>, <code>stm32g474rbt7</code>, <code>stm32g474rct3</code>, <code>stm32g474rct6</code>, <code>stm32g474rct7</code>, <code>stm32g474ret3</code>, <code>stm32g474ret6</code>, <code>stm32g474ret7</code>, <code>stm32g474vbh3</code>, <code>stm32g474vbh6</code>, <code>stm32g474vbh7</code>, <code>stm32g474vbt3</code>, <code>stm32g474vbt6</code>, <code>stm32g474vbt7</code>, <code>stm32g474vch6</code>, <code>stm32g474vct6</code>, <code>stm32g474veh3</code>, <code>stm32g474veh6</code>, <code>stm32g474veh7</code>, <code>stm32g474vet3</code>, <code>stm32g474vet6</code>, <code>stm32g474vet7</code>.</p>"},{"location":"reference/targets/#stm32g483","title":"STM32G483","text":"<p><code>stm32g483cet3</code>, <code>stm32g483cet6</code>, <code>stm32g483cet7</code>, <code>stm32g483ceu3</code>, <code>stm32g483ceu6</code>, <code>stm32g483ceu7</code>, <code>stm32g483met6</code>, <code>stm32g483mey6</code>, <code>stm32g483pei6</code>, <code>stm32g483qet6</code>, <code>stm32g483ret3</code>, <code>stm32g483ret6</code>, <code>stm32g483ret7</code>, <code>stm32g483veh6</code>, <code>stm32g483vet6</code>.</p>"},{"location":"reference/targets/#stm32g484","title":"STM32G484","text":"<p><code>stm32g484cet3</code>, <code>stm32g484cet6</code>, <code>stm32g484cet7</code>, <code>stm32g484ceu3</code>, <code>stm32g484ceu6</code>, <code>stm32g484ceu7</code>, <code>stm32g484met3</code>, <code>stm32g484met6</code>, <code>stm32g484met7</code>, <code>stm32g484mey3</code>, <code>stm32g484mey6</code>, <code>stm32g484mey7</code>, <code>stm32g484pei6</code>, <code>stm32g484qet3</code>, <code>stm32g484qet6</code>, <code>stm32g484qet7</code>, <code>stm32g484ret3</code>, <code>stm32g484ret6</code>, <code>stm32g484ret7</code>, <code>stm32g484veh6</code>, <code>stm32g484vet6</code>.</p>"},{"location":"reference/targets/#stm32g491","title":"STM32G491","text":"<p><code>stm32g491cct3</code>, <code>stm32g491cct6</code>, <code>stm32g491cct7</code>, <code>stm32g491ccu3</code>, <code>stm32g491ccu6</code>, <code>stm32g491ccu7</code>, <code>stm32g491cet3</code>, <code>stm32g491cet6</code>, <code>stm32g491cet7</code>, <code>stm32g491ceu3</code>, <code>stm32g491ceu6</code>, <code>stm32g491ceu7</code>, <code>stm32g491kcu6</code>, <code>stm32g491keu6</code>, <code>stm32g491mcs6</code>, <code>stm32g491mct6</code>, <code>stm32g491mes6</code>, <code>stm32g491met6</code>, <code>stm32g491rci6</code>, <code>stm32g491rct6</code>, <code>stm32g491rei6</code>, <code>stm32g491ret6</code>, <code>stm32g491ret6z</code>, <code>stm32g491rey6</code>, <code>stm32g491vct6</code>, <code>stm32g491vet6</code>.</p>"},{"location":"reference/targets/#stm32g4a1","title":"STM32G4A1","text":"<p><code>stm32g4a1cet6</code>, <code>stm32g4a1ceu6</code>, <code>stm32g4a1keu6</code>, <code>stm32g4a1mes6</code>, <code>stm32g4a1met6</code>, <code>stm32g4a1rei6</code>, <code>stm32g4a1ret6</code>, <code>stm32g4a1rey6</code>, <code>stm32g4a1vet6</code>.</p>"},{"location":"reference/targets/#stm32h7","title":"STM32H7","text":""},{"location":"reference/targets/#stm32h723","title":"STM32H723","text":"<p><code>stm32h723veh6</code>, <code>stm32h723vet6</code>, <code>stm32h723vgh6</code>, <code>stm32h723vgt6</code>, <code>stm32h723zei6</code>, <code>stm32h723zet6</code>, <code>stm32h723zgi6</code>, <code>stm32h723zgt6</code>.</p>"},{"location":"reference/targets/#stm32h725","title":"STM32H725","text":"<p><code>stm32h725aei6</code>, <code>stm32h725agi3</code>, <code>stm32h725agi6</code>, <code>stm32h725agi7</code>, <code>stm32h725iek6</code>, <code>stm32h725iet6</code>, <code>stm32h725igk3</code>, <code>stm32h725igk6</code>, <code>stm32h725igk7</code>, <code>stm32h725igt3</code>, <code>stm32h725igt6</code>, <code>stm32h725igt7</code>, <code>stm32h725rev6</code>, <code>stm32h725rgv3</code>, <code>stm32h725rgv6</code>, <code>stm32h725rgv7</code>, <code>stm32h725veh6</code>, <code>stm32h725vet6</code>, <code>stm32h725vgh3</code>, <code>stm32h725vgh6</code>, <code>stm32h725vgh7</code>, <code>stm32h725vgt3</code>, <code>stm32h725vgt6</code>, <code>stm32h725vgt7</code>, <code>stm32h725vgy3</code>, <code>stm32h725vgy6</code>, <code>stm32h725vgy7</code>, <code>stm32h725zet6</code>, <code>stm32h725zgt3</code>, <code>stm32h725zgt6</code>, <code>stm32h725zgt7</code>.</p>"},{"location":"reference/targets/#stm32h730","title":"STM32H730","text":"<p><code>stm32h730abi6q</code>, <code>stm32h730ibk6q</code>, <code>stm32h730ibt6q</code>, <code>stm32h730vbh6</code>, <code>stm32h730vbt6</code>, <code>stm32h730zbi6</code>, <code>stm32h730zbt6</code>.</p>"},{"location":"reference/targets/#stm32h733","title":"STM32H733","text":"<p><code>stm32h733vgh6</code>, <code>stm32h733vgt6</code>, <code>stm32h733zgi6</code>, <code>stm32h733zgt6</code>.</p>"},{"location":"reference/targets/#stm32h735","title":"STM32H735","text":"<p><code>stm32h735agi6</code>, <code>stm32h735igk3</code>, <code>stm32h735igk6</code>, <code>stm32h735igk7</code>, <code>stm32h735igt3</code>, <code>stm32h735igt6</code>, <code>stm32h735igt7</code>, <code>stm32h735rgv6</code>, <code>stm32h735vgh6</code>, <code>stm32h735vgt6</code>, <code>stm32h735vgy6</code>, <code>stm32h735zgt6</code>.</p>"},{"location":"reference/targets/#stm32h742","title":"STM32H742","text":"<p><code>stm32h742agi6</code>, <code>stm32h742aii6</code>, <code>stm32h742bgt6</code>, <code>stm32h742bit6</code>, <code>stm32h742igk6</code>, <code>stm32h742igt6</code>, <code>stm32h742iik6</code>, <code>stm32h742iit6</code>, <code>stm32h742vgh6</code>, <code>stm32h742vgt6</code>, <code>stm32h742vih6</code>, <code>stm32h742vit6</code>, <code>stm32h742xgh6</code>, <code>stm32h742xih6</code>, <code>stm32h742zgt6</code>, <code>stm32h742zit6</code>.</p>"},{"location":"reference/targets/#stm32h743","title":"STM32H743","text":"<p><code>stm32h743agi6</code>, <code>stm32h743aii6</code>, <code>stm32h743bgt6</code>, <code>stm32h743bit6</code>, <code>stm32h743igk6</code>, <code>stm32h743igt6</code>, <code>stm32h743iik6</code>, <code>stm32h743iit6</code>, <code>stm32h743vgh6</code>, <code>stm32h743vgt6</code>, <code>stm32h743vih6</code>, <code>stm32h743vit6</code>, <code>stm32h743xgh6</code>, <code>stm32h743xih6</code>, <code>stm32h743zgt6</code>, <code>stm32h743zit6</code>.</p>"},{"location":"reference/targets/#stm32h750","title":"STM32H750","text":"<p><code>stm32h750ibk6</code>, <code>stm32h750ibt6</code>, <code>stm32h750vbt6</code>, <code>stm32h750xbh6</code>, <code>stm32h750zbt6</code>.</p>"},{"location":"reference/targets/#stm32h753","title":"STM32H753","text":"<p><code>stm32h753aii6</code>, <code>stm32h753bit6</code>, <code>stm32h753iik6</code>, <code>stm32h753iit6</code>, <code>stm32h753vih6</code>, <code>stm32h753vit6</code>, <code>stm32h753xih6</code>, <code>stm32h753zit6</code>.</p>"},{"location":"reference/targets/#stm32h7a3","title":"STM32H7A3","text":"<p><code>stm32h7a3agi6q</code>, <code>stm32h7a3aii6q</code>, <code>stm32h7a3igk6</code>, <code>stm32h7a3igk6q</code>, <code>stm32h7a3igt6</code>, <code>stm32h7a3igt6q</code>, <code>stm32h7a3iik6</code>, <code>stm32h7a3iik6q</code>, <code>stm32h7a3iit6</code>, <code>stm32h7a3iit6q</code>, <code>stm32h7a3lgh6q</code>, <code>stm32h7a3lih6q</code>, <code>stm32h7a3ngh6</code>, <code>stm32h7a3nih6</code>, <code>stm32h7a3qiy6q</code>, <code>stm32h7a3rgt6</code>, <code>stm32h7a3rit6</code>, <code>stm32h7a3vgh6</code>, <code>stm32h7a3vgh6q</code>, <code>stm32h7a3vgt6</code>, <code>stm32h7a3vgt6q</code>, <code>stm32h7a3vih6</code>, <code>stm32h7a3vih6q</code>, <code>stm32h7a3vit6</code>, <code>stm32h7a3vit6q</code>, <code>stm32h7a3zgt6</code>, <code>stm32h7a3zgt6q</code>, <code>stm32h7a3zit6</code>, <code>stm32h7a3zit6q</code>.</p>"},{"location":"reference/targets/#stm32h7b0","title":"STM32H7B0","text":"<p><code>stm32h7b0abi6q</code>, <code>stm32h7b0ibk6q</code>, <code>stm32h7b0ibt6</code>, <code>stm32h7b0rbt6</code>, <code>stm32h7b0vbt6</code>, <code>stm32h7b0zbt6</code>.</p>"},{"location":"reference/targets/#stm32h7b3","title":"STM32H7B3","text":"<p><code>stm32h7b3aii6q</code>, <code>stm32h7b3iik6</code>, <code>stm32h7b3iik6q</code>, <code>stm32h7b3iit6</code>, <code>stm32h7b3iit6q</code>, <code>stm32h7b3lih6q</code>, <code>stm32h7b3nih6</code>, <code>stm32h7b3qiy6q</code>, <code>stm32h7b3rit6</code>, <code>stm32h7b3vih6</code>, <code>stm32h7b3vih6q</code>, <code>stm32h7b3vit6</code>, <code>stm32h7b3vit6q</code>, <code>stm32h7b3zit6</code>, <code>stm32h7b3zit6q</code>.</p>"},{"location":"reference/targets/#stm32l0","title":"STM32L0","text":""},{"location":"reference/targets/#stm32l010","title":"STM32L010","text":"<p><code>stm32l010c6t6</code>, <code>stm32l010f4p6</code>, <code>stm32l010k4t6</code>, <code>stm32l010k8t6</code>, <code>stm32l010r8t6</code>, <code>stm32l010rbt6</code>.</p>"},{"location":"reference/targets/#stm32l011","title":"STM32L011","text":"<p><code>stm32l011d3p6</code>, <code>stm32l011d4p6</code>, <code>stm32l011d4p7</code>, <code>stm32l011e3y6</code>, <code>stm32l011e4y6</code>, <code>stm32l011f3p3</code>, <code>stm32l011f3p6</code>, <code>stm32l011f3p7</code>, <code>stm32l011f3u3</code>, <code>stm32l011f3u6</code>, <code>stm32l011f3u7</code>, <code>stm32l011f4p3</code>, <code>stm32l011f4p6</code>, <code>stm32l011f4p7</code>, <code>stm32l011f4u3</code>, <code>stm32l011f4u6</code>, <code>stm32l011f4u7</code>, <code>stm32l011g3u6</code>, <code>stm32l011g4u6</code>, <code>stm32l011g4u7</code>, <code>stm32l011k3t3</code>, <code>stm32l011k3t6</code>, <code>stm32l011k3t7</code>, <code>stm32l011k3u6</code>, <code>stm32l011k4t3</code>, <code>stm32l011k4t6</code>, <code>stm32l011k4t7</code>, <code>stm32l011k4u3</code>, <code>stm32l011k4u6</code>, <code>stm32l011k4u7</code>.</p>"},{"location":"reference/targets/#stm32l021","title":"STM32L021","text":"<p><code>stm32l021d4p3</code>, <code>stm32l021d4p6</code>, <code>stm32l021d4p7</code>, <code>stm32l021f4p6</code>, <code>stm32l021f4u6</code>, <code>stm32l021f4u7</code>, <code>stm32l021g4u6</code>, <code>stm32l021g4u7</code>, <code>stm32l021k4t6</code>, <code>stm32l021k4t7</code>, <code>stm32l021k4u6</code>.</p>"},{"location":"reference/targets/#stm32l031","title":"STM32L031","text":"<p><code>stm32l031c4t6</code>, <code>stm32l031c4u6</code>, <code>stm32l031c6t3</code>, <code>stm32l031c6t6</code>, <code>stm32l031c6t7</code>, <code>stm32l031c6u3</code>, <code>stm32l031c6u6</code>, <code>stm32l031c6u7</code>, <code>stm32l031e4y6</code>, <code>stm32l031e6y3</code>, <code>stm32l031e6y6</code>, <code>stm32l031e6y7</code>, <code>stm32l031f4p3</code>, <code>stm32l031f4p6</code>, <code>stm32l031f4p7</code>, <code>stm32l031f6p6</code>, <code>stm32l031f6p7</code>, <code>stm32l031g4u6</code>, <code>stm32l031g6u3</code>, <code>stm32l031g6u3s</code>, <code>stm32l031g6u6</code>, <code>stm32l031g6u6s</code>, <code>stm32l031g6u7</code>, <code>stm32l031g6u7s</code>, <code>stm32l031k4t3</code>, <code>stm32l031k4t6</code>, <code>stm32l031k4t7</code>, <code>stm32l031k4u6</code>, <code>stm32l031k6t3</code>, <code>stm32l031k6t6</code>, <code>stm32l031k6t7</code>, <code>stm32l031k6u3</code>, <code>stm32l031k6u6</code>, <code>stm32l031k6u7</code>.</p>"},{"location":"reference/targets/#stm32l041","title":"STM32L041","text":"<p><code>stm32l041c4t6</code>, <code>stm32l041c4t7</code>, <code>stm32l041c6t6</code>, <code>stm32l041c6t7</code>, <code>stm32l041c6u6</code>, <code>stm32l041c6u7</code>, <code>stm32l041e6y3</code>, <code>stm32l041e6y6</code>, <code>stm32l041e6y7</code>, <code>stm32l041f6p6</code>, <code>stm32l041f6p7</code>, <code>stm32l041g6u6</code>, <code>stm32l041g6u6s</code>, <code>stm32l041g6u7</code>, <code>stm32l041g6u7s</code>, <code>stm32l041k6t3</code>, <code>stm32l041k6t6</code>, <code>stm32l041k6t7</code>, <code>stm32l041k6u3</code>, <code>stm32l041k6u6</code>, <code>stm32l041k6u7</code>.</p>"},{"location":"reference/targets/#stm32l051","title":"STM32L051","text":"<p><code>stm32l051c6t6</code>, <code>stm32l051c6u6</code>, <code>stm32l051c8t3</code>, <code>stm32l051c8t6</code>, <code>stm32l051c8t7</code>, <code>stm32l051c8u3</code>, <code>stm32l051c8u6</code>, <code>stm32l051c8u7</code>, <code>stm32l051k6t6</code>, <code>stm32l051k6u6</code>, <code>stm32l051k8t3</code>, <code>stm32l051k8t6</code>, <code>stm32l051k8t7</code>, <code>stm32l051k8u3</code>, <code>stm32l051k8u6</code>, <code>stm32l051k8u7</code>, <code>stm32l051r6h6</code>, <code>stm32l051r6t6</code>, <code>stm32l051r8h6</code>, <code>stm32l051r8h7</code>, <code>stm32l051r8t6</code>, <code>stm32l051r8t7</code>, <code>stm32l051t6y6</code>, <code>stm32l051t8y3</code>, <code>stm32l051t8y6</code>, <code>stm32l051t8y7</code>.</p>"},{"location":"reference/targets/#stm32l052","title":"STM32L052","text":"<p><code>stm32l052c6t6</code>, <code>stm32l052c6u6</code>, <code>stm32l052c8t3</code>, <code>stm32l052c8t6</code>, <code>stm32l052c8t7</code>, <code>stm32l052c8u3</code>, <code>stm32l052c8u6</code>, <code>stm32l052c8u7</code>, <code>stm32l052k6t6</code>, <code>stm32l052k6t7</code>, <code>stm32l052k6u6</code>, <code>stm32l052k6u7</code>, <code>stm32l052k8t3</code>, <code>stm32l052k8t6</code>, <code>stm32l052k8t7</code>, <code>stm32l052k8u3</code>, <code>stm32l052k8u6</code>, <code>stm32l052k8u7</code>, <code>stm32l052r6h6</code>, <code>stm32l052r6t6</code>, <code>stm32l052r8h6</code>, <code>stm32l052r8h7</code>, <code>stm32l052r8t6</code>, <code>stm32l052r8t7</code>, <code>stm32l052t6y6</code>, <code>stm32l052t6y7</code>, <code>stm32l052t8f3</code>, <code>stm32l052t8f6</code>, <code>stm32l052t8f7</code>, <code>stm32l052t8y3</code>, <code>stm32l052t8y6</code>, <code>stm32l052t8y7</code>.</p>"},{"location":"reference/targets/#stm32l053","title":"STM32L053","text":"<p><code>stm32l053c6t6</code>, <code>stm32l053c6t7</code>, <code>stm32l053c6u6</code>, <code>stm32l053c6u7</code>, <code>stm32l053c8t3</code>, <code>stm32l053c8t6</code>, <code>stm32l053c8t7</code>, <code>stm32l053c8u3</code>, <code>stm32l053c8u6</code>, <code>stm32l053c8u7</code>, <code>stm32l053r6h6</code>, <code>stm32l053r6t6</code>, <code>stm32l053r8h3</code>, <code>stm32l053r8h6</code>, <code>stm32l053r8h7</code>, <code>stm32l053r8t3</code>, <code>stm32l053r8t6</code>, <code>stm32l053r8t7</code>.</p>"},{"location":"reference/targets/#stm32l062","title":"STM32L062","text":"<p><code>stm32l062c8u6</code>, <code>stm32l062k8t6</code>, <code>stm32l062k8u6</code>.</p>"},{"location":"reference/targets/#stm32l063","title":"STM32L063","text":"<p><code>stm32l063c8t6</code>, <code>stm32l063c8u6</code>, <code>stm32l063r8t6</code>, <code>stm32l063r8t7</code>.</p>"},{"location":"reference/targets/#stm32l071","title":"STM32L071","text":"<p><code>stm32l071c8t6</code>, <code>stm32l071c8t7</code>, <code>stm32l071c8u6</code>, <code>stm32l071c8u7</code>, <code>stm32l071cbt3</code>, <code>stm32l071cbt6</code>, <code>stm32l071cbt7</code>, <code>stm32l071cbu3</code>, <code>stm32l071cbu6</code>, <code>stm32l071cbu7</code>, <code>stm32l071cby3</code>, <code>stm32l071cby6</code>, <code>stm32l071cby7</code>, <code>stm32l071czt3</code>, <code>stm32l071czt6</code>, <code>stm32l071czt7</code>, <code>stm32l071czu3</code>, <code>stm32l071czu6</code>, <code>stm32l071czu7</code>, <code>stm32l071czy3</code>, <code>stm32l071czy6</code>, <code>stm32l071czy7</code>, <code>stm32l071k8u3</code>, <code>stm32l071k8u6</code>, <code>stm32l071k8u7</code>, <code>stm32l071kbt3</code>, <code>stm32l071kbt6</code>, <code>stm32l071kbt7</code>, <code>stm32l071kbu3</code>, <code>stm32l071kbu6</code>, <code>stm32l071kbu7</code>, <code>stm32l071kzt3</code>, <code>stm32l071kzt6</code>, <code>stm32l071kzt7</code>, <code>stm32l071kzu3</code>, <code>stm32l071kzu6</code>, <code>stm32l071kzu7</code>, <code>stm32l071rbh6</code>, <code>stm32l071rbh7</code>, <code>stm32l071rbt6</code>, <code>stm32l071rbt7</code>, <code>stm32l071rzh6</code>, <code>stm32l071rzh7</code>, <code>stm32l071rzt6</code>, <code>stm32l071rzt7</code>, <code>stm32l071v8i6</code>, <code>stm32l071v8t6</code>, <code>stm32l071vbi6</code>, <code>stm32l071vbt6</code>, <code>stm32l071vbt7</code>, <code>stm32l071vzi6</code>, <code>stm32l071vzt6</code>, <code>stm32l071vzt7</code>.</p>"},{"location":"reference/targets/#stm32l072","title":"STM32L072","text":"<p><code>stm32l072cbt6</code>, <code>stm32l072cbu6</code>, <code>stm32l072cby6</code>, <code>stm32l072cze3</code>, <code>stm32l072cze6</code>, <code>stm32l072cze7</code>, <code>stm32l072czt3</code>, <code>stm32l072czt6</code>, <code>stm32l072czt7</code>, <code>stm32l072czu3</code>, <code>stm32l072czu6</code>, <code>stm32l072czu7</code>, <code>stm32l072czy3</code>, <code>stm32l072czy6</code>, <code>stm32l072czy7</code>, <code>stm32l072kbt6</code>, <code>stm32l072kbt7</code>, <code>stm32l072kbu3</code>, <code>stm32l072kbu6</code>, <code>stm32l072kbu7</code>, <code>stm32l072kzt6</code>, <code>stm32l072kzt7</code>, <code>stm32l072kzu6</code>, <code>stm32l072kzu7</code>, <code>stm32l072rbh3</code>, <code>stm32l072rbh6</code>, <code>stm32l072rbh7</code>, <code>stm32l072rbi3</code>, <code>stm32l072rbi6</code>, <code>stm32l072rbi7</code>, <code>stm32l072rbt3</code>, <code>stm32l072rbt6</code>, <code>stm32l072rbt7</code>, <code>stm32l072rzh3</code>, <code>stm32l072rzh6</code>, <code>stm32l072rzh7</code>, <code>stm32l072rzi3</code>, <code>stm32l072rzi6</code>, <code>stm32l072rzi7</code>, <code>stm32l072rzt3</code>, <code>stm32l072rzt6</code>, <code>stm32l072rzt7</code>, <code>stm32l072v8i6</code>, <code>stm32l072v8t6</code>, <code>stm32l072vbi6</code>, <code>stm32l072vbt6</code>, <code>stm32l072vzi6</code>, <code>stm32l072vzt6</code>.</p>"},{"location":"reference/targets/#stm32l073","title":"STM32L073","text":"<p><code>stm32l073cbt6</code>, <code>stm32l073cbu6</code>, <code>stm32l073czt3</code>, <code>stm32l073czt6</code>, <code>stm32l073czt7</code>, <code>stm32l073czu3</code>, <code>stm32l073czu6</code>, <code>stm32l073czu7</code>, <code>stm32l073czy3</code>, <code>stm32l073czy6</code>, <code>stm32l073czy7</code>, <code>stm32l073rbh6</code>, <code>stm32l073rbt6</code>, <code>stm32l073rzh3</code>, <code>stm32l073rzh6</code>, <code>stm32l073rzh7</code>, <code>stm32l073rzi3</code>, <code>stm32l073rzi6</code>, <code>stm32l073rzi7</code>, <code>stm32l073rzt3</code>, <code>stm32l073rzt6</code>, <code>stm32l073rzt7</code>, <code>stm32l073v8i6</code>, <code>stm32l073v8t6</code>, <code>stm32l073v8t7</code>, <code>stm32l073vbi3</code>, <code>stm32l073vbi6</code>, <code>stm32l073vbi7</code>, <code>stm32l073vbt6</code>, <code>stm32l073vbt7</code>, <code>stm32l073vzi3</code>, <code>stm32l073vzi6</code>, <code>stm32l073vzi7</code>, <code>stm32l073vzt3</code>, <code>stm32l073vzt6</code>, <code>stm32l073vzt7</code>.</p>"},{"location":"reference/targets/#stm32l081","title":"STM32L081","text":"<p><code>stm32l081cbt6</code>, <code>stm32l081czt6</code>, <code>stm32l081czu6</code>, <code>stm32l081kzt6</code>, <code>stm32l081kzu6</code>.</p>"},{"location":"reference/targets/#stm32l082","title":"STM32L082","text":"<p><code>stm32l082czu3</code>, <code>stm32l082czu6</code>, <code>stm32l082czu7</code>, <code>stm32l082czy3</code>, <code>stm32l082czy6</code>, <code>stm32l082czy7</code>, <code>stm32l082kbt6</code>, <code>stm32l082kbu6</code>, <code>stm32l082kzt6</code>, <code>stm32l082kzu6</code>.</p>"},{"location":"reference/targets/#stm32l083","title":"STM32L083","text":"<p><code>stm32l083cbt6</code>, <code>stm32l083czt6</code>, <code>stm32l083czu6</code>, <code>stm32l083rbh6</code>, <code>stm32l083rbt6</code>, <code>stm32l083rzh3</code>, <code>stm32l083rzh6</code>, <code>stm32l083rzh7</code>, <code>stm32l083rzt3</code>, <code>stm32l083rzt6</code>, <code>stm32l083rzt7</code>, <code>stm32l083v8i6</code>, <code>stm32l083v8t6</code>, <code>stm32l083vbi6</code>, <code>stm32l083vbt6</code>, <code>stm32l083vzi6</code>, <code>stm32l083vzt6</code>.</p>"},{"location":"reference/targets/#stm32l1","title":"STM32L1","text":""},{"location":"reference/targets/#stm32l100","title":"STM32L100","text":"<p><code>stm32l100c6u6</code>, <code>stm32l100c6u6a</code>, <code>stm32l100r8t6</code>, <code>stm32l100r8t6a</code>, <code>stm32l100rbt6</code>, <code>stm32l100rbt6a</code>, <code>stm32l100rct6</code>.</p>"},{"location":"reference/targets/#stm32l151","title":"STM32L151","text":"<p><code>stm32l151c6t6</code>, <code>stm32l151c6t6a</code>, <code>stm32l151c6u6</code>, <code>stm32l151c6u6a</code>, <code>stm32l151c8t6</code>, <code>stm32l151c8t6a</code>, <code>stm32l151c8u6</code>, <code>stm32l151c8u6a</code>, <code>stm32l151cbt3</code>, <code>stm32l151cbt6</code>, <code>stm32l151cbt6a</code>, <code>stm32l151cbt7</code>, <code>stm32l151cbu3</code>, <code>stm32l151cbu6</code>, <code>stm32l151cbu6a</code>, <code>stm32l151cbu7</code>, <code>stm32l151cct6</code>, <code>stm32l151cct7</code>, <code>stm32l151ccu6</code>, <code>stm32l151ccu7</code>, <code>stm32l151qdh6</code>, <code>stm32l151qeh6</code>, <code>stm32l151r6h6</code>, <code>stm32l151r6h6a</code>, <code>stm32l151r6t6</code>, <code>stm32l151r6t6a</code>, <code>stm32l151r8h6</code>, <code>stm32l151r8h6a</code>, <code>stm32l151r8t6</code>, <code>stm32l151r8t6a</code>, <code>stm32l151rbh3</code>, <code>stm32l151rbh6</code>, <code>stm32l151rbh6a</code>, <code>stm32l151rbh7</code>, <code>stm32l151rbt3</code>, <code>stm32l151rbt6</code>, <code>stm32l151rbt6a</code>, <code>stm32l151rbt7</code>, <code>stm32l151rct6</code>, <code>stm32l151rct6a</code>, <code>stm32l151rcy6</code>, <code>stm32l151rdt6</code>, <code>stm32l151rdt7</code>, <code>stm32l151rdy6</code>, <code>stm32l151rdy7</code>, <code>stm32l151ret6</code>, <code>stm32l151ucy3</code>, <code>stm32l151ucy6</code>, <code>stm32l151ucy7</code>, <code>stm32l151v8h6</code>, <code>stm32l151v8h6a</code>, <code>stm32l151v8t6</code>, <code>stm32l151v8t6a</code>, <code>stm32l151vbh3</code>, <code>stm32l151vbh6</code>, <code>stm32l151vbh6a</code>, <code>stm32l151vbh7</code>, <code>stm32l151vbt3</code>, <code>stm32l151vbt6</code>, <code>stm32l151vbt6a</code>, <code>stm32l151vbt7</code>, <code>stm32l151vch3</code>, <code>stm32l151vch6</code>, <code>stm32l151vch7</code>, <code>stm32l151vct3</code>, <code>stm32l151vct6</code>, <code>stm32l151vct6a</code>, <code>stm32l151vct7</code>, <code>stm32l151vdt6</code>, <code>stm32l151vdt6x</code>, <code>stm32l151vdy6x</code>, <code>stm32l151vet3</code>, <code>stm32l151vet6</code>, <code>stm32l151vet7</code>, <code>stm32l151vey3</code>, <code>stm32l151vey6</code>, <code>stm32l151vey7</code>, <code>stm32l151zdt6</code>, <code>stm32l151zet6</code>.</p>"},{"location":"reference/targets/#stm32l152","title":"STM32L152","text":"<p><code>stm32l152c6t6</code>, <code>stm32l152c6t6a</code>, <code>stm32l152c6u6</code>, <code>stm32l152c6u6a</code>, <code>stm32l152c8t6</code>, <code>stm32l152c8t6a</code>, <code>stm32l152c8u6</code>, <code>stm32l152c8u6a</code>, <code>stm32l152cbt6</code>, <code>stm32l152cbt6a</code>, <code>stm32l152cbu6</code>, <code>stm32l152cbu6a</code>, <code>stm32l152cct3</code>, <code>stm32l152cct6</code>, <code>stm32l152cct7</code>, <code>stm32l152ccu3</code>, <code>stm32l152ccu6</code>, <code>stm32l152ccu7</code>, <code>stm32l152qdh6</code>, <code>stm32l152qeh6</code>, <code>stm32l152r6h6</code>, <code>stm32l152r6h6a</code>, <code>stm32l152r6t6</code>, <code>stm32l152r6t6a</code>, <code>stm32l152r8h6</code>, <code>stm32l152r8h6a</code>, <code>stm32l152r8t6</code>, <code>stm32l152r8t6a</code>, <code>stm32l152rbh6</code>, <code>stm32l152rbh6a</code>, <code>stm32l152rbt6</code>, <code>stm32l152rbt6a</code>, <code>stm32l152rct3</code>, <code>stm32l152rct6</code>, <code>stm32l152rct6a</code>, <code>stm32l152rct7</code>, <code>stm32l152rdt6</code>, <code>stm32l152rdy6</code>, <code>stm32l152ret6</code>, <code>stm32l152ucy6</code>, <code>stm32l152v8h6</code>, <code>stm32l152v8h6a</code>, <code>stm32l152v8t6</code>, <code>stm32l152v8t6a</code>, <code>stm32l152vbh6</code>, <code>stm32l152vbh6a</code>, <code>stm32l152vbt6</code>, <code>stm32l152vbt6a</code>, <code>stm32l152vch3</code>, <code>stm32l152vch6</code>, <code>stm32l152vch7</code>, <code>stm32l152vct3</code>, <code>stm32l152vct6</code>, <code>stm32l152vct6a</code>, <code>stm32l152vct7</code>, <code>stm32l152vdt6</code>, <code>stm32l152vdt6x</code>, <code>stm32l152vet3</code>, <code>stm32l152vet6</code>, <code>stm32l152vet7</code>, <code>stm32l152vey3</code>, <code>stm32l152vey6</code>, <code>stm32l152vey7</code>, <code>stm32l152zdt6</code>, <code>stm32l152zet3</code>, <code>stm32l152zet6</code>, <code>stm32l152zet7</code>.</p>"},{"location":"reference/targets/#stm32l162","title":"STM32L162","text":"<p><code>stm32l162qch6</code>, <code>stm32l162qdh3</code>, <code>stm32l162qdh6</code>, <code>stm32l162qdh7</code>, <code>stm32l162rct6</code>, <code>stm32l162rct6a</code>, <code>stm32l162rdt6</code>, <code>stm32l162rdy6</code>, <code>stm32l162ret6</code>, <code>stm32l162vch3</code>, <code>stm32l162vch6</code>, <code>stm32l162vch7</code>, <code>stm32l162vct3</code>, <code>stm32l162vct6</code>, <code>stm32l162vct6a</code>, <code>stm32l162vct7</code>, <code>stm32l162vdt6</code>, <code>stm32l162vdy6x</code>, <code>stm32l162vet6</code>, <code>stm32l162vey6</code>, <code>stm32l162zct6</code>, <code>stm32l162zdt6</code>, <code>stm32l162zet6</code>.</p>"},{"location":"reference/targets/#stm32l4","title":"STM32L4","text":""},{"location":"reference/targets/#stm32l412","title":"STM32L412","text":"<p><code>stm32l412c8t6</code>, <code>stm32l412c8u6</code>, <code>stm32l412cbt3</code>, <code>stm32l412cbt3p</code>, <code>stm32l412cbt6</code>, <code>stm32l412cbt6p</code>, <code>stm32l412cbt7</code>, <code>stm32l412cbt7p</code>, <code>stm32l412cbu3</code>, <code>stm32l412cbu3p</code>, <code>stm32l412cbu6</code>, <code>stm32l412cbu6p</code>, <code>stm32l412cbu7</code>, <code>stm32l412cbu7p</code>, <code>stm32l412k8t6</code>, <code>stm32l412k8u6</code>, <code>stm32l412kbt3</code>, <code>stm32l412kbt6</code>, <code>stm32l412kbt7</code>, <code>stm32l412kbu3</code>, <code>stm32l412kbu6</code>, <code>stm32l412kbu7</code>, <code>stm32l412r8i6</code>, <code>stm32l412r8t6</code>, <code>stm32l412rbi6</code>, <code>stm32l412rbi6p</code>, <code>stm32l412rbt6</code>, <code>stm32l412rbt6p</code>, <code>stm32l412t8y6</code>, <code>stm32l412tby6</code>, <code>stm32l412tby6p</code>.</p>"},{"location":"reference/targets/#stm32l422","title":"STM32L422","text":"<p><code>stm32l422cbt6</code>, <code>stm32l422cbu6</code>, <code>stm32l422kbt6</code>, <code>stm32l422kbu6</code>, <code>stm32l422rbi6</code>, <code>stm32l422rbt6</code>, <code>stm32l422tby6</code>.</p>"},{"location":"reference/targets/#stm32l431","title":"STM32L431","text":"<p><code>stm32l431cbt6</code>, <code>stm32l431cbt7</code>, <code>stm32l431cbu6</code>, <code>stm32l431cbu7</code>, <code>stm32l431cby6</code>, <code>stm32l431cby7</code>, <code>stm32l431cct6</code>, <code>stm32l431ccu6</code>, <code>stm32l431ccy6</code>, <code>stm32l431kbu6</code>, <code>stm32l431kcu6</code>, <code>stm32l431rbi3</code>, <code>stm32l431rbi6</code>, <code>stm32l431rbi7</code>, <code>stm32l431rbt3</code>, <code>stm32l431rbt6</code>, <code>stm32l431rbt7</code>, <code>stm32l431rby3</code>, <code>stm32l431rby6</code>, <code>stm32l431rby7</code>, <code>stm32l431rci6</code>, <code>stm32l431rct6</code>, <code>stm32l431rcy6</code>, <code>stm32l431vci6</code>, <code>stm32l431vci7</code>, <code>stm32l431vct6</code>, <code>stm32l431vct7</code>.</p>"},{"location":"reference/targets/#stm32l432","title":"STM32L432","text":"<p><code>stm32l432kbu6</code>, <code>stm32l432kcu6</code>.</p>"},{"location":"reference/targets/#stm32l433","title":"STM32L433","text":"<p><code>stm32l433cbt6</code>, <code>stm32l433cbt7</code>, <code>stm32l433cbu6</code>, <code>stm32l433cbu7</code>, <code>stm32l433cby6</code>, <code>stm32l433cby7</code>, <code>stm32l433cct3</code>, <code>stm32l433cct6</code>, <code>stm32l433cct7</code>, <code>stm32l433ccu3</code>, <code>stm32l433ccu6</code>, <code>stm32l433ccu7</code>, <code>stm32l433ccy3</code>, <code>stm32l433ccy6</code>, <code>stm32l433ccy7</code>, <code>stm32l433rbi6</code>, <code>stm32l433rbt6</code>, <code>stm32l433rby6</code>, <code>stm32l433rci3</code>, <code>stm32l433rci6</code>, <code>stm32l433rci7</code>, <code>stm32l433rct3</code>, <code>stm32l433rct3p</code>, <code>stm32l433rct6</code>, <code>stm32l433rct6p</code>, <code>stm32l433rct7</code>, <code>stm32l433rct7p</code>, <code>stm32l433rcy3</code>, <code>stm32l433rcy6</code>, <code>stm32l433rcy7</code>, <code>stm32l433vci3</code>, <code>stm32l433vci6</code>, <code>stm32l433vci7</code>, <code>stm32l433vct3</code>, <code>stm32l433vct6</code>, <code>stm32l433vct7</code>.</p>"},{"location":"reference/targets/#stm32l442","title":"STM32L442","text":"<p><code>stm32l442kcu6</code>.</p>"},{"location":"reference/targets/#stm32l443","title":"STM32L443","text":"<p><code>stm32l443ccf6</code>, <code>stm32l443cct6</code>, <code>stm32l443ccu6</code>, <code>stm32l443ccy6</code>, <code>stm32l443rci3</code>, <code>stm32l443rci6</code>, <code>stm32l443rci7</code>, <code>stm32l443rct3</code>, <code>stm32l443rct6</code>, <code>stm32l443rct7</code>, <code>stm32l443rcy3</code>, <code>stm32l443rcy6</code>, <code>stm32l443rcy7</code>, <code>stm32l443vci6</code>, <code>stm32l443vct6</code>.</p>"},{"location":"reference/targets/#stm32l451","title":"STM32L451","text":"<p><code>stm32l451ccu3</code>, <code>stm32l451ccu6</code>, <code>stm32l451ccu7</code>, <code>stm32l451cet6</code>, <code>stm32l451ceu6</code>, <code>stm32l451rci3</code>, <code>stm32l451rci6</code>, <code>stm32l451rci7</code>, <code>stm32l451rct3</code>, <code>stm32l451rct6</code>, <code>stm32l451rct7</code>, <code>stm32l451rcy3</code>, <code>stm32l451rcy6</code>, <code>stm32l451rcy7</code>, <code>stm32l451rei6</code>, <code>stm32l451ret6</code>, <code>stm32l451rey6</code>, <code>stm32l451vci6</code>, <code>stm32l451vct6</code>, <code>stm32l451vei6</code>, <code>stm32l451vet6</code>.</p>"},{"location":"reference/targets/#stm32l452","title":"STM32L452","text":"<p><code>stm32l452ccu6</code>, <code>stm32l452cet3</code>, <code>stm32l452cet3p</code>, <code>stm32l452cet6</code>, <code>stm32l452cet6p</code>, <code>stm32l452cet7</code>, <code>stm32l452cet7p</code>, <code>stm32l452ceu3</code>, <code>stm32l452ceu6</code>, <code>stm32l452ceu7</code>, <code>stm32l452rci6</code>, <code>stm32l452rct6</code>, <code>stm32l452rcy6</code>, <code>stm32l452rei3</code>, <code>stm32l452rei6</code>, <code>stm32l452rei7</code>, <code>stm32l452ret3</code>, <code>stm32l452ret3p</code>, <code>stm32l452ret6</code>, <code>stm32l452ret6p</code>, <code>stm32l452ret7</code>, <code>stm32l452ret7p</code>, <code>stm32l452rey3</code>, <code>stm32l452rey3p</code>, <code>stm32l452rey6</code>, <code>stm32l452rey6p</code>, <code>stm32l452rey7</code>, <code>stm32l452rey7p</code>, <code>stm32l452vci6</code>, <code>stm32l452vct6</code>, <code>stm32l452vei3</code>, <code>stm32l452vei6</code>, <code>stm32l452vei7</code>, <code>stm32l452vet3</code>, <code>stm32l452vet6</code>, <code>stm32l452vet7</code>.</p>"},{"location":"reference/targets/#stm32l462","title":"STM32L462","text":"<p><code>stm32l462cet3</code>, <code>stm32l462cet6</code>, <code>stm32l462cet7</code>, <code>stm32l462ceu3</code>, <code>stm32l462ceu6</code>, <code>stm32l462ceu7</code>, <code>stm32l462rei6</code>, <code>stm32l462ret6</code>, <code>stm32l462rey6</code>, <code>stm32l462vei6</code>, <code>stm32l462vet6</code>.</p>"},{"location":"reference/targets/#stm32l471","title":"STM32L471","text":"<p><code>stm32l471qei3</code>, <code>stm32l471qei6</code>, <code>stm32l471qei7</code>, <code>stm32l471qgi6</code>, <code>stm32l471ret3</code>, <code>stm32l471ret6</code>, <code>stm32l471ret7</code>, <code>stm32l471rgt6</code>, <code>stm32l471vet6</code>, <code>stm32l471vgt3</code>, <code>stm32l471vgt6</code>, <code>stm32l471vgt7</code>, <code>stm32l471zej3</code>, <code>stm32l471zej6</code>, <code>stm32l471zej7</code>, <code>stm32l471zet3</code>, <code>stm32l471zet6</code>, <code>stm32l471zet7</code>, <code>stm32l471zgj6</code>, <code>stm32l471zgt6</code>.</p>"},{"location":"reference/targets/#stm32l475","title":"STM32L475","text":"<p><code>stm32l475rct3</code>, <code>stm32l475rct6</code>, <code>stm32l475rct7</code>, <code>stm32l475ret6</code>, <code>stm32l475rgt6</code>, <code>stm32l475rgt7</code>, <code>stm32l475vct6</code>, <code>stm32l475vet6</code>, <code>stm32l475vgt6</code>.</p>"},{"location":"reference/targets/#stm32l476","title":"STM32L476","text":"<p><code>stm32l476jey6</code>, <code>stm32l476jgy3</code>, <code>stm32l476jgy3p</code>, <code>stm32l476jgy6</code>, <code>stm32l476jgy6p</code>, <code>stm32l476jgy7</code>, <code>stm32l476jgy7p</code>, <code>stm32l476mey6</code>, <code>stm32l476mgy3</code>, <code>stm32l476mgy6</code>, <code>stm32l476mgy7</code>, <code>stm32l476qei6</code>, <code>stm32l476qgi3</code>, <code>stm32l476qgi3p</code>, <code>stm32l476qgi6</code>, <code>stm32l476qgi6p</code>, <code>stm32l476qgi7</code>, <code>stm32l476qgi7p</code>, <code>stm32l476rct6</code>, <code>stm32l476ret6</code>, <code>stm32l476rgt3</code>, <code>stm32l476rgt6</code>, <code>stm32l476rgt7</code>, <code>stm32l476vct6</code>, <code>stm32l476vet6</code>, <code>stm32l476vgt6</code>, <code>stm32l476vgt7</code>, <code>stm32l476vgy6p</code>, <code>stm32l476zet6</code>, <code>stm32l476zgj3</code>, <code>stm32l476zgj6</code>, <code>stm32l476zgj7</code>, <code>stm32l476zgt3</code>, <code>stm32l476zgt3p</code>, <code>stm32l476zgt6</code>, <code>stm32l476zgt6p</code>, <code>stm32l476zgt7</code>, <code>stm32l476zgt7p</code>.</p>"},{"location":"reference/targets/#stm32l485","title":"STM32L485","text":"<p><code>stm32l485jcy6</code>, <code>stm32l485jey6</code>.</p>"},{"location":"reference/targets/#stm32l486","title":"STM32L486","text":"<p><code>stm32l486jgy6</code>, <code>stm32l486qgi6</code>, <code>stm32l486rgt6</code>, <code>stm32l486vgt3</code>, <code>stm32l486vgt6</code>, <code>stm32l486vgt7</code>, <code>stm32l486zgt3</code>, <code>stm32l486zgt6</code>, <code>stm32l486zgt7</code>.</p>"},{"location":"reference/targets/#stm32l496","title":"STM32L496","text":"<p><code>stm32l496aei6</code>, <code>stm32l496agi3</code>, <code>stm32l496agi3p</code>, <code>stm32l496agi6</code>, <code>stm32l496agi6p</code>, <code>stm32l496agi7</code>, <code>stm32l496agi7p</code>, <code>stm32l496qei6</code>, <code>stm32l496qgi3</code>, <code>stm32l496qgi3p</code>, <code>stm32l496qgi3s</code>, <code>stm32l496qgi6</code>, <code>stm32l496qgi6p</code>, <code>stm32l496qgi6s</code>, <code>stm32l496qgi7</code>, <code>stm32l496qgi7p</code>, <code>stm32l496qgi7s</code>, <code>stm32l496ret6</code>, <code>stm32l496rgt3</code>, <code>stm32l496rgt3p</code>, <code>stm32l496rgt6</code>, <code>stm32l496rgt6p</code>, <code>stm32l496rgt7</code>, <code>stm32l496rgt7p</code>, <code>stm32l496vet3</code>, <code>stm32l496vet6</code>, <code>stm32l496vet7</code>, <code>stm32l496vgt3</code>, <code>stm32l496vgt3p</code>, <code>stm32l496vgt6</code>, <code>stm32l496vgt6p</code>, <code>stm32l496vgt7</code>, <code>stm32l496vgt7p</code>, <code>stm32l496vgy3</code>, <code>stm32l496vgy3p</code>, <code>stm32l496vgy6</code>, <code>stm32l496vgy6p</code>, <code>stm32l496vgy7</code>, <code>stm32l496vgy7p</code>, <code>stm32l496wgy6p</code>, <code>stm32l496zet6</code>, <code>stm32l496zgt3</code>, <code>stm32l496zgt3p</code>, <code>stm32l496zgt6</code>, <code>stm32l496zgt6p</code>, <code>stm32l496zgt7</code>, <code>stm32l496zgt7p</code>.</p>"},{"location":"reference/targets/#stm32l4a6","title":"STM32L4A6","text":"<p><code>stm32l4a6agi6</code>, <code>stm32l4a6agi6p</code>, <code>stm32l4a6qgi6</code>, <code>stm32l4a6qgi6p</code>, <code>stm32l4a6rgt6</code>, <code>stm32l4a6rgt6p</code>, <code>stm32l4a6rgt7</code>, <code>stm32l4a6rgt7p</code>, <code>stm32l4a6vgt6</code>, <code>stm32l4a6vgt6p</code>, <code>stm32l4a6vgy6</code>, <code>stm32l4a6vgy6p</code>, <code>stm32l4a6zgt6</code>, <code>stm32l4a6zgt6p</code>.</p>"},{"location":"reference/targets/#stm32l4p5","title":"STM32L4P5","text":"<p><code>stm32l4p5aei6</code>, <code>stm32l4p5agi6</code>, <code>stm32l4p5agi6p</code>, <code>stm32l4p5cet6</code>, <code>stm32l4p5ceu6</code>, <code>stm32l4p5cgt6</code>, <code>stm32l4p5cgt6p</code>, <code>stm32l4p5cgu6</code>, <code>stm32l4p5cgu6p</code>, <code>stm32l4p5qei6</code>, <code>stm32l4p5qgi6</code>, <code>stm32l4p5qgi6p</code>, <code>stm32l4p5qgi6s</code>, <code>stm32l4p5ret6</code>, <code>stm32l4p5rgt6</code>, <code>stm32l4p5rgt6p</code>, <code>stm32l4p5vet6</code>, <code>stm32l4p5vey6</code>, <code>stm32l4p5vgt6</code>, <code>stm32l4p5vgt6p</code>, <code>stm32l4p5vgy6</code>, <code>stm32l4p5vgy6p</code>, <code>stm32l4p5zet6</code>, <code>stm32l4p5zgt6</code>, <code>stm32l4p5zgt6p</code>.</p>"},{"location":"reference/targets/#stm32l4q5","title":"STM32L4Q5","text":"<p><code>stm32l4q5agi6</code>, <code>stm32l4q5agi6p</code>, <code>stm32l4q5cgt6</code>, <code>stm32l4q5cgt6p</code>, <code>stm32l4q5cgu6</code>, <code>stm32l4q5cgu6p</code>, <code>stm32l4q5qgi6</code>, <code>stm32l4q5qgi6p</code>, <code>stm32l4q5rgt3</code>, <code>stm32l4q5rgt3p</code>, <code>stm32l4q5rgt6</code>, <code>stm32l4q5rgt6p</code>, <code>stm32l4q5rgt7</code>, <code>stm32l4q5rgt7p</code>, <code>stm32l4q5vgt6</code>, <code>stm32l4q5vgt6p</code>, <code>stm32l4q5vgy6</code>, <code>stm32l4q5vgy6p</code>, <code>stm32l4q5zgt6</code>, <code>stm32l4q5zgt6p</code>.</p>"},{"location":"reference/targets/#stm32l4r5","title":"STM32L4R5","text":"<p><code>stm32l4r5agi6</code>, <code>stm32l4r5aii6</code>, <code>stm32l4r5aii6p</code>, <code>stm32l4r5qgi6</code>, <code>stm32l4r5qgi6s</code>, <code>stm32l4r5qii6</code>, <code>stm32l4r5qii6p</code>, <code>stm32l4r5vgt6</code>, <code>stm32l4r5vit6</code>, <code>stm32l4r5zgt6</code>, <code>stm32l4r5zgy6</code>, <code>stm32l4r5zit6</code>, <code>stm32l4r5zit6p</code>, <code>stm32l4r5ziy6</code>.</p>"},{"location":"reference/targets/#stm32l4r7","title":"STM32L4R7","text":"<p><code>stm32l4r7aii6</code>, <code>stm32l4r7vit6</code>, <code>stm32l4r7zit6</code>.</p>"},{"location":"reference/targets/#stm32l4r9","title":"STM32L4R9","text":"<p><code>stm32l4r9agi6</code>, <code>stm32l4r9aii6</code>, <code>stm32l4r9vgt6</code>, <code>stm32l4r9vit6</code>, <code>stm32l4r9zgj6</code>, <code>stm32l4r9zgt6</code>, <code>stm32l4r9zgy6</code>, <code>stm32l4r9zij6</code>, <code>stm32l4r9zit6</code>, <code>stm32l4r9ziy6</code>, <code>stm32l4r9ziy6p</code>.</p>"},{"location":"reference/targets/#stm32l4s5","title":"STM32L4S5","text":"<p><code>stm32l4s5aii3</code>, <code>stm32l4s5aii6</code>, <code>stm32l4s5aii7</code>, <code>stm32l4s5qii3</code>, <code>stm32l4s5qii6</code>, <code>stm32l4s5qii7</code>, <code>stm32l4s5vit3</code>, <code>stm32l4s5vit6</code>, <code>stm32l4s5vit7</code>, <code>stm32l4s5zit6</code>, <code>stm32l4s5ziy6</code>.</p>"},{"location":"reference/targets/#stm32l4s7","title":"STM32L4S7","text":"<p><code>stm32l4s7aii6</code>, <code>stm32l4s7vit6</code>, <code>stm32l4s7zit6</code>.</p>"},{"location":"reference/targets/#stm32l4s9","title":"STM32L4S9","text":"<p><code>stm32l4s9aii6</code>, <code>stm32l4s9vit6</code>, <code>stm32l4s9zij6</code>, <code>stm32l4s9zit6</code>, <code>stm32l4s9ziy6</code>.</p>"},{"location":"reference/targets/#stm32l5","title":"STM32L5","text":""},{"location":"reference/targets/#stm32l552","title":"STM32L552","text":"<p><code>stm32l552cct6</code>, <code>stm32l552ccu6</code>, <code>stm32l552cet6</code>, <code>stm32l552cet6p</code>, <code>stm32l552ceu6</code>, <code>stm32l552ceu6p</code>, <code>stm32l552mey6p</code>, <code>stm32l552mey6q</code>, <code>stm32l552qci6q</code>, <code>stm32l552qei6</code>, <code>stm32l552qei6p</code>, <code>stm32l552qei6q</code>, <code>stm32l552rct3</code>, <code>stm32l552rct6</code>, <code>stm32l552rct7</code>, <code>stm32l552ret6</code>, <code>stm32l552ret6p</code>, <code>stm32l552ret6q</code>, <code>stm32l552vct6q</code>, <code>stm32l552vet6</code>, <code>stm32l552vet6q</code>, <code>stm32l552zct6q</code>, <code>stm32l552zet3</code>, <code>stm32l552zet3q</code>, <code>stm32l552zet6</code>, <code>stm32l552zet6q</code>, <code>stm32l552zet7</code>, <code>stm32l552zet7q</code>.</p>"},{"location":"reference/targets/#stm32l562","title":"STM32L562","text":"<p><code>stm32l562cet6</code>, <code>stm32l562cet6p</code>, <code>stm32l562ceu6</code>, <code>stm32l562ceu6p</code>, <code>stm32l562mey6p</code>, <code>stm32l562mey6q</code>, <code>stm32l562qei6</code>, <code>stm32l562qei6p</code>, <code>stm32l562qei6q</code>, <code>stm32l562ret6</code>, <code>stm32l562ret6p</code>, <code>stm32l562ret6q</code>, <code>stm32l562vet6</code>, <code>stm32l562vet6q</code>, <code>stm32l562zet6</code>, <code>stm32l562zet6q</code>.</p>"},{"location":"reference/targets/#stm32u5","title":"STM32U5","text":""},{"location":"reference/targets/#stm32u535","title":"STM32U535","text":"<p><code>stm32u535cbt6</code>, <code>stm32u535cbt6q</code>, <code>stm32u535cbu6</code>, <code>stm32u535cbu6q</code>, <code>stm32u535cct6</code>, <code>stm32u535cct6q</code>, <code>stm32u535ccu6</code>, <code>stm32u535ccu6q</code>, <code>stm32u535cet6</code>, <code>stm32u535cet6q</code>, <code>stm32u535ceu6</code>, <code>stm32u535ceu6q</code>, <code>stm32u535jey6q</code>, <code>stm32u535ncy6q</code>, <code>stm32u535ney6q</code>, <code>stm32u535rbi6</code>, <code>stm32u535rbi6q</code>, <code>stm32u535rbt6</code>, <code>stm32u535rbt6q</code>, <code>stm32u535rci6</code>, <code>stm32u535rci6q</code>, <code>stm32u535rct6</code>, <code>stm32u535rct6q</code>, <code>stm32u535rei6</code>, <code>stm32u535rei6q</code>, <code>stm32u535ret6</code>, <code>stm32u535ret6q</code>, <code>stm32u535vci6</code>, <code>stm32u535vci6q</code>, <code>stm32u535vct6</code>, <code>stm32u535vct6q</code>, <code>stm32u535vei6</code>, <code>stm32u535vei6q</code>, <code>stm32u535vet6</code>, <code>stm32u535vet6q</code>.</p>"},{"location":"reference/targets/#stm32u545","title":"STM32U545","text":"<p><code>stm32u545cet6</code>, <code>stm32u545cet6q</code>, <code>stm32u545ceu6</code>, <code>stm32u545ceu6q</code>, <code>stm32u545jey6q</code>, <code>stm32u545ney6q</code>, <code>stm32u545rei6</code>, <code>stm32u545rei6q</code>, <code>stm32u545ret6</code>, <code>stm32u545ret6q</code>, <code>stm32u545vei6</code>, <code>stm32u545vei6q</code>, <code>stm32u545vet6</code>, <code>stm32u545vet6q</code>.</p>"},{"location":"reference/targets/#stm32u575","title":"STM32U575","text":"<p><code>stm32u575agi6</code>, <code>stm32u575agi6q</code>, <code>stm32u575aii6</code>, <code>stm32u575aii6q</code>, <code>stm32u575cgt6</code>, <code>stm32u575cgt6q</code>, <code>stm32u575cgu6</code>, <code>stm32u575cgu6q</code>, <code>stm32u575cit6</code>, <code>stm32u575cit6q</code>, <code>stm32u575ciu6</code>, <code>stm32u575ciu6q</code>, <code>stm32u575ogy6q</code>, <code>stm32u575oiy6q</code>, <code>stm32u575qgi6</code>, <code>stm32u575qgi6q</code>, <code>stm32u575qii6</code>, <code>stm32u575qii6q</code>, <code>stm32u575rgt6</code>, <code>stm32u575rgt6q</code>, <code>stm32u575rit6</code>, <code>stm32u575rit6q</code>, <code>stm32u575vgt6</code>, <code>stm32u575vgt6q</code>, <code>stm32u575vit6</code>, <code>stm32u575vit6q</code>, <code>stm32u575zgt6</code>, <code>stm32u575zgt6q</code>, <code>stm32u575zit6</code>, <code>stm32u575zit6q</code>.</p>"},{"location":"reference/targets/#stm32u585","title":"STM32U585","text":"<p><code>stm32u585aii6</code>, <code>stm32u585aii6q</code>, <code>stm32u585cit3</code>, <code>stm32u585cit3q</code>, <code>stm32u585cit6</code>, <code>stm32u585cit6q</code>, <code>stm32u585cit7</code>, <code>stm32u585cit7q</code>, <code>stm32u585ciu3</code>, <code>stm32u585ciu3q</code>, <code>stm32u585ciu6</code>, <code>stm32u585ciu6q</code>, <code>stm32u585ciu7</code>, <code>stm32u585ciu7q</code>, <code>stm32u585oiy6q</code>, <code>stm32u585qii3</code>, <code>stm32u585qii3q</code>, <code>stm32u585qii6</code>, <code>stm32u585qii6q</code>, <code>stm32u585qii7</code>, <code>stm32u585qii7q</code>, <code>stm32u585rit6</code>, <code>stm32u585rit6q</code>, <code>stm32u585vit3</code>, <code>stm32u585vit3q</code>, <code>stm32u585vit6</code>, <code>stm32u585vit6q</code>, <code>stm32u585vit7</code>, <code>stm32u585vit7q</code>, <code>stm32u585zit6</code>, <code>stm32u585zit6q</code>.</p>"},{"location":"reference/targets/#stm32u595","title":"STM32U595","text":"<p><code>stm32u595aih6</code>, <code>stm32u595aih6q</code>, <code>stm32u595ajh6</code>, <code>stm32u595ajh6q</code>, <code>stm32u595qii6</code>, <code>stm32u595qii6q</code>, <code>stm32u595qji6</code>, <code>stm32u595qji6q</code>, <code>stm32u595rit6</code>, <code>stm32u595rit6q</code>, <code>stm32u595rjt6</code>, <code>stm32u595rjt6q</code>, <code>stm32u595vit6</code>, <code>stm32u595vit6q</code>, <code>stm32u595vjt6</code>, <code>stm32u595vjt6q</code>, <code>stm32u595zit6</code>, <code>stm32u595zit6q</code>, <code>stm32u595ziy6q</code>, <code>stm32u595zjt6</code>, <code>stm32u595zjt6q</code>, <code>stm32u595zjy6q</code>.</p>"},{"location":"reference/targets/#stm32u599","title":"STM32U599","text":"<p><code>stm32u599bjy6q</code>, <code>stm32u599nih6q</code>, <code>stm32u599njh6q</code>, <code>stm32u599vit6q</code>, <code>stm32u599vjt6</code>, <code>stm32u599vjt6q</code>, <code>stm32u599zit6q</code>, <code>stm32u599ziy6q</code>, <code>stm32u599zjt6q</code>, <code>stm32u599zjy6q</code>.</p>"},{"location":"reference/targets/#stm32u5a5","title":"STM32U5A5","text":"<p><code>stm32u5a5ajh6</code>, <code>stm32u5a5ajh6q</code>, <code>stm32u5a5qii6q</code>, <code>stm32u5a5qji6</code>, <code>stm32u5a5qji6q</code>, <code>stm32u5a5rjt6</code>, <code>stm32u5a5rjt6q</code>, <code>stm32u5a5vjt6</code>, <code>stm32u5a5vjt6q</code>, <code>stm32u5a5zjt6</code>, <code>stm32u5a5zjt6q</code>, <code>stm32u5a5zjy6q</code>.</p>"},{"location":"reference/targets/#stm32u5a9","title":"STM32U5A9","text":"<p><code>stm32u5a9bjy6q</code>, <code>stm32u5a9njh6q</code>, <code>stm32u5a9vjt6q</code>, <code>stm32u5a9zjt6q</code>, <code>stm32u5a9zjy6q</code>.</p>"},{"location":"reference/targets/#stm32u5f7","title":"STM32U5F7","text":"<p><code>stm32u5f7vit6</code>, <code>stm32u5f7vit6q</code>, <code>stm32u5f7vjt6</code>, <code>stm32u5f7vjt6q</code>.</p>"},{"location":"reference/targets/#stm32u5f9","title":"STM32U5F9","text":"<p><code>stm32u5f9bjy6q</code>, <code>stm32u5f9njh6q</code>, <code>stm32u5f9vit6q</code>, <code>stm32u5f9vjt6q</code>, <code>stm32u5f9zij6q</code>, <code>stm32u5f9zit6q</code>, <code>stm32u5f9zjj6q</code>, <code>stm32u5f9zjt6q</code>.</p>"},{"location":"reference/targets/#stm32u5g7","title":"STM32U5G7","text":"<p><code>stm32u5g7vjt6</code>, <code>stm32u5g7vjt6q</code>.</p>"},{"location":"reference/targets/#stm32u5g9","title":"STM32U5G9","text":"<p><code>stm32u5g9bjy6q</code>, <code>stm32u5g9njh6q</code>, <code>stm32u5g9vjt6q</code>, <code>stm32u5g9zjj6q</code>, <code>stm32u5g9zjt6q</code>.</p>"},{"location":"reference/config/modm-al-avreb-can/","title":"AL-AVREB_CAN Board","text":"<p>lbuild config: <code>modm:al-avreb-can</code></p> <p>AVR breakout board with AT90CAN128: https://www.alvidi.de/products/DE/AVR_Entwicklungsboards/avr_modul_avreb_can.php</p>"},{"location":"reference/config/modm-al-avreb-can/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;at90can128-16au&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:f_cpu\"&gt;16M&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:al-avreb-can&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-arduino-nano/","title":"Arduino NANO","text":"<p>lbuild config: <code>modm:arduino-nano</code></p>"},{"location":"reference/config/modm-arduino-nano/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;atmega328p-au&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:f_cpu\"&gt;16M&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:arduino-nano&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-arduino-uno/","title":"Arduino UNO","text":"<p>lbuild config: <code>modm:arduino-uno</code></p>"},{"location":"reference/config/modm-arduino-uno/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;atmega328p-au&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:f_cpu\"&gt;16M&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:arduino-uno&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-black-pill-f103/","title":"Black Pill","text":"<p>lbuild config: <code>modm:black-pill-f103</code></p> <p>STM32F103C8T6 \"Black Pill\" Minimum System Development Board</p> <p>Cheap and bread-board-friendly board for STM32 F1 series. Sold for less than 2 USD on Aliexpress.</p> <p>https://stm32-base.org/boards/STM32F103C8T6-Black-Pill.html</p>"},{"location":"reference/config/modm-black-pill-f103/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f103c8t6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:black-pill-f103&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-black-pill-f401/","title":"Black Pill F401","text":"<p>lbuild config: <code>modm:black-pill-f401</code></p> <p>STM32F401CCU \"Mini-F401\" Minimum System Development Board</p> <p>Cheap and bread-board-friendly board for STM32F401 series. Sold for less than 4 USD on Aliexpress. Attention: There are two variants: Mini-F411 and the cheaper Mini-F401.</p> <p>https://stm32-base.org/boards/STM32F401CEU6-WeAct-Black-Pill-V3.0</p>"},{"location":"reference/config/modm-black-pill-f401/#programming","title":"Programming","text":"<p>Since the board has no St-Link programmer on the board, you must use DFU (Device Firmware Update (via USB)) to program the board. A DFU command is integrated into the <code>modm:build:scons</code> tool and can be called as follows:</p> <pre><code>scons program-dfu\n</code></pre>"},{"location":"reference/config/modm-black-pill-f401/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f401ccu6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:black-pill-f401&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-black-pill-f411/","title":"Black Pill F411","text":"<p>lbuild config: <code>modm:black-pill-f411</code></p> <p>STM32F411CEU \"Mini-F411\" Minimum System Development Board</p> <p>Cheap and bread-board-friendly board for STM32F411 series. Sold for less than 5 USD on Aliexpress. Attention: There are two variants: Mini-F411 and the cheaper Mini-F401.</p> <p>https://stm32-base.org/boards/STM32F401CEU6-WeAct-Black-Pill-V3.0</p>"},{"location":"reference/config/modm-black-pill-f411/#programming","title":"Programming","text":"<p>Since the board has no St-Link programmer on the board, you must use DFU (Device Firmware Update (via USB)) to program the board. A DFU command is integrated into the <code>modm:build:scons</code> tool and can be called as follows:</p> <pre><code>scons program-dfu\n</code></pre>"},{"location":"reference/config/modm-black-pill-f411/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f411ceu6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:black-pill-f411&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-blue-pill-f103/","title":"Blue Pill","text":"<p>lbuild config: <code>modm:blue-pill-f103</code></p> <p>STM32F103C8T6 \"Blue Pill\" Minimum System Development Board</p> <p>Cheap and bread-board-friendly board for STM32 F1 series. Sold for less than 2 USD on Aliexpress.</p> <p>https://stm32-base.org/boards/STM32F103C8T6-Blue-Pill.html</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-blue-pill-f103/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f103c8t6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:blue-pill-f103&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-devebox-stm32f4xx/","title":"STM32F4XX mcudev DevEBox","text":"<p>lbuild config: <code>modm:devebox-stm32f4xx</code></p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-devebox-stm32f4xx/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f407vet6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:devebox-stm32f4xx&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-devebox-stm32h750vb/","title":"STM32F750VB mcudev DevEBox","text":"<p>lbuild config: <code>modm:devebox-stm32h750vb</code></p> <p>STM32F750VB mcudev DevEBox H7xx</p> <p>Please note that this BSP uses the Y revision of the STM32H750, which limits the main clock frequency to \u2264400MHz and applies an errata bug fix to the SysTick, whose reference clock cannot be divided by 8.</p> <p>See the STM32H750 errata sheet.</p> <p>In case you are using the new revision V of STM32H750, you can overwrite the target option in your <code>project.xml</code>:</p> <pre><code>&lt;library&gt;\n  &lt;extends&gt;modm:devebox-stm32h750vb&lt;/extends&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32h750vbt6/revV&lt;/option&gt;\n  &lt;/options&gt;\n&lt;/library&gt;\n</code></pre> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-devebox-stm32h750vb/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32h750vbt6/revY&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:devebox-stm32h750vb&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f051r8/","title":"STM32F0DISCOVERY","text":"<p>lbuild config: <code>modm:disco-f051r8</code></p> <p>Discovery kit for STM32F051</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-disco-f051r8/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f051r8t6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f051r8&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f072rb/","title":"STM32F072DISCOVERY","text":"<p>lbuild config: <code>modm:disco-f072rb</code></p> <p>Discovery kit for STM32F072</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-disco-f072rb/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f072rbt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f072rb&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f100rb/","title":"STM32VLDISCOVERY","text":"<p>lbuild config: <code>modm:disco-f100rb</code></p> <p>Discovery kit for STM32F100</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-disco-f100rb/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f100rbt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f100rb&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f303vc/","title":"STM32F3DISCOVERY","text":"<p>lbuild config: <code>modm:disco-f303vc</code></p> <p>Discovery kit for STM32F303</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-disco-f303vc/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f303vct6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f303vc&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f401vc/","title":"STM32F401DISCOVERY","text":"<p>lbuild config: <code>modm:disco-f401vc</code></p> <p>Discovery kit for STM32F401</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-disco-f401vc/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f401vct6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f401vc&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f407vg/","title":"STM32F4DISCOVERY","text":"<p>lbuild config: <code>modm:disco-f407vg</code></p> <p>Discovery kit for STM32F407</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-disco-f407vg/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f407vgt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f407vg&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f411ve/","title":"STM32F4DISCOVERY","text":"<p>lbuild config: <code>modm:disco-f411ve</code></p> <p>Discovery kit for STM32F411</p>"},{"location":"reference/config/modm-disco-f411ve/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f411vet6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f411ve&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f429zi/","title":"STM32F429IDISCOVERY","text":"<p>lbuild config: <code>modm:disco-f429zi</code></p> <p>Discovery kit for STM32F429</p>"},{"location":"reference/config/modm-disco-f429zi/#logging","title":"Logging","text":"<p>To use the logging, you need to close SB11 and SB15 and upgrade the STLINK/V2-B firmware! See Section 6.3 \"Embedded ST-LINK/V2-B\" of UM1670.</p>"},{"location":"reference/config/modm-disco-f429zi/#tinyusb","title":"TinyUSB","text":"<p>To use the USB port, you must configure TinyUSB to use the HS port in FS mode:</p> <pre><code>&lt;option name=\"modm:tinyusb:max-speed\"&gt;full&lt;/option&gt;\n&lt;!-- place either the device or host classes on the HS port --&gt;\n&lt;option name=\"modm:tinyusb:device:port\"&gt;hs&lt;/option&gt;\n&lt;option name=\"modm:tinyusb:host:port\"&gt;hs&lt;/option&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f429zi/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f429zit6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f429zi&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f469ni/","title":"STM32F469IDISCOVERY","text":"<p>lbuild config: <code>modm:disco-f469ni:b-03</code></p> <p>Discovery kit with STM32F469NI MCU.</p> <p>This BSPs <code>Board::initialize()</code> sets the board up with these settings:</p> <ul> <li>180MHz CPU clock frequency in overdrive mode.</li> <li>90MHz APB2 and 45MHz APB1 clock frequency.</li> <li>MODM_LOGGER initialized at 115.2kBaud outputting on STLink.</li> <li>16MB SDRAM initialized for heap.</li> <li>Disables the display by default.</li> </ul> <p>You can enable and use the on-board display in two ways:</p> <ol> <li>Use the <code>modm::GraphicDisplay</code> returned by <code>Board::getDisplay()</code>, which    initializes the display on first call and allocates the framebuffer in the    external SDRAM. This is the simplest option.</li> <li>Call <code>Board::initializeDisplay()</code> and then provide your own display buffer    with <code>Board::setDisplayBuffer(void*)</code>.</li> </ol> <p>No Double-Buffering!</p> <p>Double-buffering is not implemented, so you may notice some tearing if you update the display fast enough.</p> <p>Access to the capacitive touchscreen is provided in the <code>Board::ft6</code> namespace. Call <code>Board::initializeTouchscreen()</code> to setup the peripherals.</p> <p>Product Link</p>"},{"location":"reference/config/modm-disco-f469ni/#hardware-revisions","title":"Hardware Revisions","text":"<p>The revision B-03 has a different touch sensor address from B-01 and B-02. The correct address for the revision is provided as <code>Board::ft6::TouchAddress</code>:</p> <pre><code>Board::ft6::Touch::Data data;\nBoard::ft6::Touch touchSensor(data, Board::ft6::TouchAddress);\n</code></pre> <p>If you want to provide the same code for both revisions, you can change the address at runtime if the device does not respond to a ping:</p> <pre><code>if (not touchSensor.ping()) touchSensor.setAddress(Board::ft6::TouchAddress2);\n</code></pre> <p>Default: <code>b-03</code> Revisions: <code>[b-01, b-02, b-03]</code></p>"},{"location":"reference/config/modm-disco-f469ni/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f469nih6&lt;/option&gt;\n    &lt;option name=\"modm:platform:heap:allocator\"&gt;tlsf&lt;/option&gt;\n    &lt;option name=\"modm:tlsf:minimum_pool_size\"&gt;16Mi&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f469ni&lt;/module&gt;\n    &lt;module&gt;modm:platform:heap&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f723ie/","title":"STM32F723E DISCOVERY","text":"<p>lbuild config: <code>modm:disco-f723ie</code></p> <p>Discovery kit for STM32F723E</p>"},{"location":"reference/config/modm-disco-f723ie/#tinyusb","title":"TinyUSB","text":"<p>This board has two USB ports: one with Full Speed support and another with true High Speed support. By default, TinyUSB runs the device classes on the FS port, however, you can reassign it to HS via this option:</p> <pre><code>&lt;options&gt;\n  &lt;option name=\"modm:tinyusb:config\"&gt;device.cdc,device.msc&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:device:port\"&gt;hs&lt;/option&gt;\n&lt;/options&gt;\n</code></pre> <p>Note that can use TinyUSB with both the device and host classes at the same time if you assign them to different ports:</p> <pre><code>```xml\n&lt;options&gt;\n  &lt;option name=\"modm:tinyusb:config\"&gt;device.cdc,device.msc&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:device:port\"&gt;fs&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:host:port\"&gt;hs&lt;/option&gt;\n&lt;/options&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f723ie/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f723iek6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f723ie&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f746ng/","title":"STM32F7DISCOVERY","text":"<p>lbuild config: <code>modm:disco-f746ng</code></p> <p>Discovery kit for STM32F746</p>"},{"location":"reference/config/modm-disco-f746ng/#tinyusb","title":"TinyUSB","text":"<p>This board has two USB ports: one with Full Speed support and another with true High Speed support. By default, TinyUSB runs the device classes on the FS port, however, you can reassign it to HS via this option:</p> <pre><code>&lt;options&gt;\n  &lt;option name=\"modm:tinyusb:config\"&gt;device.cdc,device.msc&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:device:port\"&gt;hs&lt;/option&gt;\n&lt;/options&gt;\n</code></pre> <p>Note that can use TinyUSB with both the device and host classes at the same time if you assign them to different ports:</p> <pre><code>&lt;options&gt;\n  &lt;option name=\"modm:tinyusb:config\"&gt;device.cdc,device.msc&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:device:port\"&gt;fs&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:host:port\"&gt;hs&lt;/option&gt;\n&lt;/options&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f746ng/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f746ngh6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f746ng&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-f769ni/","title":"STM32F769IDISCOVERY","text":"<p>lbuild config: <code>modm:disco-f769ni</code></p> <p>Discovery kit for STM32F769 line</p>"},{"location":"reference/config/modm-disco-f769ni/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f769nih6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-f769ni&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-l152rc/","title":"DISCO-L152RC","text":"<p>lbuild config: <code>modm:disco-l152rc</code></p> <p>Discovery kit for STM32L152RC</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-disco-l152rc/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32l152rct6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-l152rc&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-disco-l476vg/","title":"STM32L476DISCOVERY","text":"<p>lbuild config: <code>modm:disco-l476vg</code></p> <p>Discovery kit for STM32L476</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-disco-l476vg/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32l476vgt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:disco-l476vg&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-feather-m0/","title":"Adafruit Feather-M0","text":"<p>lbuild config: <code>modm:feather-m0</code></p> <p>At the Feather M0's heart is an ATSAMD21G18 ARM Cortex M0 processor, clocked at 48 MHz and at 3.3V logic, the same one used in the new Arduino Zero. This chip has a whopping 256K of FLASH (8x more than the Atmega328 or 32u4) and 32K of RAM (16x as much)! This chip comes with built in USB so it has USB-to-Serial program &amp; debug capability built in with no need for an FTDI-like chip.</p> <p>https://www.adafruit.com/product/2772</p>"},{"location":"reference/config/modm-feather-m0/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;samd21g18a-au&lt;/option&gt;\n    &lt;option name=\"modm:platform:cortex-m:linkerscript.flash_offset\"&gt;0x2000&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:feather-m0&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-feather-m4/","title":"Adafruit Feather M4 Express","text":"<p>lbuild config: <code>modm:feather-m4</code></p> <p>The Feather M4 Express features an ATSAMD51J19 (a 120MHz Cortex M4 with floating point support, 512KB Flash and 192KB RAM), plus a number of extra peripherals for support.</p> <p>Main Product Page</p> <p>User Guide</p>"},{"location":"reference/config/modm-feather-m4/#board-details","title":"Board Details","text":""},{"location":"reference/config/modm-feather-m4/#pins-available","title":"Pins available","text":"<p>The Feather boards have dimensions of 51mm x 23mm for a fairly compact form factor. That does, however, limit the number of pins broken out on the board.</p> <p>Out of 51 GPIO pins on the SAMD51J19, only 22 have pads for the breakout headers. One of these, labeled AREF (PA03), is connected directly to 3.3V and thus cannot be used for IO. (This is due to a problem with the chip itself; the DAC will not function without this connection. If the DAC is not needed, the trace can be cut and the pin used as desired.)</p> <p>There are seven other pins not broken out but used for devices on-board: six are used for a 2MB QSPI Flash, and one for the 'Neopixel', Adafruit's name for a WS2812 RGB LED.</p> <p>Pins PA30-PA31 have pads on the underside of the board for the Serial Wire Debug Interface (SWCLK and SWDIO, respectively), allowing connection to a debug probe.</p> <p>The pinouts page in the User Guide has further information, photos, and a useful diagram showing the various pin functions. (This diagram does have some errors, however; the most noticeable being the labeling of several pins as outputs for TC6 &amp; TC7, Timer/Counters which are not present on the chip.)</p>"},{"location":"reference/config/modm-feather-m4/#board-labeling","title":"Board labeling","text":"<p>Most pins broken out on the board are labeled Arduino-style, with A0-A5 having 'analog' functions, and 0-13 (not all of which are available) for 'digital'. A few pins are labeled for specific functions, e.g. SPI, I2C, etc. All pins are aliased in 'board.hpp' to their GPIO equivalents; the 'digital' (0-13) pin aliases are prefixed with a 'D'.</p>"},{"location":"reference/config/modm-feather-m4/#clocks","title":"Clocks","text":"<p>Although the SAMD51 has pins available for crystal oscillators XOSC1 and XOSC2, there are no crystals installed on this board for their use. There is, however, a 32kHz crystal for the XOSC32K oscillator.</p> <p>Typically, an FDPLL is used as the system clock after bootup is complete; and using XOSC32K as a reference for it is not reliable. Even when using the workaround prescibed in Item 2.13 of the Errata, the result is usually failure.</p> <p>The simplest solution is to source a GCLK generator with the 48MHz DFLL, and use a division factor that creates a suitable reference frequency for the FDPLL (e.g. 1-2MHz). It can be done with the DFLL in open- or closed-loop mode, but in order to meet the USB timing specs, closed-loop with XOSC32K as reference is used here.</p>"},{"location":"reference/config/modm-feather-m4/#programming","title":"Programming","text":"<p>The Feather M4 has a UF2 bootloader. By using a utility to convert the '.elf' files (generated by scons or make) to '.uf2' files, it is then possible to copy the uf2 file directly to the board.</p> <p>In modm, the conversion utility is called 'elf2uf2.py' (in tools/modm_tools), and is incorporated into the build system. Use 'scons uf2' or 'make uf2' to create the uf2 file.</p> <p>Alternatively, the bootloader on the Feather is compatible with BOSSA; so another method is to use 'scons program-bossac' or 'make program-bossac' to load your program into flash.</p> <p>With either method, you must press the reset button twice to get the board into bootloader mode before flashing with BOSSA or UF2 copying. (In bootloader mode, a volume named FEATHERBOOT will be mounted; and that is where the UF2 file should be copied.)</p>"},{"location":"reference/config/modm-feather-m4/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;samd51j19a-au&lt;/option&gt;\n    &lt;option name=\"modm:platform:cortex-m:linkerscript.flash_offset\"&gt;0x4000&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:feather-m4&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-feather-rp2040/","title":"Adafruit Feather RP2040","text":"<p>lbuild config: <code>modm:feather-rp2040</code></p> <p>A board with RP2040 chip and 8MB of flash memory.</p> <p>https://www.adafruit.com/product/4884</p> <p>See <code>modm:rp-pico</code> for programming instructions.</p>"},{"location":"reference/config/modm-feather-rp2040/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;rp2040&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:boot2\"&gt;generic_03h&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:boot2_size\"&gt;8Mi&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:feather-rp2040&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-mega-2560-pro/","title":"Mega 2560 PRO (Embed) CH340G","text":"<p>lbuild config: <code>modm:mega-2560-pro</code></p> <p>A compact breakout board similiar to the Arduino Mega 2560 board. You can order this for little money from well known Chinese online stores.</p> <p>See: https://robotdyn.com/mega-2560-pro-embed-ch340g-atmega2560-16au.html</p>"},{"location":"reference/config/modm-mega-2560-pro/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;atmega2560-16au&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:f_cpu\"&gt;16M&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:mega-2560-pro&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-c031c6/","title":"NUCLEO-C031C6","text":"<p>lbuild config: <code>modm:nucleo-c031c6</code></p> <p>Nucleo kit for STM32C031C6</p>"},{"location":"reference/config/modm-nucleo-c031c6/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32c031c6t6&lt;/option&gt;\n    &lt;option name=\"modm:platform:cortex-m:main_stack_size\"&gt;1Ki&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-c031c6&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f031k6/","title":"NUCLEO-F031K6","text":"<p>lbuild config: <code>modm:nucleo-f031k6</code></p> <p>Nucleo kit for STM32F031K6</p>"},{"location":"reference/config/modm-nucleo-f031k6/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f031k6t6&lt;/option&gt;\n    &lt;option name=\"modm:platform:cortex-m:main_stack_size\"&gt;1Ki&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f031k6&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f042k6/","title":"NUCLEO-F042K6","text":"<p>lbuild config: <code>modm:nucleo-f042k6</code></p> <p>Nucleo kit for STM32F042K6</p>"},{"location":"reference/config/modm-nucleo-f042k6/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f042k6t6&lt;/option&gt;\n    &lt;option name=\"modm:platform:cortex-m:main_stack_size\"&gt;1Ki&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f042k6&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f072rb/","title":"NUCLEO-F072RB","text":"<p>lbuild config: <code>modm:nucleo-f072rb</code></p> <p>Nucleo kit for STM32F072RB</p>"},{"location":"reference/config/modm-nucleo-f072rb/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f072rbt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f072rb&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f091rc/","title":"NUCLEO-F091RC","text":"<p>lbuild config: <code>modm:nucleo-f091rc</code></p> <p>Nucleo kit for STM32F091RC</p>"},{"location":"reference/config/modm-nucleo-f091rc/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f091rct6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f091rc&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f103rb/","title":"NUCLEO-F103RB","text":"<p>lbuild config: <code>modm:nucleo-f103rb</code></p> <p>Nucleo kit for STM32F103RB</p>"},{"location":"reference/config/modm-nucleo-f103rb/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f103rbt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f103rb&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f303k8/","title":"NUCLEO-F303K8","text":"<p>lbuild config: <code>modm:nucleo-f303k8</code></p> <p>Nucleo kit for STM32F303K8</p>"},{"location":"reference/config/modm-nucleo-f303k8/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f303k8t6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f303k8&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f303re/","title":"NUCLEO-F303RE","text":"<p>lbuild config: <code>modm:nucleo-f303re</code></p> <p>Nucleo kit for STM32F303RE</p>"},{"location":"reference/config/modm-nucleo-f303re/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f303ret6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f303re&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f334r8/","title":"NUCLEO-F334R8","text":"<p>lbuild config: <code>modm:nucleo-f334r8</code></p> <p>Nucleo kit for STM32F334R8</p>"},{"location":"reference/config/modm-nucleo-f334r8/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f334r8t6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f334r8&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f401re/","title":"NUCLEO-F401RE","text":"<p>lbuild config: <code>modm:nucleo-f401re</code></p> <p>Nucleo kit for STM32F401RE</p>"},{"location":"reference/config/modm-nucleo-f401re/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f401ret6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f401re&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f411re/","title":"NUCLEO-F411RE","text":"<p>lbuild config: <code>modm:nucleo-f411re</code></p> <p>Nucleo kit for STM32F411RE</p>"},{"location":"reference/config/modm-nucleo-f411re/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f411ret6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f411re&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f429zi/","title":"NUCLEO-F429ZI","text":"<p>lbuild config: <code>modm:nucleo-f429zi</code></p> <p>Nucleo kit for STM32F429ZI</p>"},{"location":"reference/config/modm-nucleo-f429zi/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f429zit6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f429zi&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f439zi/","title":"NUCLEO-F439ZI","text":"<p>lbuild config: <code>modm:nucleo-f439zi</code></p> <p>Nucleo kit for STM32F439ZI</p>"},{"location":"reference/config/modm-nucleo-f439zi/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f439zit6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f439zi&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f446re/","title":"NUCLEO-F446RE","text":"<p>lbuild config: <code>modm:nucleo-f446re</code></p> <p>Nucleo kit for STM32F446RE</p>"},{"location":"reference/config/modm-nucleo-f446re/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f446ret6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f446re&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f446ze/","title":"NUCLEO-F446ZE","text":"<p>lbuild config: <code>modm:nucleo-f446ze</code></p> <p>Nucleo kit for STM32F446ZE</p>"},{"location":"reference/config/modm-nucleo-f446ze/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f446zet6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f446ze&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f746zg/","title":"NUCLEO-F746ZG","text":"<p>lbuild config: <code>modm:nucleo-f746zg</code></p> <p>Nucleo kit for STM32F746ZG</p>"},{"location":"reference/config/modm-nucleo-f746zg/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f746zgt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f746zg&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-f767zi/","title":"NUCLEO-F767ZI","text":"<p>lbuild config: <code>modm:nucleo-f767zi</code></p> <p>Nucleo kit for STM32F767ZI</p>"},{"location":"reference/config/modm-nucleo-f767zi/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f767zit6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-f767zi&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-g070rb/","title":"NUCLEO-G070RB","text":"<p>lbuild config: <code>modm:nucleo-g070rb</code></p> <p>Nucleo kit for STM32G070RB</p>"},{"location":"reference/config/modm-nucleo-g070rb/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32g070rbt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-g070rb&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-g071rb/","title":"NUCLEO-G071RB","text":"<p>lbuild config: <code>modm:nucleo-g071rb</code></p> <p>Nucleo kit for STM32G071RB</p>"},{"location":"reference/config/modm-nucleo-g071rb/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32g071rbt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-g071rb&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-g431kb/","title":"NUCLEO-G431KB","text":"<p>lbuild config: <code>modm:nucleo-g431kb</code></p> <p>Nucleo kit for STM32G431KB</p>"},{"location":"reference/config/modm-nucleo-g431kb/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32g431kbt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-g431kb&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-g431rb/","title":"NUCLEO-G431RB","text":"<p>lbuild config: <code>modm:nucleo-g431rb</code></p> <p>Nucleo kit for STM32G474RE</p>"},{"location":"reference/config/modm-nucleo-g431rb/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32g431rbt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-g431rb&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-g474re/","title":"NUCLEO-G474RE","text":"<p>lbuild config: <code>modm:nucleo-g474re</code></p> <p>Nucleo kit for STM32G474RE</p>"},{"location":"reference/config/modm-nucleo-g474re/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32g474ret6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-g474re&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-h723zg/","title":"NUCLEO-H723ZG","text":"<p>lbuild config: <code>modm:nucleo-h723zg</code></p> <p>Nucleo kit for STM32H723ZG</p>"},{"location":"reference/config/modm-nucleo-h723zg/#tinyusb","title":"TinyUSB","text":"<p>To use the USB port, you must configure TinyUSB to use the HS port in FS mode:</p> <pre><code>&lt;option name=\"modm:tinyusb:max-speed\"&gt;full&lt;/option&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-h723zg/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32h723zgt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-h723zg&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-h743zi/","title":"NUCLEO-H743ZI","text":"<p>lbuild config: <code>modm:nucleo-h743zi</code></p> <p>Nucleo kit for STM32H743ZI</p> <p>Please note that this BSP uses the Y revision of the STM32H743, which limits the main clock frequency to \u2264400MHz and applies an errata bug fix to the SysTick, whose reference clock cannot be divided by 8.</p> <p>See the STM32H743 errata sheet.</p> <p>In case you are using the new revision V of STM32H743, you can overwrite the target option in your <code>project.xml</code>:</p> <pre><code>&lt;library&gt;\n  &lt;extends&gt;modm:nucleo-h743zi&lt;/extends&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32h743zit6/revV&lt;/option&gt;\n  &lt;/options&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-h743zi/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32h743zit6/revY&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-h743zi&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-l031k6/","title":"NUCLEO-L031K6","text":"<p>lbuild config: <code>modm:nucleo-l031k6</code></p> <p>Nucleo kit for STM32L031K6</p>"},{"location":"reference/config/modm-nucleo-l031k6/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32l031k6t6&lt;/option&gt;\n    &lt;option name=\"modm:platform:cortex-m:main_stack_size\"&gt;1Ki&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-l031k6&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-l053r8/","title":"NUCLEO-L053R8","text":"<p>lbuild config: <code>modm:nucleo-l053r8</code></p> <p>Nucleo kit for STM32L053R8</p>"},{"location":"reference/config/modm-nucleo-l053r8/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32l053r8t6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-l053r8&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-l152re/","title":"NUCLEO-L152RE","text":"<p>lbuild config: <code>modm:nucleo-l152re</code></p> <p>Nucleo kit for STM32L152RE</p>"},{"location":"reference/config/modm-nucleo-l152re/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32l152ret6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-l152re&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-l432kc/","title":"NUCLEO-L432KC","text":"<p>lbuild config: <code>modm:nucleo-l432kc</code></p> <p>Nucleo kit for STM32L432KC</p>"},{"location":"reference/config/modm-nucleo-l432kc/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32l432kcu6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-l432kc&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-l452re/","title":"NUCLEO-L452RE","text":"<p>lbuild config: <code>modm:nucleo-l452re</code></p> <p>Nucleo kit for STM32L452RE</p>"},{"location":"reference/config/modm-nucleo-l452re/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32l452ret6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-l452re&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-l476rg/","title":"NUCLEO-L476RG","text":"<p>lbuild config: <code>modm:nucleo-l476rg</code></p> <p>Nucleo kit for STM32L476RG</p>"},{"location":"reference/config/modm-nucleo-l476rg/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32l476rgt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-l476rg&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-l496zg-p/","title":"NUCLEO-L496ZG-P","text":"<p>lbuild config: <code>modm:nucleo-l496zg-p</code></p> <p>Nucleo kit for STM32L496ZG-P</p>"},{"location":"reference/config/modm-nucleo-l496zg-p/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32l496zgt6p&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-l496zg-p&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-l552ze-q/","title":"NUCLEO-L552ZE-Q","text":"<p>lbuild config: <code>modm:nucleo-l552ze-q</code></p> <p>Nucleo kit for STM32L552ZE-Q</p>"},{"location":"reference/config/modm-nucleo-l552ze-q/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32l552zet6q&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-l552ze-q&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-nucleo-u575zi-q/","title":"NUCLEO-U575ZI-Q","text":"<p>lbuild config: <code>modm:nucleo-u575zi-q</code></p> <p>Nucleo kit for STM32U575ZI-Q</p>"},{"location":"reference/config/modm-nucleo-u575zi-q/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32u575zit6q&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:nucleo-u575zi-q&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-olimexino-stm32/","title":"Olimexino STM32","text":"<p>lbuild config: <code>modm:olimexino-stm32</code></p> <p>Modified Maple board with STM32F103RBT6: https://www.olimex.com/Products/Duino/STM32/OLIMEXINO-STM32/open-source-hardware</p>"},{"location":"reference/config/modm-olimexino-stm32/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f103rbt6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:olimexino-stm32&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-rp-pico/","title":"Raspberry Pi Pico","text":"<p>lbuild config: <code>modm:rp-pico</code></p> <p>RP2040 Official System Development Board See https://www.raspberrypi.com/products/raspberry-pi-pico</p>"},{"location":"reference/config/modm-rp-pico/#programming","title":"Programming","text":""},{"location":"reference/config/modm-rp-pico/#uf2","title":"UF2","text":"<p>The RP2040 ships with a UF2 bootloader in ROM.</p> <p>To upload your application, connect the RP2040 via USB, convert the ELF to UF2 format by calling <code>scons uf2</code> or <code>make uf2</code> and copy the generated <code>.uf2</code> file to the mounted virtual disk.</p>"},{"location":"reference/config/modm-rp-pico/#openocd","title":"OpenOCD","text":"<p>Another option is to use Picoprobe and custom version of OpenOCD provided by RPi.</p> <p>You would need to build and program one of the boards with the Picoprobe firmware, configure and build RPi OpenOCD, and connect the boards via SWD. The wiring diagram and detailed description is available in the Pico Documentation.</p> <p>The how-to shows steps for building and installing the RPi OpenOCD into your system globally, however, if you still want to be able to work with other OpenOCD binaries, you should only install it locally:</p> <pre><code>sudo apt install automake autoconf build-essential texinfo libtool libftdi-dev libusb-1.0-0-dev\n\ncd ~/pico\ngit clone https://github.com/raspberrypi/openocd.git --branch rp2040 --depth=1 --no-single-branch\n\ncd openocd\n./bootstrap\n\nmkdir build\ncd build\n../configure --enable-picoprobe --prefix=$(realpath ../install)\n\nmake -j4\nmake install\n</code></pre> <p>Additional steps are needed to get access to the device from a non-privileged user on Linux. Edit or create the <code>/etc/udev/rules.d/60-openocd.rules</code> file and append these lines to it:</p> <pre><code># Raspberry Pi Picoprobe\nATTRS{idVendor}==\"2e8a\", ATTRS{idProduct}==\"0004\", MODE=\"660\", GROUP=\"plugdev\", TAG+=\"uaccess\"\n</code></pre> <p>Once you have both of your Pico boards connected according to the wiring diagram, you can run <code>scons program</code> to program the dev board:</p> <pre><code>export MODM_OPENOCD_BINARY=$HOME/pico/openocd/install/bin/openocd\nscons program\n</code></pre>"},{"location":"reference/config/modm-rp-pico/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;rp2040&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:boot2\"&gt;w25q080&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:boot2_size\"&gt;2Mi&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:rp-pico&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-samd21-mini/","title":"RobotDyn SAMD21 M0 MINI","text":"<p>lbuild config: <code>modm:samd21-mini</code></p> <p>The SAMD21 MINI board is a small breakout board for the ATSAMD21G18 ARM Cortex-M0 processor, clocked at 48 MHz and at 3.3V logic.</p> <p>See: https://robotdyn.com/samd21-m0-mini.html</p> <p>It can be bought for little cost from well known Chinese online stores.</p>"},{"location":"reference/config/modm-samd21-mini/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;samd21g18a-uu&lt;/option&gt;\n    &lt;option name=\"modm:platform:cortex-m:linkerscript.flash_offset\"&gt;0x2000&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:samd21-mini&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-samd21-xplained-pro/","title":"Microchip SAMD21 Xplained Pro","text":"<p>lbuild config: <code>modm:samd21-xplained-pro</code></p>"},{"location":"reference/config/modm-samd21-xplained-pro/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;samd21j18a-au&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:samd21-xplained-pro&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-same54-xplained-pro/","title":"Microchip SAME54 Xplained Pro","text":"<p>lbuild config: <code>modm:same54-xplained-pro</code></p>"},{"location":"reference/config/modm-same54-xplained-pro/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;same54p20a-au&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:same54-xplained-pro&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-same70-xplained/","title":"Microchip SAME70 Xplained","text":"<p>lbuild config: <code>modm:same70-xplained</code></p>"},{"location":"reference/config/modm-same70-xplained/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;same70q21a-an&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:same70-xplained&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-samg55-xplained-pro/","title":"Microchip SAMG55 Xplained Pro","text":"<p>lbuild config: <code>modm:samg55-xplained-pro</code></p>"},{"location":"reference/config/modm-samg55-xplained-pro/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;samg55j19a-au&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:samg55-xplained-pro&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-samv71-xplained-ultra/","title":"Microchip SAMV71 Xplained Ultra","text":"<p>lbuild config: <code>modm:samv71-xplained-ultra</code></p>"},{"location":"reference/config/modm-samv71-xplained-ultra/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;samv71q21b-aab&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:samv71-xplained-ultra&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-srxe/","title":"Smart Response XE","text":"<p>lbuild config: <code>modm:srxe</code></p> <p>Smart Response XE is an obsolete classroom clicker, sold for as little as 5 USD on well known online auction site. It's a compelling platform that's fully reverse engineered and ready to hack out of box, featuring:</p> <ul> <li>ATmega128RFA1 MCU</li> <li>384x136 LCD display</li> <li>QWERTY keyboard</li> <li>External 1MB SPI flash</li> <li>Exposed ISP and JTAG headers</li> <li>ZigBee transciever with antennas</li> <li>Powered by 4 AAA batteries</li> <li>Optional (unpopulated):</li> <li>RS232</li> <li>Debug LED</li> <li>Buzzer</li> <li>Accelerometer</li> </ul>"},{"location":"reference/config/modm-srxe/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;atmega128rfa1-zu&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:f_cpu\"&gt;16M&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:srxe&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-stm32_f4ve/","title":"STM32_F4VE","text":"<p>lbuild config: <code>modm:stm32_f4ve</code></p> <p>https://stm32-base.org/boards/STM32F407VET6-STM32-F4VE-V2.0.html</p>"},{"location":"reference/config/modm-stm32_f4ve/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f407vet6&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:stm32_f4ve&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-stm32f030_demo/","title":"STM32F030 Demo Board","text":"<p>lbuild config: <code>modm:stm32f030_demo</code></p> <p>STM32F030F4P6 Minimum System Development Board.</p> <p>Cheap and bread-board-friendly board for STM32 F0 series. https://stm32-base.org/boards/STM32F030F4P6-STM32F030-DEMO-BOARD-V1.1</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-stm32f030_demo/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32f030f4p6&lt;/option&gt;\n    &lt;option name=\"modm:rtt:buffer.tx\"&gt;256&lt;/option&gt;\n    &lt;option name=\"modm:rtt:buffer.rx\"&gt;16&lt;/option&gt;\n    &lt;option name=\"modm:platform:cortex-m:main_stack_size\"&gt;1Ki&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:stm32f030_demo&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-thingplus-rp2040/","title":"SparkFun Thing Plus - RP2040","text":"<p>lbuild config: <code>modm:thingplus-rp2040</code></p> <p>The SparkFun Thing Plus - RP2040 is a low-cost, high performance board with flexible digital interfaces featuring the Raspberry Pi Foundation's RP2040 microcontroller. Besides the Thing Plus or Feather footprint (with 18 GPIO pins), the board also includes an SD card slot, 16MB (128Mbit) flash memory, a JST single cell battery connector (with a charging circuit and fuel gauge sensor), an addressable WS2812 RGB LED, JTAG PTH pins, four (4-40 screw) mounting holes, and SparkFun's Qwiic connector.</p> <p>https://www.sparkfun.com/products/17745</p> <p>See <code>modm:rp-pico</code> for programming instructions.</p>"},{"location":"reference/config/modm-thingplus-rp2040/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;rp2040&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:boot2\"&gt;w25q080&lt;/option&gt;\n    &lt;option name=\"modm:platform:core:boot2_size\"&gt;16Mi&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:thingplus-rp2040&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/config/modm-weact-c011f6/","title":"WeAct Studio STM32C011F6 Core Board","text":"<p>lbuild config: <code>modm:weact-c011f6</code></p> <p>Documentation</p> <p>This board has no serial port and logs via RTT instead.</p>"},{"location":"reference/config/modm-weact-c011f6/#configuration","title":"Configuration","text":"<pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32c011f6p6&lt;/option&gt;\n    &lt;option name=\"modm:rtt:buffer.tx\"&gt;256&lt;/option&gt;\n    &lt;option name=\"modm:rtt:buffer.rx\"&gt;16&lt;/option&gt;\n    &lt;option name=\"modm:platform:cortex-m:main_stack_size\"&gt;1Ki&lt;/option&gt;\n  &lt;/options&gt;\n  &lt;modules&gt;\n    &lt;module&gt;modm:board:weact-c011f6&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/module/modm-architecture-1-wire/","title":"1-Wire","text":"<p>lbuild module: <code>modm:architecture:1-wire</code></p> <p>1-Wire is a device communications bus system designed by Dallas Semiconductor Corp. that provides low-speed data, signaling and power over a single signal. 1-Wire is similar in concept to I\u00b2C, but with lower data rates and longer range. It is typically used to communicate with small inexpensive devices such as digital thermometers and weather instruments.</p> <p>One distinctive feature of the bus is the possibility to use only two wires: data and ground. To accomplish this, 1-wire devices include an 800 pF capacitor to store charge, and power the device during periods where the data line is used for data.</p>"},{"location":"reference/module/modm-architecture-accessor/","title":"Memory Accessors","text":"<p>lbuild module: <code>modm:architecture:accessor</code></p>"},{"location":"reference/module/modm-architecture-adc/","title":"Analog-to-Digital Converters","text":"<p>lbuild module: <code>modm:architecture:adc</code></p>"},{"location":"reference/module/modm-architecture-assert/","title":"Assertions and Abandonment","text":"<p>lbuild module: <code>modm:architecture:assert</code></p> <p>This module provides a way to define and report assertions, that act as a low-cost replacement for C++ exceptions and as a low-cost customization point for errors raised in asynchronous code.</p> <p>Assertions are called with or without a context:</p> <ul> <li><code>modm_assert(condition, name, descr);</code></li> <li><code>modm_assert(condition, name, descr, context);</code></li> </ul> <p>They have the following arguments:</p> <ol> <li><code>bool condition</code>: The assertion fails when this condition evaluated to false.</li> <li><code>const char *name</code>: A short and unique assertion name.</li> <li><code>const char *description</code>: A detailed description of the failure.</li> <li><code>uintptr_t context = -1</code>: Optional context.</li> </ol> <p>The condition is evaluated at most once by a (C-style) cast to bool.</p> <p>The name format is not enforced, however, it is recommended to either use <code>what</code> for top-level failures, like <code>malloc</code> for heap troubles, or <code>scope.what</code> for failures that may not be unique, like <code>can.rx</code> vs. <code>uart.rx</code> for when their respective receive buffers overflow.</p> <p>The description can be as detailed as necessary, since it is only included in the firmware if the <code>with_description</code> option is set to true, which also defines <code>MODM_ASSERTION_INFO_HAS_DESCRIPTION</code> to 1 or 0. You can either find the detailed description in your code via its name, or if you prefer a stand-alone solution and your target has enough memory, include all strings in your binary.</p> <p>The context is of pointer size, and anything passed to it is cast to <code>uintptr_t</code>. Otherwise all bits are set via <code>uintptr_t(-1)</code>.</p> <p>Assertions are implemented as macros and expand to this pseudo-code equivalent:</p> <pre><code>void modm_assert(bool condition, const char *name, const char *description,\n                 uintptr_t context=uintptr_t(-1))\n{\n    if (not condition)\n    {\n        modm::AssertionInfo info{name, description, context};\n        modm_assert_report(info);\n        // Unreachable code\n    }\n}\n</code></pre> <p>Assertions can be used in both C and C++ code.</p> <p>If you like to know the technical details, you can read here about the original assertions in xpcc.</p>"},{"location":"reference/module/modm-architecture-assert/#assertion-handlers","title":"Assertion Handlers","text":"<p>Assertions may also be recoverable if the call site allows for it. For example if the CAN receive buffer overflows, you may want to simply discard the input. If malloc fails to allocate it just returns NULL and the caller is responsible to deal with that. But maybe you want to enable an additional assertion in debug mode just to double-check.</p> <p>When an assertion fails, the runtime calls any number of user-defined handlers, registered using <code>MODM_ASSERTION_HANDLER(handler)</code>. The handlers must return a <code>modm::Abandonment</code> value, specifying whether they want to continue with the execution with <code>Abandonment::Ignore</code>, or abandon execution with <code>Abandonment::Fail</code> leading to a call to <code>modm_abandon(info)</code>, or delegate the decision with <code>Abandonment::DontCare</code>.</p> <p>For example, this neutral handler logs the failed assertion's name, but delegates all further decisions to others:</p> <pre><code>static modm::Abandonment\nlog_assertion(const modm::AssertionInfo &amp;info)\n{\n    MODM_LOG_ERROR.printf(\"Assertion '%s' raised!\\n\", info.name);\n    return Abandonment::DontCare;\n}\n// Register handler for all builds\nMODM_ASSERTION_HANDLER(log_assertion);\n// Or register only for debug builds\nMODM_ASSERTION_HANDLER_DEBUG(log_assertion);\n</code></pre> <p>You may register specialized handlers anywhere in your code, for example for ignoring the mentioned CAN receive buffer overflow in your connectivity code:</p> <pre><code>static modm::Abandonment\nignore_can_rx_handler(const modm::AssertionInfo &amp;info)\n{\n    if (info.name == \"can.rx\"s) {\n        // Only silently ignore this specific assertion!\n        return Abandonment::Ignore;\n    }\n    return Abandonment::DontCare;\n}\nMODM_ASSERTION_HANDLER(ignore_can_rx_handler);\n</code></pre> <p>You may define any number of handlers, which are called in random order by the runtime and their results are accumulated as follows:</p> <ol> <li>If at least one handler returns <code>Abandonment::Fail</code> execution abandons.</li> <li>Otherwise if any handler returns <code>Abandonment::Ignore</code> execution resumes.</li> <li>Otherwise if no handlers are registered or all handlers return    <code>Abandonment::DontCare</code>, the assertion type determines the outcome.</li> </ol> <p>Handler execution order is undefined.</p> <p>The order of handler execution is undefined and must not be relied upon for any functionality!</p> <p>Assertions and handlers are not reentrant!</p> <p>Assertions may fail in an interrupt context, thus calling handlers in that context too. Since handlers may make use of interrupts themselves (for logging via UART) assertions are not atomically scoped by default. You may however use a <code>modm::atomic::Lock</code> inside your assertion handler.</p> <p>Handlers may be called inside high-priority interrupts!</p> <p>This is problematic when relying on interrupts still working inside handlers for example for logging the failure via UART. Be aware of this and make sure you do not inadvertently block inside handlers.</p>"},{"location":"reference/module/modm-architecture-assert/#assertion-types","title":"Assertion Types","text":"<p>The call site of the assertion decides whether an assertion can be recovered from or not. For example, if the CAN receive buffer has overflowed, but execution continues, then code to discard the message must be in place.</p> <p>In case no handlers are registered or they all delegate the abandonment decision away, the call site must decide what the default behavior is. For this purpose the following assertions are available:</p> <ol> <li><code>void modm_assert()</code>: Always abandons execution when failed.</li> <li><code>bool modm_assert_continue_fail()</code>: Abandons execution unless overwritten.</li> <li><code>bool modm_assert_continue_ignore()</code>: Resumes execution unless overwritten.</li> </ol> <p>Assertions that can resume execution return the evaluated boolean condition to be used to branch to cleanup code:</p> <pre><code>// Can be done inline in any flow control statement\nif (not modm_assert_continue_fail(condition, ...)) {\n    // cleanup code\n}\n\n// Or saved in a variable and queried multiple times.\nconst bool cleanup = not modm_assert_continue_ignore(condition, ...);\nif (cleanup) {\n    // cleanup code part 1\n}\n// other code\nif (cleanup) {\n    // cleanup code part 1\n}\n\n// or if cleanup is require *before* assertion is called\nconst bool is_ok = (condition);\nif (not is_ok) {\n    // pre-assert cleanup\n}\nmodm_assert_continue_fail(is_ok, ...);\nif (not is_ok) {\n    // post-assert cleanup\n}\n</code></pre> <p>Additionally, these assertions are only active in <code>profile=debug</code> (more about profiles: scons, make). Of course they still evaluate and return the condition in <code>profile=release</code>, so you can use them just as above:</p> <ol> <li><code>bool modm_assert_continue_fail_debug()</code></li> <li><code>bool modm_assert_continue_ignore_debug()</code></li> </ol> <p>Alternatively, you can guard the entire assertion statement with the <code>MODM_BUILD_DEBUG</code> macro if you only want to execute the check and branch in debug profile:</p> <pre><code>// The check is always performed, but only raises an assertion in debug profile!\nif (not modm_assert_continue_ignore_debug(cond, ...))\n{\n    // if the check fails, this branch is executed in release profile too!\n}\n\n#ifdef MODM_DEBUG_BUILD\n// This check if only performed in debug profile\nif (not modm_assert_continue_ignore(cond, ...))\n{\n    // if the check fails, this branch is executed only in debug profile!\n}\n#endif\n</code></pre>"},{"location":"reference/module/modm-architecture-assert/#when-to-use-what","title":"When to use what?","text":"<p>Here are some guidelines for choosing the best assertion type:</p> <ol> <li>Prefer to report errors via return types whenever possible!</li> <li>If no sane recovery is possible, use <code>modm_assert()</code>.</li> <li>If there is a (sensible) fallback for the failure, use    <code>modm_assert_continue_{fail|ignore}()</code>:    a. Abort by default, if the failure runs contrary to expected behavior.    b. Resume by default, if the failure is expected and its behavior is well       documented.</li> <li>If the failure is expected and communicated via the normal API, or it    only occurs rarely or through a clear misuse of the API, use    <code>modm_assert_continue_{fail|ignore}_debug()</code>.</li> </ol> <p>Let's illustrate these with a few examples:</p> <ol> <li>libc <code>exit()</code> is called. There is no sensible fallback, since there is no    operating system to return control back to, so use <code>modm_assert()</code>.</li> <li>An interrupt without a user-defined handler is triggered. The developer most    likely enabled the wrong interrupt or provided the wrong handler. A sensible    fallback is to disable the interrupt from triggering again and to alert the    developer with <code>modm_assert_continue_fail(..., irq_number)</code>.</li> <li>The CAN receive buffer overflows. A sensible fallback is to discard the    message, which is documented as the expected behavior. Since this occurs    asynchronously inside the CAN RX interrupt, there is no way to return an    error code, so call <code>modm_assert_continue_ignore(..., &amp;message)</code> with a    pointer to the message to inform the developer.</li> <li>malloc fails to due to heap exhaustion and returns NULL, delegating the    fallback implementation to the caller. Since the typical callers of malloc    are known for not checking for NULL, using    <code>modm_assert_continue_fail_debug()</code> here is warranted, helping the    developer find potential issues faster, and then ignoring this assert for    debug builds by registering a handler via <code>MODM_ASSERTION_HANDLER_DEBUG()</code>.</li> <li>An I2C transfer failure is detected inside an interrupt. Such failures are    expected on busses and typically the transfers are simply retried. You can    use <code>modm_assert_continue_ignore_debug()</code> to give the developer a way to    log the failure frequency without having to provide a special API. This can    help diagnose a problem perhaps with the bus connection faster.</li> </ol>"},{"location":"reference/module/modm-architecture-assert/#abandoning-execution","title":"Abandoning execution","text":"<p>If execution is abandoned <code>modm_abandon(const AssertionInfo &amp;info)</code> is called, which is a weak and empty function by default.</p> <p>The function is meant to be overwritten by the application on embedded targets for example to disable relevant hardware for safety, log the failure via UART and perhaps blink some LEDs wildly to get the user's attention.</p> <p>After returning from that function, the runtime resets the chip on Cortex-M, or loops forever on AVR, or calls <code>abort()</code> on hosted. You may of course, implement your own abandoning behavior instead of returning from <code>modm_abandon()</code>.</p> <p><code>modm_abandon()</code> may be called inside high-priority interrupts!</p> <p>You can try to lower the active IRQ priority to let UART work, however, in the worst case you're called from within the HardFault or even NMI handlers which have the highest fixed priority.</p>"},{"location":"reference/module/modm-architecture-assert/#options","title":"Options","text":""},{"location":"reference/module/modm-architecture-assert/#with_description","title":"with_description","text":"<p>Include assertion description</p> <p>Places the full description of a <code>modm_assert()</code> into the firmware image instead of only into the ELF file. This makes printing assertion information a simple standalone feature, fully independent of any additional script for decoding logging output, however, it may increase binary size considerably!</p> <p>Default: <code>debug</code> avr, rp, sam, stm32 Default: <code>release</code> hosted Inputs: <code>[debug, off, release]</code> </p>"},{"location":"reference/module/modm-architecture-assert/#dependencies","title":"Dependencies","text":"<p> modm:architecture:assert modm_architecture_assert modm: architecture: assert modm_architecture_accessor modm: architecture: accessor modm_architecture_assert-&gt;modm_architecture_accessor modm_architecture_register modm: architecture: register modm_architecture_assert-&gt;modm_architecture_register </p>"},{"location":"reference/module/modm-architecture-atomic/","title":"Atomic Operations and Containers","text":"<p>lbuild module: <code>modm:architecture:atomic</code></p>"},{"location":"reference/module/modm-architecture-block-device/","title":"Block Devices","text":"<p>lbuild module: <code>modm:architecture:block.device</code></p>"},{"location":"reference/module/modm-architecture-build_id/","title":"GNU Build ID","text":"<p>lbuild module: <code>modm:architecture:build_id</code></p>"},{"location":"reference/module/modm-architecture-can/","title":"Controller Area Network","text":"<p>lbuild module: <code>modm:architecture:can</code></p> <p>Controller\u2013area network (CAN or CAN-bus) is a vehicle bus standard designed to allow microcontrollers and devices to communicate with each other within a vehicle without a host computer.</p> <p>CAN is a message based protocol, designed specifically for automotive applications but now also used in other areas such as industrial automation and medical equipment.</p>"},{"location":"reference/module/modm-architecture-can/#options","title":"Options","text":""},{"location":"reference/module/modm-architecture-can/#messagebuffer","title":"message.buffer","text":"<p>Default: <code>8</code> Inputs: <code>[8 ... 64]</code> </p>"},{"location":"reference/module/modm-architecture-can/#dependencies","title":"Dependencies","text":"<p> modm:architecture:can modm_architecture_can modm: architecture: can modm_debug modm: debug modm_architecture_can-&gt;modm_debug </p>"},{"location":"reference/module/modm-architecture-clock/","title":"System Clock","text":"<p>lbuild module: <code>modm:architecture:clock</code></p> <p>To provide a system-wide time base this module provides two clocks:</p> <ul> <li><code>modm::Clock</code>: a 32-bit unsigned millisecond clock running for approx. 49 days   until wrap around, as an optimized replacement of <code>std::chrono::system_clock</code>.</li> <li><code>modm::PreciseClock</code>: a 32-bit unsigned microsecond clock running for approx.   71 minutes until wrap around, as an optimized replacement of   <code>std::chrono::high_resolution_clock</code>.</li> </ul> <p>These clocks are intended to measure time intervals:</p> <pre><code>const auto start = modm::PreciseClock::now();\nhow_long_does_this_function_take();\nconst auto duration = modm::PreciseClock::now() - start;\nMODM_LOG_DEBUG &lt;&lt; \"Function took \" &lt;&lt; duration &lt;&lt; modm::endl;\n</code></pre> <p>For additional common timeout and periodic timer use-cases also check out the <code>modm:processing:timer</code> module which uses these clocks.</p>"},{"location":"reference/module/modm-architecture-clock/#limitations","title":"Limitations","text":"<p>The clocks intended to be very lightweight to use, however, a few interface tradeoffs had to be made to achieve this goal.</p> <ol> <li>The clocks are not steady with their 32-bit counters overflowing after a    relatively short time. They must therefore only be used for measuring    intervals, not absolute time.</li> <li>The clocks have unsigned durations to make it easy to work with intervals    since the addition/subtraction of intervals works just fine on clocks    wrapping around, on the important condition that the interval is shorter than    the clocks wrap around time.</li> </ol> <p>Use a RTC-backed calendar for timekeeping!</p> <p>These clocks are definitely not accurate over long periods of time, since they are based on the internal clock supplies, which may have significant drift and thus are no replacement for a Real-Time Clock!</p> <p>Also check the <code>modm:platform:clock</code> module descriptions for additional limitations on clock resolution and clock drift depending on target.</p>"},{"location":"reference/module/modm-architecture-clock/#dependencies","title":"Dependencies","text":"<p> modm:architecture:clock modm_architecture_clock modm: architecture: clock modm_stdc++ modm: stdc++ modm_architecture_clock-&gt;modm_stdc++ </p>"},{"location":"reference/module/modm-architecture-delay/","title":"Blocking Delays","text":"<p>lbuild module: <code>modm:architecture:delay</code></p> <p>These functions allow you to spin for a short time using only the CPU.</p> <p>In general it is recommended to use the <code>std::chrono</code> duration types to allow the compiler to choose the optimal implementation for you:</p> <pre><code>#include &lt;chrono&gt;\n\nconstexpr std::chrono::nanoseconds DELAY_TIME{100};\nmodm::delay(DELAY_TIME);\n\nconstexpr std::chrono::microseconds DELAY_TIME2{200};\nmodm::delay(DELAY_TIME2); // same signature, different implementation\n</code></pre> <p>In your code you can also use the <code>std::chrono</code> literals:</p> <pre><code>using namespace std::chrono_literals;\n\nmodm::delay(100ns);\nmodm::delay(200us);\nmodm::delay(300ms);\nmodm::delay(400s);\n</code></pre> <p>In order to not require wild casting around of values, there are also three overloads for (unsigned) integer values. These are particularly useful for when you do not want to or cannot use chrono literals.</p> <pre><code>modm::delay_ns(100);\nmodm::delay_us(200);\nmodm::delay_ms(300);\n</code></pre> <p>Note that these delay functions work at any CPU clock speed, even if changed dynamically at runtime and are available very early in the startup process at hardware-init time.</p>"},{"location":"reference/module/modm-architecture-delay/#limitations","title":"Limitations","text":"<p>The main limitations are accuracy and length of delay. The only guarantee given to you is to delay for at least the specified time. Note that invocation of interrupts during spinning may add delay too.</p> <ul> <li><code>modm::delay(ns)</code> guarantees at most 1'000'000ns = 1ms delay.</li> <li><code>modm::delay(us)</code> guarantees at most 1'000'000\u00b5s = 1s delay.</li> <li><code>modm::delay(ms)</code> is limited to 49 days.</li> </ul> <p>Please note that the delay these functions provide is defined as the time from invocation to the time of execution return. Obviously no delay beyond that is considered, which may require you to use shorter delays to compensate for the overhead of your code:</p> <pre><code>do // GpioA4 toggling takes longer than 500ns because:\n{\n    modm::delay_ns(500); // takes ~500ns\n    GpioA4::toggle();    // takes a few cycles\n} while(1);              // jump back to loop also takes a few cycles\n</code></pre> <p>You should always prefer Software Timers (see <code>modm:processing:timer</code>) over these blocking delay functions. However, when <code>modm::Clock</code> is not set up yet, or when you need very small delays (for example to bit-bang a protocol), you need to use these delay functions.</p> <p>For the technical details on the delay implementations you can read \"Accurate Micro- and Nanosecond Delay in modm\".</p>"},{"location":"reference/module/modm-architecture-fiber/","title":"Fiber Interface","text":"<p>lbuild module: <code>modm:architecture:fiber</code></p> <p>This module provides an interface to yield control back to a scheduler. The basic functionality is provided by the <code>yield()</code> function which transparently gives control back to the scheduler and returns afterwards. It is particularly important to yield in long running loops to prevent the system from locking up by preventing other fibers from making progress:</p> <pre><code>while(true)\n{\n    // run your code here\n    // but always yield to other fibers whenever possible\n    modm::this_fiber::yield();\n}\n</code></pre> <p>For convenience a <code>poll()</code> function is provided that can be used to yield until a condition is met:</p> <pre><code>modm::this_fiber::poll([&amp;]{ return condition; });\n</code></pre> <p>An extension of this concept is provided by the <code>poll_for()</code> and <code>poll_until()</code> functions, which yield until the condition is met or until a timeout occurs:</p> <pre><code>bool condition_met = modm::this_fiber::poll_for(1s, [&amp;]{ return condition; });\n// if (not condition_met) condition did not return true for 1s.\n</code></pre> <p>If microseconds are passed for the duration, the functions use the <code>modm::chrono::micro_clock</code> (=<code>modm::PreciseClock</code>), otherwise they use <code>modm::chrono::milli_clock</code> (=<code>modm::Clock</code>). This requires that these clocks are already initialized and running.</p> <p>These basic building blocks are then used to implement the <code>sleep_for()</code> and <code>sleep_until()</code> convenience functions:</p> <pre><code>modm::this_fiber::sleep_for(1s);\n</code></pre>"},{"location":"reference/module/modm-architecture-fiber/#implementation","title":"Implementation","text":"<p>The <code>yield()</code> function is implemented by the <code>modm:processing:fiber</code> module which provides a cooperative multitasking scheduler that is able to switch between multiple fiber contexts.</p> <p>If <code>yield()</code> is called outside of a fiber context, for example, in the <code>main()</code> function when the scheduler is not yet running, <code>yield()</code> will return in-place. This mechanism allows for a graceful fallback to a blocking API without changes to the code using <code>yield()</code>.</p> <pre><code>modm::Fiber fiber_nonblocking([]\n{\n    modm::Timeout timeout(100ms);\n    timeout.wait(); // non-blocking call!\n});\nint main()\n{\n    modm::Timeout timeout(100ms);\n    timeout.wait(); // blocking call!\n\n    modm::fiber::Scheduler::run()\n    return 0;\n}\n</code></pre> <p>This mechanism also supports running modm on devices with very small memories where a stackful scheduler may be to resource intensive: The <code>modm:processing:fiber</code> module is strictly opt-in and if not selected the scheduler is not included and the <code>yield()</code> function is implemented as an empty stub while still allowing for the whole API to be used without changes:</p> <pre><code>modm::Lis3mdl&lt;I2cMaster1&gt; sensor{};\nint main()\n{\n    sensor.configure(); // blocking but works just fine\n    while(true)\n    {\n        modm::Vector3f magVector;\n        sensor.readMagnetometer(magVector); // another blocking call\n        modm::this_fiber::sleep_for(10ms); // this will wait in place\n    }\n}\n</code></pre> <p>Therefore, if you use these functions in your code, only depend on <code>modm:architecture:fiber</code> and let the user decide on the implementation by including <code>modm:processing:fiber</code> or not. This compromise allows for a seamless transition between different devices and scheduling strategies.</p>"},{"location":"reference/module/modm-architecture-fiber/#identifier","title":"Identifier","text":"<p>You can check what fiber your code is executed in by calling the <code>get_id()</code> function:</p> <pre><code>auto id = modm::this_fiber::get_id();\n// if (id == 0) called outside a fiber\n// else called from inside a fiber\n</code></pre> <p>The returned ID is the address of the currently running fiber object. If called outside of a fiber, for example, in the main function before the scheduler is running, the function returns <code>0</code>. The implementation ensures that all returned values are unique and thus allow the ID to be used for tracking ownership of various recursive locks, for example.</p>"},{"location":"reference/module/modm-architecture-fiber/#dependencies","title":"Dependencies","text":"<p> modm:architecture:fiber modm_architecture_fiber modm: architecture: fiber modm_architecture_clock modm: architecture: clock modm_architecture_fiber-&gt;modm_architecture_clock modm_processing modm: processing modm_architecture_fiber-&gt;modm_processing modm_stdc++ modm: stdc++ modm_architecture_fiber-&gt;modm_stdc++ </p>"},{"location":"reference/module/modm-architecture-gpio-expander/","title":"GPIO Expanders","text":"<p>lbuild module: <code>modm:architecture:gpio.expander</code></p>"},{"location":"reference/module/modm-architecture-gpio-expander/#dependencies","title":"Dependencies","text":"<p> modm:architecture:gpio.expander modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio modm: architecture: gpio modm_architecture_gpio_expander-&gt;modm_architecture_gpio modm_architecture_register modm: architecture: register modm_architecture_gpio_expander-&gt;modm_architecture_register modm_math_utils modm: math: utils modm_architecture_gpio_expander-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-architecture-gpio/","title":"General Purpose Input/Output","text":"<p>lbuild module: <code>modm:architecture:gpio</code></p> <p>GPIOs are modeled as individual classes with an interface consisting out of a common set of static methods.</p>"},{"location":"reference/module/modm-architecture-gpio/#using-gpios","title":"Using GPIOs","text":"<p>These classes are used to create architecture independent definitions for hardware pins which then can be used as template parameters for miscellaneous device drivers.</p> <p>Example of a platform-independent blinking light:</p> <pre><code>#include &lt;modm/platform.hpp&gt;\n\nusing Led = GpioOutputB0;\n\nLed::setOutput();\nLed::set();\n\nwhile (true)\n{\n    Led::toggle();\n    modm::delay(500ms);\n}\n</code></pre> <p>You can use the common definitions of <code>modm::Gpio</code> to express your intention for setting a pin. However, you can also use anything that casts to <code>bool</code>.</p> <pre><code>Led::set(modm::Gpio::High); // Turns Led on\nLed::set(modm::Gpio::Low); // Turns Led off\nLed::set(true);\nLed::set(false);\nLed::set(1);\nLed::set(0);\nLed::set();\nLed::reset();\n</code></pre> <p>Initialize your GPIOs</p> <p>Call <code>Gpio::setInput()</code> or <code>Gpio::setOutput()</code> before the first use, otherwise the GPIO state may be undefined!</p> <p>See the <code>modm:platform:gpio</code> module for platform-specific GPIO behaviors, especially signal connections to peripherals.</p>"},{"location":"reference/module/modm-architecture-i2c-device/","title":"I\u00b2C Devices","text":"<p>lbuild module: <code>modm:architecture:i2c.device</code></p>"},{"location":"reference/module/modm-architecture-i2c-device/#dependencies","title":"Dependencies","text":"<p> modm:architecture:i2c.device modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture_fiber modm: architecture: fiber modm_architecture_i2c_device-&gt;modm_architecture_fiber modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c_device-&gt;modm_architecture_i2c </p>"},{"location":"reference/module/modm-architecture-i2c-multiplexer/","title":"I\u00b2C Multiplexer","text":"<p>lbuild module: <code>modm:architecture:i2c.multiplexer</code></p>"},{"location":"reference/module/modm-architecture-i2c-multiplexer/#dependencies","title":"Dependencies","text":"<p> modm:architecture:i2c.multiplexer modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c_multiplexer-&gt;modm_architecture_i2c </p>"},{"location":"reference/module/modm-architecture-i2c/","title":"Inter-Integrated Circuit (I\u00b2C)","text":"<p>lbuild module: <code>modm:architecture:i2c</code></p>"},{"location":"reference/module/modm-architecture-i2c/#dependencies","title":"Dependencies","text":"<p> modm:architecture:i2c modm_architecture_i2c modm: architecture: i2c modm_architecture_fiber modm: architecture: fiber modm_architecture_i2c-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_architecture_i2c-&gt;modm_architecture_gpio </p>"},{"location":"reference/module/modm-architecture-interrupt/","title":"Interrupt Service Routines","text":"<p>lbuild module: <code>modm:architecture:interrupt</code></p>"},{"location":"reference/module/modm-architecture-memory/","title":"Memory Traits","text":"<p>lbuild module: <code>modm:architecture:memory</code></p> <p>Memories have different traits, such as DMA-ability or access time. The memory allocator functions (<code>malloc()</code>, <code>operator new</code>, etc) by default only return DMA-able memories, ordered by fastest access time. To allocate memory with specific traits, use the overloaded <code>operator new</code>:</p> <pre><code>auto *p = new (modm::MemoryFastData) Foo;\nauto *q = new (modm::MemoryExternal, std::nothrow) Foo;\n</code></pre> <p>You need to choose a heap implementation!</p> <p>You can include the <code>modm:platform:heap</code> module or supply your own implementation.</p>"},{"location":"reference/module/modm-architecture-memory/#dependencies","title":"Dependencies","text":"<p> modm:architecture:memory modm_architecture_memory modm: architecture: memory modm_architecture_register modm: architecture: register modm_architecture_memory-&gt;modm_architecture_register </p>"},{"location":"reference/module/modm-architecture-register/","title":"General Purpose Registers","text":"<p>lbuild module: <code>modm:architecture:register</code></p> <p>Data structures to provide a native register abstraction.</p> <p>These data structures are used to describe the relationship of single bits, bit groups and bit configurations in registers with type-safe access.</p> <p>Registers can be made up of three things:</p> <ul> <li>Bits: a single bit (position N),</li> <li>Configurations: a combination of bits where the meaning does not correspond to its numeric value (position [N, M])</li> <li>Values: a numeric value (position [N, M])</li> </ul> <p>Example of an 8-bit register called Control</p> <pre><code>   7    6    5      4      3      2      1    0\n| EN | FS | PRE1 | PRE0 | DEL2 | DEL1 | DEL0 | |\n</code></pre> <ul> <li>Bit 7: Enable</li> <li>Bit 6: Full Scale</li> <li>Configuration [5, 4]: Prescaler<ul> <li>00: Divide by 1</li> <li>01: Divide by 2</li> <li>10: Divide by 4</li> <li>11: Divide by 8</li> </ul> </li> <li>Value [3, 1]: Start-Up Delay in ms</li> </ul>"},{"location":"reference/module/modm-architecture-register/#register-bits","title":"Register Bits","text":"<p>The bits can be modelled using strongly-typed enums and the Flags template class as follows:</p> <pre><code>enum class\nControl : uint8_t\n{\n    EN = Bit7,  ///&lt; bit documentation\n    FS = Bit6,\n\n    PRE1 = Bit5,\n    PRE0 = Bit4,\n\n    DEL2 = Bit3,\n    DEL1 = Bit2,\n    DEL0 = Bit1,\n};\nMODM_FLAGS8(Control);\n// expands to\n// typedef modm::Flags8&lt; Control &gt;  Control_t;\n// and some enum operator overloading magic\n</code></pre> <p>You can handle all its register bits as you would expect:</p> <pre><code>Control_t control = Control::EN;\ncontrol = Control::EN | Control::FS;\ncontrol &amp;= ~Control::FS;\ncontrol |= Control::FS;\ncontrol ^= Control::PRE1;\nbool isSet = control &amp; Control::FS;\n\ncontrol.reset(Control::PRE1 | Control::PRE0);\ncontrol.set(Control::DEL0);\n\nbool noneSet = control.none(Control::PRE1 | Control::PRE0);\nbool allSet = control.all(Control::EN | Control::FS);\n</code></pre> <p>You still get raw access if you really need it:</p> <pre><code>uint8_t raw = control.value; // the underlying type\ncontrol.value = 0x24;\n</code></pre> <p>The access is type-safe, you cannot use bits from two different registers:</p> <pre><code>enum class Control2 : uint8_t\n{\n    DIS = Bit4,\n    HS = Bit3,\n};\nMODM_FLAGS8(Control2);\n\nauto control = Control::EN | Control2::HS; // compile error\n</code></pre> <p>You can even overload functions on argument type now:</p> <pre><code>void write(Control_t control);\nvoid write(Control2_t control);\n\nwrite(Control::EN | Control::FS);  // calls #1\nwrite(Control2::DIS);              // calls #2\n</code></pre>"},{"location":"reference/module/modm-architecture-register/#register-configurations","title":"Register Configurations","text":"<p>Configurations are also described as a strongly-typed enum and then wrapped into the Configuration template class.</p> <pre><code>enum class\nPrescaler : uint8_t\n{\n    Div1 = 0,               ///&lt; configuration documentation\n    Div2 = int(Control::PRE0),\n    Div4 = int(Control::PRE1),\n    Div8 = int(Control::PRE1) | int(Control::PRE0),\n};\ntypedef Configuration&lt; Control_t, Prescaler, (Bit5 | Bit4) &gt;  Prescaler_t;\n</code></pre> <p>The <code>Prescaler</code> enum values are already shifted in this example (hence the <code>(Bit5 | Bit4)</code> mask), however you can also declare the prescaler values non-shifted and let the wrapper shift it:</p> <pre><code>enum class Prescaler : uint8_t\n{\n    Div1 = 0,\n    Div2 = 1,\n    Div4 = 2,\n    Div8 = 3,\n};\ntypedef Configuration&lt;Control_t, Prescaler, 0b11, 4&gt; Prescaler_t;\n</code></pre> <p>Why? If you have two or more configurations with the same selections in the same register,  you can simply add another one:</p> <pre><code>typedef Configuration&lt; Control_t, Prescaler, 0b11, 6 &gt;  Prescaler2_t;\n</code></pre> <p>Configurations can be used inline:</p> <pre><code>Control_t control = Control::EN | Prescaler_t(Prescaler::Div2);\nControl_t control &amp;= ~Prescaler_t::mask();\n</code></pre> <p>But do not have to:</p> <pre><code>Prescaler_t::set(control, Prescaler::Div2);\nPrescaler_t::reset(control);\nPrescaler prescaler = Prescaler_t::get(control);\n</code></pre>"},{"location":"reference/module/modm-architecture-register/#register-values","title":"Register Values","text":"<p>Values are described using the Value template class which masks and shifts the value as required. In our example the value has a width of 3 bits and needs to be shifted 1 bit:</p> <pre><code>typedef Value&lt; Control_t, 3, 1 &gt;  Delay_t;\n</code></pre> <p>This can be used the same way as the Configuration:</p> <pre><code>Control_t control = Control::EN | Prescaler_t(Prescaler::Div2) | Delay_t(4);\nControl_t control &amp;= ~Delay_t::mask();\n\nDelay_t::set(control, 7);\nDelay_t::reset(control);\nuint8_t delay = Delay_t::get(control);\n</code></pre> <p>See Typesafe Register Access in C++ for a more detailed background on this implementation.</p>"},{"location":"reference/module/modm-architecture-register/#dependencies","title":"Dependencies","text":"<p> modm:architecture:register modm_architecture_register modm: architecture: register modm_math_utils modm: math: utils modm_architecture_register-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-architecture-spi-device/","title":"SPI Devices","text":"<p>lbuild module: <code>modm:architecture:spi.device</code></p>"},{"location":"reference/module/modm-architecture-spi-device/#dependencies","title":"Dependencies","text":"<p> modm:architecture:spi.device modm_architecture_spi_device modm: architecture: spi.device modm_architecture_spi modm: architecture: spi modm_architecture_spi_device-&gt;modm_architecture_spi </p>"},{"location":"reference/module/modm-architecture-spi/","title":"Serial Peripheral Interface (SPI)","text":"<p>lbuild module: <code>modm:architecture:spi</code></p>"},{"location":"reference/module/modm-architecture-uart-device/","title":"UART Devices","text":"<p>lbuild module: <code>modm:architecture:uart.device</code></p>"},{"location":"reference/module/modm-architecture-uart-device/#dependencies","title":"Dependencies","text":"<p> modm:architecture:uart.device modm_architecture_uart_device modm: architecture: uart.device modm_architecture_uart modm: architecture: uart modm_architecture_uart_device-&gt;modm_architecture_uart modm_processing_timer modm: processing: timer modm_architecture_uart_device-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-architecture-uart/","title":"Universal Asynchronous Receiver/Transmitter (UART)","text":"<p>lbuild module: <code>modm:architecture:uart</code></p>"},{"location":"reference/module/modm-architecture-unaligned/","title":"Unaligned Memory Accessor","text":"<p>lbuild module: <code>modm:architecture:unaligned</code></p>"},{"location":"reference/module/modm-architecture/","title":"Architecture Interfaces","text":"<p>lbuild module: <code>modm:architecture</code></p> <p>All hardware peripherals with common interfaces.</p>"},{"location":"reference/module/modm-architecture/#dependencies","title":"Dependencies","text":"<p> modm:architecture modm_architecture modm: architecture modm_math_units modm: math: units modm_architecture-&gt;modm_math_units </p>"},{"location":"reference/module/modm-board-al-avreb-can/","title":"AL-AVREB_CAN Board","text":"<p>lbuild module: <code>modm:board:al-avreb-can</code></p> <p>AVR breakout board with AT90CAN128: https://www.alvidi.de/products/DE/AVR_Entwicklungsboards/avr_modul_avreb_can.php</p> <p>This module is only available for avr90.</p>"},{"location":"reference/module/modm-board-al-avreb-can/#dependencies","title":"Dependencies","text":"<p> modm:board:al-avreb-can modm_board_al_avreb_can modm: board: al-avreb-can modm_architecture_clock modm: architecture: clock modm_board_al_avreb_can-&gt;modm_architecture_clock modm_debug modm: debug modm_board_al_avreb_can-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_al_avreb_can-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_al_avreb_can-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_al_avreb_can-&gt;modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_al_avreb_can-&gt;modm_platform_uart_1 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-arduino-nano/","title":"Arduino NANO","text":"<p>lbuild module: <code>modm:board:arduino-nano</code></p> <p>This module is only available for avrmega.</p>"},{"location":"reference/module/modm-board-arduino-nano/#dependencies","title":"Dependencies","text":"<p> modm:board:arduino-nano modm_board_arduino_nano modm: board: arduino-nano modm_architecture_clock modm: architecture: clock modm_board_arduino_nano-&gt;modm_architecture_clock modm_architecture_interrupt modm: architecture: interrupt modm_board_arduino_nano-&gt;modm_architecture_interrupt modm_debug modm: debug modm_board_arduino_nano-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_arduino_nano-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_arduino_nano-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_arduino_nano-&gt;modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_arduino_nano-&gt;modm_platform_uart_0 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-arduino-uno/","title":"Arduino UNO","text":"<p>lbuild module: <code>modm:board:arduino-uno</code></p> <p>This module is only available for avrmega.</p>"},{"location":"reference/module/modm-board-arduino-uno/#dependencies","title":"Dependencies","text":"<p> modm:board:arduino-uno modm_board_arduino_uno modm: board: arduino-uno modm_architecture_clock modm: architecture: clock modm_board_arduino_uno-&gt;modm_architecture_clock modm_architecture_interrupt modm: architecture: interrupt modm_board_arduino_uno-&gt;modm_architecture_interrupt modm_debug modm: debug modm_board_arduino_uno-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_arduino_uno-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_arduino_uno-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_arduino_uno-&gt;modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_arduino_uno-&gt;modm_platform_uart_0 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-black-pill-f103/","title":"Black Pill","text":"<p>lbuild module: <code>modm:board:black-pill-f103</code></p> <p>STM32F103C8T6 \"Black Pill\" Minimum System Development Board</p> <p>Cheap and bread-board-friendly board for STM32 F1 series. Sold for less than 2 USD on Aliexpress.</p> <p>https://stm32-base.org/boards/STM32F103C8T6-Black-Pill.html</p> <p>This module is only available for stm32f103c8t6.</p>"},{"location":"reference/module/modm-board-black-pill-f103/#dependencies","title":"Dependencies","text":"<p> modm:board:black-pill-f103 modm_board_black_pill_f103 modm: board: black-pill-f103 modm_architecture_clock modm: architecture: clock modm_board_black_pill_f103-&gt;modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_black_pill_f103-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_black_pill_f103-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_black_pill_f103-&gt;modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_black_pill_f103-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-black-pill-f401/","title":"Black Pill F401","text":"<p>lbuild module: <code>modm:board:black-pill-f401</code></p> <p>STM32F401CCU \"Mini-F401\" Minimum System Development Board</p> <p>Cheap and bread-board-friendly board for STM32F401 series. Sold for less than 4 USD on Aliexpress. Attention: There are two variants: Mini-F411 and the cheaper Mini-F401.</p> <p>https://stm32-base.org/boards/STM32F401CEU6-WeAct-Black-Pill-V3.0</p>"},{"location":"reference/module/modm-board-black-pill-f401/#programming","title":"Programming","text":"<p>Since the board has no St-Link programmer on the board, you must use DFU (Device Firmware Update (via USB)) to program the board. A DFU command is integrated into the <code>modm:build:scons</code> tool and can be called as follows:</p> <pre><code>scons program-dfu\n</code></pre> <p>This module is only available for stm32f401ccu6.</p>"},{"location":"reference/module/modm-board-black-pill-f401/#dependencies","title":"Dependencies","text":"<p> modm:board:black-pill-f401 modm_board_black_pill_f401 modm: board: black-pill-f401 modm_architecture_clock modm: architecture: clock modm_board_black_pill_f401-&gt;modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_black_pill_f401-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_black_pill_f401-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_black_pill_f401-&gt;modm_platform_gpio modm_platform_usb_fs modm: platform: usb: fs modm_board_black_pill_f401-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-black-pill-f411/","title":"Black Pill F411","text":"<p>lbuild module: <code>modm:board:black-pill-f411</code></p> <p>STM32F411CEU \"Mini-F411\" Minimum System Development Board</p> <p>Cheap and bread-board-friendly board for STM32F411 series. Sold for less than 5 USD on Aliexpress. Attention: There are two variants: Mini-F411 and the cheaper Mini-F401.</p> <p>https://stm32-base.org/boards/STM32F401CEU6-WeAct-Black-Pill-V3.0</p>"},{"location":"reference/module/modm-board-black-pill-f411/#programming","title":"Programming","text":"<p>Since the board has no St-Link programmer on the board, you must use DFU (Device Firmware Update (via USB)) to program the board. A DFU command is integrated into the <code>modm:build:scons</code> tool and can be called as follows:</p> <pre><code>scons program-dfu\n</code></pre> <p>This module is only available for stm32f411ceu6.</p>"},{"location":"reference/module/modm-board-black-pill-f411/#dependencies","title":"Dependencies","text":"<p> modm:board:black-pill-f411 modm_board_black_pill_f411 modm: board: black-pill-f411 modm_architecture_clock modm: architecture: clock modm_board_black_pill_f411-&gt;modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_black_pill_f411-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_black_pill_f411-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_black_pill_f411-&gt;modm_platform_gpio modm_platform_usb_fs modm: platform: usb: fs modm_board_black_pill_f411-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-blue-pill-f103/","title":"Blue Pill","text":"<p>lbuild module: <code>modm:board:blue-pill-f103</code></p> <p>STM32F103C8T6 \"Blue Pill\" Minimum System Development Board</p> <p>Cheap and bread-board-friendly board for STM32 F1 series. Sold for less than 2 USD on Aliexpress.</p> <p>https://stm32-base.org/boards/STM32F103C8T6-Blue-Pill.html</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32f103c8t6.</p>"},{"location":"reference/module/modm-board-blue-pill-f103/#dependencies","title":"Dependencies","text":"<p> modm:board:blue-pill-f103 modm_board_blue_pill_f103 modm: board: blue-pill-f103 modm_architecture_clock modm: architecture: clock modm_board_blue_pill_f103-&gt;modm_architecture_clock modm_debug modm: debug modm_board_blue_pill_f103-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_blue_pill_f103-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_blue_pill_f103-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_blue_pill_f103-&gt;modm_platform_gpio modm_platform_rtt modm: platform: rtt modm_board_blue_pill_f103-&gt;modm_platform_rtt modm_platform_usb modm: platform: usb modm_board_blue_pill_f103-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-devebox-stm32f4xx/","title":"STM32F4XX mcudev DevEBox","text":"<p>lbuild module: <code>modm:board:devebox-stm32f4xx</code></p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32f4.</p>"},{"location":"reference/module/modm-board-devebox-stm32f4xx/#dependencies","title":"Dependencies","text":"<p> modm:board:devebox-stm32f4xx modm_board_devebox_stm32f4xx modm: board: devebox-stm32f4xx modm_debug modm: debug modm_board_devebox_stm32f4xx-&gt;modm_debug modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_board_devebox_stm32f4xx-&gt;modm_driver_block_device_spi_flash modm_platform_clock modm: platform: clock modm_board_devebox_stm32f4xx-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_devebox_stm32f4xx-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_devebox_stm32f4xx-&gt;modm_platform_gpio modm_platform_rtt modm: platform: rtt modm_board_devebox_stm32f4xx-&gt;modm_platform_rtt modm_platform_spi_1 modm: platform: spi: 1 modm_board_devebox_stm32f4xx-&gt;modm_platform_spi_1 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-devebox-stm32h750vb/","title":"STM32F750VB mcudev DevEBox","text":"<p>lbuild module: <code>modm:board:devebox-stm32h750vb</code></p> <p>STM32F750VB mcudev DevEBox H7xx</p> <p>Please note that this BSP uses the Y revision of the STM32H750, which limits the main clock frequency to \u2264400MHz and applies an errata bug fix to the SysTick, whose reference clock cannot be divided by 8.</p> <p>See the STM32H750 errata sheet.</p> <p>In case you are using the new revision V of STM32H750, you can overwrite the target option in your <code>project.xml</code>:</p> <pre><code>&lt;library&gt;\n  &lt;extends&gt;modm:devebox-stm32h750vb&lt;/extends&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32h750vbt6/revV&lt;/option&gt;\n  &lt;/options&gt;\n&lt;/library&gt;\n</code></pre> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32h7.</p>"},{"location":"reference/module/modm-board-devebox-stm32h750vb/#dependencies","title":"Dependencies","text":"<p> modm:board:devebox-stm32h750vb modm_board_devebox_stm32h750vb modm: board: devebox-stm32h750vb modm_debug modm: debug modm_board_devebox_stm32h750vb-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_devebox_stm32h750vb-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_devebox_stm32h750vb-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_devebox_stm32h750vb-&gt;modm_platform_gpio modm_platform_rtt modm: platform: rtt modm_board_devebox_stm32h750vb-&gt;modm_platform_rtt modm_platform_uart_1 modm: platform: uart: 1 modm_board_devebox_stm32h750vb-&gt;modm_platform_uart_1 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f051r8/","title":"STM32F0DISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f051r8</code></p> <p>Discovery kit for STM32F051</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32f051r8t6.</p>"},{"location":"reference/module/modm-board-disco-f051r8/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f051r8 modm_board_disco_f051r8 modm: board: disco-f051r8 modm_architecture_clock modm: architecture: clock modm_board_disco_f051r8-&gt;modm_architecture_clock modm_debug modm: debug modm_board_disco_f051r8-&gt;modm_debug modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f051r8-&gt;modm_driver_l3gd20 modm_platform_clock modm: platform: clock modm_board_disco_f051r8-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f051r8-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f051r8-&gt;modm_platform_gpio modm_platform_rtt modm: platform: rtt modm_board_disco_f051r8-&gt;modm_platform_rtt </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f072rb/","title":"STM32F072DISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f072rb</code></p> <p>Discovery kit for STM32F072</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32f072rbt6.</p>"},{"location":"reference/module/modm-board-disco-f072rb/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f072rb modm_board_disco_f072rb modm: board: disco-f072rb modm_architecture_clock modm: architecture: clock modm_board_disco_f072rb-&gt;modm_architecture_clock modm_debug modm: debug modm_board_disco_f072rb-&gt;modm_debug modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f072rb-&gt;modm_driver_l3gd20 modm_platform_clock modm: platform: clock modm_board_disco_f072rb-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f072rb-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f072rb-&gt;modm_platform_gpio modm_platform_rtt modm: platform: rtt modm_board_disco_f072rb-&gt;modm_platform_rtt modm_platform_spi_2 modm: platform: spi: 2 modm_board_disco_f072rb-&gt;modm_platform_spi_2 modm_platform_usb modm: platform: usb modm_board_disco_f072rb-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f100rb/","title":"STM32VLDISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f100rb</code></p> <p>Discovery kit for STM32F100</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32f100rbt6.</p>"},{"location":"reference/module/modm-board-disco-f100rb/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f100rb modm_board_disco_f100rb modm: board: disco-f100rb modm_architecture_clock modm: architecture: clock modm_board_disco_f100rb-&gt;modm_architecture_clock modm_debug modm: debug modm_board_disco_f100rb-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_disco_f100rb-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f100rb-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f100rb-&gt;modm_platform_gpio modm_platform_rtt modm: platform: rtt modm_board_disco_f100rb-&gt;modm_platform_rtt </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f303vc/","title":"STM32F3DISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f303vc</code></p> <p>Discovery kit for STM32F303</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32f303vct6.</p>"},{"location":"reference/module/modm-board-disco-f303vc/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f303vc modm_board_disco_f303vc modm: board: disco-f303vc modm_debug modm: debug modm_board_disco_f303vc-&gt;modm_debug modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f303vc-&gt;modm_driver_l3gd20 modm_driver_lsm303a modm: driver: lsm303a modm_board_disco_f303vc-&gt;modm_driver_lsm303a modm_platform_clock modm: platform: clock modm_board_disco_f303vc-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f303vc-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f303vc-&gt;modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f303vc-&gt;modm_platform_i2c_1 modm_platform_rtt modm: platform: rtt modm_board_disco_f303vc-&gt;modm_platform_rtt modm_platform_spi_1 modm: platform: spi: 1 modm_board_disco_f303vc-&gt;modm_platform_spi_1 modm_platform_usb modm: platform: usb modm_board_disco_f303vc-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f401vc/","title":"STM32F401DISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f401vc</code></p> <p>Discovery kit for STM32F401</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32f401vct6.</p>"},{"location":"reference/module/modm-board-disco-f401vc/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f401vc modm_board_disco_f401vc modm: board: disco-f401vc modm_debug modm: debug modm_board_disco_f401vc-&gt;modm_debug modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f401vc-&gt;modm_driver_l3gd20 modm_driver_lsm303a modm: driver: lsm303a modm_board_disco_f401vc-&gt;modm_driver_lsm303a modm_platform_clock modm: platform: clock modm_board_disco_f401vc-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f401vc-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f401vc-&gt;modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f401vc-&gt;modm_platform_i2c_1 modm_platform_rtt modm: platform: rtt modm_board_disco_f401vc-&gt;modm_platform_rtt modm_platform_spi_1 modm: platform: spi: 1 modm_board_disco_f401vc-&gt;modm_platform_spi_1 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f401vc-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f407vg/","title":"STM32F4DISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f407vg</code></p> <p>Discovery kit for STM32F407</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32f407vgt6.</p>"},{"location":"reference/module/modm-board-disco-f407vg/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f407vg modm_board_disco_f407vg modm: board: disco-f407vg modm_debug modm: debug modm_board_disco_f407vg-&gt;modm_debug modm_driver_lis3dsh modm: driver: lis3dsh modm_board_disco_f407vg-&gt;modm_driver_lis3dsh modm_platform_clock modm: platform: clock modm_board_disco_f407vg-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f407vg-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f407vg-&gt;modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f407vg-&gt;modm_platform_i2c_1 modm_platform_rtt modm: platform: rtt modm_board_disco_f407vg-&gt;modm_platform_rtt modm_platform_spi_1 modm: platform: spi: 1 modm_board_disco_f407vg-&gt;modm_platform_spi_1 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f407vg-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f411ve/","title":"STM32F4DISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f411ve</code></p> <p>Discovery kit for STM32F411</p> <p>This module is only available for stm32f411vet6.</p>"},{"location":"reference/module/modm-board-disco-f411ve/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f411ve modm_board_disco_f411ve modm: board: disco-f411ve modm_debug modm: debug modm_board_disco_f411ve-&gt;modm_debug modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f411ve-&gt;modm_driver_l3gd20 modm_driver_lis3dsh modm: driver: lis3dsh modm_board_disco_f411ve-&gt;modm_driver_lis3dsh modm_driver_lsm303a modm: driver: lsm303a modm_board_disco_f411ve-&gt;modm_driver_lsm303a modm_platform_clock modm: platform: clock modm_board_disco_f411ve-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f411ve-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f411ve-&gt;modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f411ve-&gt;modm_platform_i2c_1 modm_platform_rtt modm: platform: rtt modm_board_disco_f411ve-&gt;modm_platform_rtt modm_platform_spi_1 modm: platform: spi: 1 modm_board_disco_f411ve-&gt;modm_platform_spi_1 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f411ve-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f429zi/","title":"STM32F429IDISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f429zi</code></p> <p>Discovery kit for STM32F429</p>"},{"location":"reference/module/modm-board-disco-f429zi/#logging","title":"Logging","text":"<p>To use the logging, you need to close SB11 and SB15 and upgrade the STLINK/V2-B firmware! See Section 6.3 \"Embedded ST-LINK/V2-B\" of UM1670.</p>"},{"location":"reference/module/modm-board-disco-f429zi/#tinyusb","title":"TinyUSB","text":"<p>To use the USB port, you must configure TinyUSB to use the HS port in FS mode:</p> <pre><code>&lt;option name=\"modm:tinyusb:max-speed\"&gt;full&lt;/option&gt;\n&lt;!-- place either the device or host classes on the HS port --&gt;\n&lt;option name=\"modm:tinyusb:device:port\"&gt;hs&lt;/option&gt;\n&lt;option name=\"modm:tinyusb:host:port\"&gt;hs&lt;/option&gt;\n</code></pre> <p>This module is only available for stm32f429zit6.</p>"},{"location":"reference/module/modm-board-disco-f429zi/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f429zi modm_board_disco_f429zi modm: board: disco-f429zi modm_architecture_clock modm: architecture: clock modm_board_disco_f429zi-&gt;modm_architecture_clock modm_debug modm: debug modm_board_disco_f429zi-&gt;modm_debug modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f429zi-&gt;modm_driver_l3gd20 modm_platform_clock modm: platform: clock modm_board_disco_f429zi-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f429zi-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f429zi-&gt;modm_platform_gpio modm_platform_spi_5 modm: platform: spi: 5 modm_board_disco_f429zi-&gt;modm_platform_spi_5 modm_platform_uart_1 modm: platform: uart: 1 modm_board_disco_f429zi-&gt;modm_platform_uart_1 modm_platform_usb_hs modm: platform: usb: hs modm_board_disco_f429zi-&gt;modm_platform_usb_hs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f469ni/","title":"STM32F469IDISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f469ni</code></p> <p>Discovery kit with STM32F469NI MCU.</p> <p>This BSPs <code>Board::initialize()</code> sets the board up with these settings:</p> <ul> <li>180MHz CPU clock frequency in overdrive mode.</li> <li>90MHz APB2 and 45MHz APB1 clock frequency.</li> <li>MODM_LOGGER initialized at 115.2kBaud outputting on STLink.</li> <li>16MB SDRAM initialized for heap.</li> <li>Disables the display by default.</li> </ul> <p>You can enable and use the on-board display in two ways:</p> <ol> <li>Use the <code>modm::GraphicDisplay</code> returned by <code>Board::getDisplay()</code>, which    initializes the display on first call and allocates the framebuffer in the    external SDRAM. This is the simplest option.</li> <li>Call <code>Board::initializeDisplay()</code> and then provide your own display buffer    with <code>Board::setDisplayBuffer(void*)</code>.</li> </ol> <p>No Double-Buffering!</p> <p>Double-buffering is not implemented, so you may notice some tearing if you update the display fast enough.</p> <p>Access to the capacitive touchscreen is provided in the <code>Board::ft6</code> namespace. Call <code>Board::initializeTouchscreen()</code> to setup the peripherals.</p> <p>Product Link</p>"},{"location":"reference/module/modm-board-disco-f469ni/#hardware-revisions","title":"Hardware Revisions","text":"<p>The revision B-03 has a different touch sensor address from B-01 and B-02. The correct address for the revision is provided as <code>Board::ft6::TouchAddress</code>:</p> <pre><code>Board::ft6::Touch::Data data;\nBoard::ft6::Touch touchSensor(data, Board::ft6::TouchAddress);\n</code></pre> <p>If you want to provide the same code for both revisions, you can change the address at runtime if the device does not respond to a ping:</p> <pre><code>if (not touchSensor.ping()) touchSensor.setAddress(Board::ft6::TouchAddress2);\n</code></pre> <p>This module is only available for stm32f469nih6.</p>"},{"location":"reference/module/modm-board-disco-f469ni/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f469ni modm_board_disco_f469ni modm: board: disco-f469ni modm_architecture_clock modm: architecture: clock modm_board_disco_f469ni-&gt;modm_architecture_clock modm_architecture_memory modm: architecture: memory modm_board_disco_f469ni-&gt;modm_architecture_memory modm_debug modm: debug modm_board_disco_f469ni-&gt;modm_debug modm_driver_ft6x06 modm: driver: ft6x06 modm_board_disco_f469ni-&gt;modm_driver_ft6x06 modm_math_utils modm: math: utils modm_board_disco_f469ni-&gt;modm_math_utils modm_platform_clock modm: platform: clock modm_board_disco_f469ni-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f469ni-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f469ni-&gt;modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f469ni-&gt;modm_platform_i2c_1 modm_platform_rcc modm: platform: rcc modm_board_disco_f469ni-&gt;modm_platform_rcc modm_platform_uart_3 modm: platform: uart: 3 modm_board_disco_f469ni-&gt;modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f469ni-&gt;modm_platform_usb_fs modm_ui_display modm: ui: display modm_board_disco_f469ni-&gt;modm_ui_display </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f723ie/","title":"STM32F723E DISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f723ie</code></p> <p>Discovery kit for STM32F723E</p>"},{"location":"reference/module/modm-board-disco-f723ie/#tinyusb","title":"TinyUSB","text":"<p>This board has two USB ports: one with Full Speed support and another with true High Speed support. By default, TinyUSB runs the device classes on the FS port, however, you can reassign it to HS via this option:</p> <pre><code>&lt;options&gt;\n  &lt;option name=\"modm:tinyusb:config\"&gt;device.cdc,device.msc&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:device:port\"&gt;hs&lt;/option&gt;\n&lt;/options&gt;\n</code></pre> <p>Note that can use TinyUSB with both the device and host classes at the same time if you assign them to different ports:</p> <pre><code>```xml\n&lt;options&gt;\n  &lt;option name=\"modm:tinyusb:config\"&gt;device.cdc,device.msc&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:device:port\"&gt;fs&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:host:port\"&gt;hs&lt;/option&gt;\n&lt;/options&gt;\n</code></pre> <p>This module is only available for stm32f723iek6.</p>"},{"location":"reference/module/modm-board-disco-f723ie/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f723ie modm_board_disco_f723ie modm: board: disco-f723ie modm_architecture_clock modm: architecture: clock modm_board_disco_f723ie-&gt;modm_architecture_clock modm_debug modm: debug modm_board_disco_f723ie-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_disco_f723ie-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f723ie-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f723ie-&gt;modm_platform_gpio modm_platform_uart_6 modm: platform: uart: 6 modm_board_disco_f723ie-&gt;modm_platform_uart_6 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f723ie-&gt;modm_platform_usb_fs modm_platform_usb_hs modm: platform: usb: hs modm_board_disco_f723ie-&gt;modm_platform_usb_hs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f746ng/","title":"STM32F7DISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f746ng</code></p> <p>Discovery kit for STM32F746</p>"},{"location":"reference/module/modm-board-disco-f746ng/#tinyusb","title":"TinyUSB","text":"<p>This board has two USB ports: one with Full Speed support and another with true High Speed support. By default, TinyUSB runs the device classes on the FS port, however, you can reassign it to HS via this option:</p> <pre><code>&lt;options&gt;\n  &lt;option name=\"modm:tinyusb:config\"&gt;device.cdc,device.msc&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:device:port\"&gt;hs&lt;/option&gt;\n&lt;/options&gt;\n</code></pre> <p>Note that can use TinyUSB with both the device and host classes at the same time if you assign them to different ports:</p> <pre><code>&lt;options&gt;\n  &lt;option name=\"modm:tinyusb:config\"&gt;device.cdc,device.msc&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:device:port\"&gt;fs&lt;/option&gt;\n  &lt;option name=\"modm:tinyusb:host:port\"&gt;hs&lt;/option&gt;\n&lt;/options&gt;\n</code></pre> <p>This module is only available for stm32f746ngh6.</p>"},{"location":"reference/module/modm-board-disco-f746ng/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f746ng modm_board_disco_f746ng modm: board: disco-f746ng modm_architecture_clock modm: architecture: clock modm_board_disco_f746ng-&gt;modm_architecture_clock modm_debug modm: debug modm_board_disco_f746ng-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_disco_f746ng-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f746ng-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f746ng-&gt;modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_disco_f746ng-&gt;modm_platform_uart_1 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f746ng-&gt;modm_platform_usb_fs modm_platform_usb_hs modm: platform: usb: hs modm_board_disco_f746ng-&gt;modm_platform_usb_hs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-f769ni/","title":"STM32F769IDISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-f769ni</code></p> <p>Discovery kit for STM32F769 line</p> <p>This module is only available for stm32f769nih6.</p>"},{"location":"reference/module/modm-board-disco-f769ni/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-f769ni modm_board_disco_f769ni modm: board: disco-f769ni modm_architecture_clock modm: architecture: clock modm_board_disco_f769ni-&gt;modm_architecture_clock modm_debug modm: debug modm_board_disco_f769ni-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_disco_f769ni-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f769ni-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f769ni-&gt;modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_disco_f769ni-&gt;modm_platform_uart_1 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-l152rc/","title":"DISCO-L152RC","text":"<p>lbuild module: <code>modm:board:disco-l152rc</code></p> <p>Discovery kit for STM32L152RC</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32l152rct6.</p>"},{"location":"reference/module/modm-board-disco-l152rc/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-l152rc modm_board_disco_l152rc modm: board: disco-l152rc modm_debug modm: debug modm_board_disco_l152rc-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_disco_l152rc-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_l152rc-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_l152rc-&gt;modm_platform_gpio modm_platform_rtt modm: platform: rtt modm_board_disco_l152rc-&gt;modm_platform_rtt </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-disco-l476vg/","title":"STM32L476DISCOVERY","text":"<p>lbuild module: <code>modm:board:disco-l476vg</code></p> <p>Discovery kit for STM32L476</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32l476vgt6.</p>"},{"location":"reference/module/modm-board-disco-l476vg/#dependencies","title":"Dependencies","text":"<p> modm:board:disco-l476vg modm_board_disco_l476vg modm: board: disco-l476vg modm_debug modm: debug modm_board_disco_l476vg-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_disco_l476vg-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_l476vg-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_l476vg-&gt;modm_platform_gpio modm_platform_rtt modm: platform: rtt modm_board_disco_l476vg-&gt;modm_platform_rtt modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_l476vg-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-feather-m0/","title":"Adafruit Feather-M0","text":"<p>lbuild module: <code>modm:board:feather-m0</code></p> <p>At the Feather M0's heart is an ATSAMD21G18 ARM Cortex M0 processor, clocked at 48 MHz and at 3.3V logic, the same one used in the new Arduino Zero. This chip has a whopping 256K of FLASH (8x more than the Atmega328 or 32u4) and 32K of RAM (16x as much)! This chip comes with built in USB so it has USB-to-Serial program &amp; debug capability built in with no need for an FTDI-like chip.</p> <p>https://www.adafruit.com/product/2772</p> <p>This module is only available for samd1x/d2x/dax.</p>"},{"location":"reference/module/modm-board-feather-m0/#dependencies","title":"Dependencies","text":"<p> modm:board:feather-m0 modm_board_feather_m0 modm: board: feather-m0 modm_debug modm: debug modm_board_feather_m0-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_feather_m0-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_feather_m0-&gt;modm_platform_core modm_platform_gclk modm: platform: gclk modm_board_feather_m0-&gt;modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_board_feather_m0-&gt;modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_feather_m0-&gt;modm_platform_uart_0 modm_platform_usb modm: platform: usb modm_board_feather_m0-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-feather-m4/","title":"Adafruit Feather M4 Express","text":"<p>lbuild module: <code>modm:board:feather-m4</code></p> <p>The Feather M4 Express features an ATSAMD51J19 (a 120MHz Cortex M4 with floating point support, 512KB Flash and 192KB RAM), plus a number of extra peripherals for support.</p> <p>Main Product Page</p> <p>User Guide</p>"},{"location":"reference/module/modm-board-feather-m4/#board-details","title":"Board Details","text":""},{"location":"reference/module/modm-board-feather-m4/#pins-available","title":"Pins available","text":"<p>The Feather boards have dimensions of 51mm x 23mm for a fairly compact form factor. That does, however, limit the number of pins broken out on the board.</p> <p>Out of 51 GPIO pins on the SAMD51J19, only 22 have pads for the breakout headers. One of these, labeled AREF (PA03), is connected directly to 3.3V and thus cannot be used for IO. (This is due to a problem with the chip itself; the DAC will not function without this connection. If the DAC is not needed, the trace can be cut and the pin used as desired.)</p> <p>There are seven other pins not broken out but used for devices on-board: six are used for a 2MB QSPI Flash, and one for the 'Neopixel', Adafruit's name for a WS2812 RGB LED.</p> <p>Pins PA30-PA31 have pads on the underside of the board for the Serial Wire Debug Interface (SWCLK and SWDIO, respectively), allowing connection to a debug probe.</p> <p>The pinouts page in the User Guide has further information, photos, and a useful diagram showing the various pin functions. (This diagram does have some errors, however; the most noticeable being the labeling of several pins as outputs for TC6 &amp; TC7, Timer/Counters which are not present on the chip.)</p>"},{"location":"reference/module/modm-board-feather-m4/#board-labeling","title":"Board labeling","text":"<p>Most pins broken out on the board are labeled Arduino-style, with A0-A5 having 'analog' functions, and 0-13 (not all of which are available) for 'digital'. A few pins are labeled for specific functions, e.g. SPI, I2C, etc. All pins are aliased in 'board.hpp' to their GPIO equivalents; the 'digital' (0-13) pin aliases are prefixed with a 'D'.</p>"},{"location":"reference/module/modm-board-feather-m4/#clocks","title":"Clocks","text":"<p>Although the SAMD51 has pins available for crystal oscillators XOSC1 and XOSC2, there are no crystals installed on this board for their use. There is, however, a 32kHz crystal for the XOSC32K oscillator.</p> <p>Typically, an FDPLL is used as the system clock after bootup is complete; and using XOSC32K as a reference for it is not reliable. Even when using the workaround prescibed in Item 2.13 of the Errata, the result is usually failure.</p> <p>The simplest solution is to source a GCLK generator with the 48MHz DFLL, and use a division factor that creates a suitable reference frequency for the FDPLL (e.g. 1-2MHz). It can be done with the DFLL in open- or closed-loop mode, but in order to meet the USB timing specs, closed-loop with XOSC32K as reference is used here.</p>"},{"location":"reference/module/modm-board-feather-m4/#programming","title":"Programming","text":"<p>The Feather M4 has a UF2 bootloader. By using a utility to convert the '.elf' files (generated by scons or make) to '.uf2' files, it is then possible to copy the uf2 file directly to the board.</p> <p>In modm, the conversion utility is called 'elf2uf2.py' (in tools/modm_tools), and is incorporated into the build system. Use 'scons uf2' or 'make uf2' to create the uf2 file.</p> <p>Alternatively, the bootloader on the Feather is compatible with BOSSA; so another method is to use 'scons program-bossac' or 'make program-bossac' to load your program into flash.</p> <p>With either method, you must press the reset button twice to get the board into bootloader mode before flashing with BOSSA or UF2 copying. (In bootloader mode, a volume named FEATHERBOOT will be mounted; and that is where the UF2 file should be copied.)</p> <p>This module is only available for samd51j19a-au.</p>"},{"location":"reference/module/modm-board-feather-m4/#dependencies","title":"Dependencies","text":"<p> modm:board:feather-m4 modm_board_feather_m4 modm: board: feather-m4 modm_debug modm: debug modm_board_feather_m4-&gt;modm_debug modm_platform_core modm: platform: core modm_board_feather_m4-&gt;modm_platform_core modm_platform_gclk modm: platform: gclk modm_board_feather_m4-&gt;modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_board_feather_m4-&gt;modm_platform_gpio modm_platform_uart_5 modm: platform: uart: 5 modm_board_feather_m4-&gt;modm_platform_uart_5 modm_platform_usb modm: platform: usb modm_board_feather_m4-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-feather-rp2040/","title":"Adafruit Feather RP2040","text":"<p>lbuild module: <code>modm:board:feather-rp2040</code></p> <p>A board with RP2040 chip and 8MB of flash memory.</p> <p>https://www.adafruit.com/product/4884</p> <p>See <code>modm:rp-pico</code> for programming instructions.</p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-board-feather-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:board:feather-rp2040 modm_board_feather_rp2040 modm: board: feather-rp2040 modm_platform_clock modm: platform: clock modm_board_feather_rp2040-&gt;modm_platform_clock modm_platform_clockgen modm: platform: clockgen modm_board_feather_rp2040-&gt;modm_platform_clockgen modm_platform_core modm: platform: core modm_board_feather_rp2040-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_feather_rp2040-&gt;modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_feather_rp2040-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-mega-2560-pro/","title":"Mega 2560 PRO (Embed) CH340G","text":"<p>lbuild module: <code>modm:board:mega-2560-pro</code></p> <p>A compact breakout board similiar to the Arduino Mega 2560 board. You can order this for little money from well known Chinese online stores.</p> <p>See: https://robotdyn.com/mega-2560-pro-embed-ch340g-atmega2560-16au.html</p> <p>This module is only available for avrmega.</p>"},{"location":"reference/module/modm-board-mega-2560-pro/#dependencies","title":"Dependencies","text":"<p> modm:board:mega-2560-pro modm_board_mega_2560_pro modm: board: mega-2560-pro modm_architecture_clock modm: architecture: clock modm_board_mega_2560_pro-&gt;modm_architecture_clock modm_architecture_interrupt modm: architecture: interrupt modm_board_mega_2560_pro-&gt;modm_architecture_interrupt modm_debug modm: debug modm_board_mega_2560_pro-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_mega_2560_pro-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_mega_2560_pro-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_mega_2560_pro-&gt;modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_mega_2560_pro-&gt;modm_platform_uart_0 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-c031c6/","title":"NUCLEO-C031C6","text":"<p>lbuild module: <code>modm:board:nucleo-c031c6</code></p> <p>Nucleo kit for STM32C031C6</p> <p>This module is only available for stm32c031c6t6.</p>"},{"location":"reference/module/modm-board-nucleo-c031c6/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-c031c6 modm_board_nucleo_c031c6 modm: board: nucleo-c031c6 modm_architecture_clock modm: architecture: clock modm_board_nucleo_c031c6-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_c031c6-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_c031c6-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_c031c6-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_c031c6-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_c031c6-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f031k6/","title":"NUCLEO-F031K6","text":"<p>lbuild module: <code>modm:board:nucleo-f031k6</code></p> <p>Nucleo kit for STM32F031K6</p> <p>This module is only available for stm32f031k6t6.</p>"},{"location":"reference/module/modm-board-nucleo-f031k6/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f031k6 modm_board_nucleo_f031k6 modm: board: nucleo-f031k6 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f031k6-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f031k6-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f031k6-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f031k6-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f031k6-&gt;modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_nucleo_f031k6-&gt;modm_platform_uart_1 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f042k6/","title":"NUCLEO-F042K6","text":"<p>lbuild module: <code>modm:board:nucleo-f042k6</code></p> <p>Nucleo kit for STM32F042K6</p> <p>This module is only available for stm32f042k6t6.</p>"},{"location":"reference/module/modm-board-nucleo-f042k6/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f042k6 modm_board_nucleo_f042k6 modm: board: nucleo-f042k6 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f042k6-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f042k6-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f042k6-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f042k6-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f042k6-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f042k6-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f072rb/","title":"NUCLEO-F072RB","text":"<p>lbuild module: <code>modm:board:nucleo-f072rb</code></p> <p>Nucleo kit for STM32F072RB</p> <p>This module is only available for stm32f072rbt6.</p>"},{"location":"reference/module/modm-board-nucleo-f072rb/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f072rb modm_board_nucleo_f072rb modm: board: nucleo-f072rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_f072rb-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f072rb-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f072rb-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f072rb-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f072rb-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f072rb-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f091rc/","title":"NUCLEO-F091RC","text":"<p>lbuild module: <code>modm:board:nucleo-f091rc</code></p> <p>Nucleo kit for STM32F091RC</p> <p>This module is only available for stm32f091rct6.</p>"},{"location":"reference/module/modm-board-nucleo-f091rc/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f091rc modm_board_nucleo_f091rc modm: board: nucleo-f091rc modm_architecture_clock modm: architecture: clock modm_board_nucleo_f091rc-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f091rc-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f091rc-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f091rc-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f091rc-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f091rc-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f103rb/","title":"NUCLEO-F103RB","text":"<p>lbuild module: <code>modm:board:nucleo-f103rb</code></p> <p>Nucleo kit for STM32F103RB</p> <p>This module is only available for stm32f103rbt6.</p>"},{"location":"reference/module/modm-board-nucleo-f103rb/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f103rb modm_board_nucleo_f103rb modm: board: nucleo-f103rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_f103rb-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f103rb-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f103rb-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f103rb-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f103rb-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f103rb-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f303k8/","title":"NUCLEO-F303K8","text":"<p>lbuild module: <code>modm:board:nucleo-f303k8</code></p> <p>Nucleo kit for STM32F303K8</p> <p>This module is only available for stm32f303k8t6.</p>"},{"location":"reference/module/modm-board-nucleo-f303k8/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f303k8 modm_board_nucleo_f303k8 modm: board: nucleo-f303k8 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f303k8-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f303k8-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f303k8-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f303k8-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f303k8-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f303k8-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f303re/","title":"NUCLEO-F303RE","text":"<p>lbuild module: <code>modm:board:nucleo-f303re</code></p> <p>Nucleo kit for STM32F303RE</p> <p>This module is only available for stm32f303ret6.</p>"},{"location":"reference/module/modm-board-nucleo-f303re/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f303re modm_board_nucleo_f303re modm: board: nucleo-f303re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f303re-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f303re-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f303re-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f303re-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f303re-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f303re-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f334r8/","title":"NUCLEO-F334R8","text":"<p>lbuild module: <code>modm:board:nucleo-f334r8</code></p> <p>Nucleo kit for STM32F334R8</p> <p>This module is only available for stm32f334r8t6.</p>"},{"location":"reference/module/modm-board-nucleo-f334r8/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f334r8 modm_board_nucleo_f334r8 modm: board: nucleo-f334r8 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f334r8-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f334r8-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f334r8-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f334r8-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f334r8-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f334r8-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f401re/","title":"NUCLEO-F401RE","text":"<p>lbuild module: <code>modm:board:nucleo-f401re</code></p> <p>Nucleo kit for STM32F401RE</p> <p>This module is only available for stm32f401ret6.</p>"},{"location":"reference/module/modm-board-nucleo-f401re/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f401re modm_board_nucleo_f401re modm: board: nucleo-f401re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f401re-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f401re-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f401re-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f401re-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f401re-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f401re-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f411re/","title":"NUCLEO-F411RE","text":"<p>lbuild module: <code>modm:board:nucleo-f411re</code></p> <p>Nucleo kit for STM32F411RE</p> <p>This module is only available for stm32f411ret6.</p>"},{"location":"reference/module/modm-board-nucleo-f411re/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f411re modm_board_nucleo_f411re modm: board: nucleo-f411re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f411re-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f411re-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f411re-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f411re-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f411re-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f411re-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f429zi/","title":"NUCLEO-F429ZI","text":"<p>lbuild module: <code>modm:board:nucleo-f429zi</code></p> <p>Nucleo kit for STM32F429ZI</p> <p>This module is only available for stm32f429zit6.</p>"},{"location":"reference/module/modm-board-nucleo-f429zi/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f429zi modm_board_nucleo_f429zi modm: board: nucleo-f429zi modm_architecture_clock modm: architecture: clock modm_board_nucleo_f429zi-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f429zi-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f429zi-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f429zi-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f429zi-&gt;modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f429zi-&gt;modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_f429zi-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f439zi/","title":"NUCLEO-F439ZI","text":"<p>lbuild module: <code>modm:board:nucleo-f439zi</code></p> <p>Nucleo kit for STM32F439ZI</p> <p>This module is only available for stm32f439zit6.</p>"},{"location":"reference/module/modm-board-nucleo-f439zi/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f439zi modm_board_nucleo_f439zi modm: board: nucleo-f439zi modm_architecture_clock modm: architecture: clock modm_board_nucleo_f439zi-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f439zi-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f439zi-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f439zi-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f439zi-&gt;modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f439zi-&gt;modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_f439zi-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f446re/","title":"NUCLEO-F446RE","text":"<p>lbuild module: <code>modm:board:nucleo-f446re</code></p> <p>Nucleo kit for STM32F446RE</p> <p>This module is only available for stm32f446ret6.</p>"},{"location":"reference/module/modm-board-nucleo-f446re/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f446re modm_board_nucleo_f446re modm: board: nucleo-f446re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f446re-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f446re-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f446re-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f446re-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f446re-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f446re-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f446ze/","title":"NUCLEO-F446ZE","text":"<p>lbuild module: <code>modm:board:nucleo-f446ze</code></p> <p>Nucleo kit for STM32F446ZE</p> <p>This module is only available for stm32f446zet6.</p>"},{"location":"reference/module/modm-board-nucleo-f446ze/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f446ze modm_board_nucleo_f446ze modm: board: nucleo-f446ze modm_architecture_clock modm: architecture: clock modm_board_nucleo_f446ze-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f446ze-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f446ze-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f446ze-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f446ze-&gt;modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f446ze-&gt;modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_f446ze-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f746zg/","title":"NUCLEO-F746ZG","text":"<p>lbuild module: <code>modm:board:nucleo-f746zg</code></p> <p>Nucleo kit for STM32F746ZG</p> <p>This module is only available for stm32f746zgt6.</p>"},{"location":"reference/module/modm-board-nucleo-f746zg/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f746zg modm_board_nucleo_f746zg modm: board: nucleo-f746zg modm_architecture_clock modm: architecture: clock modm_board_nucleo_f746zg-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f746zg-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f746zg-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f746zg-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f746zg-&gt;modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f746zg-&gt;modm_platform_uart_3 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-f767zi/","title":"NUCLEO-F767ZI","text":"<p>lbuild module: <code>modm:board:nucleo-f767zi</code></p> <p>Nucleo kit for STM32F767ZI</p> <p>This module is only available for stm32f767zit6.</p>"},{"location":"reference/module/modm-board-nucleo-f767zi/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-f767zi modm_board_nucleo_f767zi modm: board: nucleo-f767zi modm_architecture_clock modm: architecture: clock modm_board_nucleo_f767zi-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f767zi-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f767zi-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f767zi-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f767zi-&gt;modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f767zi-&gt;modm_platform_uart_3 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-g070rb/","title":"NUCLEO-G070RB","text":"<p>lbuild module: <code>modm:board:nucleo-g070rb</code></p> <p>Nucleo kit for STM32G070RB</p> <p>This module is only available for stm32g070rbt6.</p>"},{"location":"reference/module/modm-board-nucleo-g070rb/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-g070rb modm_board_nucleo_g070rb modm: board: nucleo-g070rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_g070rb-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g070rb-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g070rb-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g070rb-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g070rb-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g070rb-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-g071rb/","title":"NUCLEO-G071RB","text":"<p>lbuild module: <code>modm:board:nucleo-g071rb</code></p> <p>Nucleo kit for STM32G071RB</p> <p>This module is only available for stm32g071rbt6.</p>"},{"location":"reference/module/modm-board-nucleo-g071rb/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-g071rb modm_board_nucleo_g071rb modm: board: nucleo-g071rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_g071rb-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g071rb-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g071rb-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g071rb-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g071rb-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g071rb-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-g431kb/","title":"NUCLEO-G431KB","text":"<p>lbuild module: <code>modm:board:nucleo-g431kb</code></p> <p>Nucleo kit for STM32G431KB</p> <p>This module is only available for stm32g431kbt6.</p>"},{"location":"reference/module/modm-board-nucleo-g431kb/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-g431kb modm_board_nucleo_g431kb modm: board: nucleo-g431kb modm_architecture_clock modm: architecture: clock modm_board_nucleo_g431kb-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g431kb-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g431kb-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g431kb-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g431kb-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g431kb-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-g431rb/","title":"NUCLEO-G431RB","text":"<p>lbuild module: <code>modm:board:nucleo-g431rb</code></p> <p>Nucleo kit for STM32G474RE</p> <p>This module is only available for stm32g4.</p>"},{"location":"reference/module/modm-board-nucleo-g431rb/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-g431rb modm_board_nucleo_g431rb modm: board: nucleo-g431rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_g431rb-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g431rb-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g431rb-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g431rb-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g431rb-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g431rb-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-g474re/","title":"NUCLEO-G474RE","text":"<p>lbuild module: <code>modm:board:nucleo-g474re</code></p> <p>Nucleo kit for STM32G474RE</p> <p>This module is only available for stm32g474ret6.</p>"},{"location":"reference/module/modm-board-nucleo-g474re/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-g474re modm_board_nucleo_g474re modm: board: nucleo-g474re modm_architecture_clock modm: architecture: clock modm_board_nucleo_g474re-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g474re-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g474re-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g474re-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g474re-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g474re-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-h723zg/","title":"NUCLEO-H723ZG","text":"<p>lbuild module: <code>modm:board:nucleo-h723zg</code></p> <p>Nucleo kit for STM32H723ZG</p>"},{"location":"reference/module/modm-board-nucleo-h723zg/#tinyusb","title":"TinyUSB","text":"<p>To use the USB port, you must configure TinyUSB to use the HS port in FS mode:</p> <pre><code>&lt;option name=\"modm:tinyusb:max-speed\"&gt;full&lt;/option&gt;\n</code></pre> <p>This module is only available for stm32h723zgt6.</p>"},{"location":"reference/module/modm-board-nucleo-h723zg/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-h723zg modm_board_nucleo_h723zg modm: board: nucleo-h723zg modm_architecture_clock modm: architecture: clock modm_board_nucleo_h723zg-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_h723zg-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_h723zg-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_h723zg-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_h723zg-&gt;modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_h723zg-&gt;modm_platform_uart_3 modm_platform_usb_hs modm: platform: usb: hs modm_board_nucleo_h723zg-&gt;modm_platform_usb_hs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-h743zi/","title":"NUCLEO-H743ZI","text":"<p>lbuild module: <code>modm:board:nucleo-h743zi</code></p> <p>Nucleo kit for STM32H743ZI</p> <p>Please note that this BSP uses the Y revision of the STM32H743, which limits the main clock frequency to \u2264400MHz and applies an errata bug fix to the SysTick, whose reference clock cannot be divided by 8.</p> <p>See the STM32H743 errata sheet.</p> <p>In case you are using the new revision V of STM32H743, you can overwrite the target option in your <code>project.xml</code>:</p> <pre><code>&lt;library&gt;\n  &lt;extends&gt;modm:nucleo-h743zi&lt;/extends&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:target\"&gt;stm32h743zit6/revV&lt;/option&gt;\n  &lt;/options&gt;\n&lt;/library&gt;\n</code></pre> <p>This module is only available for stm32h743zit6.</p>"},{"location":"reference/module/modm-board-nucleo-h743zi/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-h743zi modm_board_nucleo_h743zi modm: board: nucleo-h743zi modm_architecture_clock modm: architecture: clock modm_board_nucleo_h743zi-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_h743zi-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_h743zi-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_h743zi-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_h743zi-&gt;modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_h743zi-&gt;modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_h743zi-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-l031k6/","title":"NUCLEO-L031K6","text":"<p>lbuild module: <code>modm:board:nucleo-l031k6</code></p> <p>Nucleo kit for STM32L031K6</p> <p>This module is only available for stm32l031k6t6.</p>"},{"location":"reference/module/modm-board-nucleo-l031k6/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-l031k6 modm_board_nucleo_l031k6 modm: board: nucleo-l031k6 modm_architecture_clock modm: architecture: clock modm_board_nucleo_l031k6-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l031k6-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l031k6-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l031k6-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l031k6-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l031k6-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-l053r8/","title":"NUCLEO-L053R8","text":"<p>lbuild module: <code>modm:board:nucleo-l053r8</code></p> <p>Nucleo kit for STM32L053R8</p> <p>This module is only available for stm32l053r8t6.</p>"},{"location":"reference/module/modm-board-nucleo-l053r8/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-l053r8 modm_board_nucleo_l053r8 modm: board: nucleo-l053r8 modm_architecture_clock modm: architecture: clock modm_board_nucleo_l053r8-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l053r8-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l053r8-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l053r8-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l053r8-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l053r8-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-l152re/","title":"NUCLEO-L152RE","text":"<p>lbuild module: <code>modm:board:nucleo-l152re</code></p> <p>Nucleo kit for STM32L152RE</p> <p>This module is only available for stm32l152ret6.</p>"},{"location":"reference/module/modm-board-nucleo-l152re/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-l152re modm_board_nucleo_l152re modm: board: nucleo-l152re modm_architecture_clock modm: architecture: clock modm_board_nucleo_l152re-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l152re-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l152re-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l152re-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l152re-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l152re-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-l432kc/","title":"NUCLEO-L432KC","text":"<p>lbuild module: <code>modm:board:nucleo-l432kc</code></p> <p>Nucleo kit for STM32L432KC</p> <p>This module is only available for stm32l432kcu6.</p>"},{"location":"reference/module/modm-board-nucleo-l432kc/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-l432kc modm_board_nucleo_l432kc modm: board: nucleo-l432kc modm_architecture_clock modm: architecture: clock modm_board_nucleo_l432kc-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l432kc-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l432kc-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l432kc-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l432kc-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l432kc-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-l452re/","title":"NUCLEO-L452RE","text":"<p>lbuild module: <code>modm:board:nucleo-l452re</code></p> <p>Nucleo kit for STM32L452RE</p> <p>This module is only available for stm32l4.</p>"},{"location":"reference/module/modm-board-nucleo-l452re/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-l452re modm_board_nucleo_l452re modm: board: nucleo-l452re modm_architecture_clock modm: architecture: clock modm_board_nucleo_l452re-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l452re-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l452re-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l452re-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l452re-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l452re-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-l476rg/","title":"NUCLEO-L476RG","text":"<p>lbuild module: <code>modm:board:nucleo-l476rg</code></p> <p>Nucleo kit for STM32L476RG</p> <p>This module is only available for stm32l476rgt6.</p>"},{"location":"reference/module/modm-board-nucleo-l476rg/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-l476rg modm_board_nucleo_l476rg modm: board: nucleo-l476rg modm_architecture_clock modm: architecture: clock modm_board_nucleo_l476rg-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l476rg-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l476rg-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l476rg-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l476rg-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l476rg-&gt;modm_platform_uart_2 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-l496zg-p/","title":"NUCLEO-L496ZG-P","text":"<p>lbuild module: <code>modm:board:nucleo-l496zg-p</code></p> <p>Nucleo kit for STM32L496ZG-P</p> <p>This module is only available for stm32l496zgt6p.</p>"},{"location":"reference/module/modm-board-nucleo-l496zg-p/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-l496zg-p modm_board_nucleo_l496zg_p modm: board: nucleo-l496zg-p modm_architecture_clock modm: architecture: clock modm_board_nucleo_l496zg_p-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l496zg_p-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l496zg_p-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l496zg_p-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l496zg_p-&gt;modm_platform_gpio modm_platform_uart_lpuart1 modm: platform: uart: lpuart1 modm_board_nucleo_l496zg_p-&gt;modm_platform_uart_lpuart1 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_l496zg_p-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-l552ze-q/","title":"NUCLEO-L552ZE-Q","text":"<p>lbuild module: <code>modm:board:nucleo-l552ze-q</code></p> <p>Nucleo kit for STM32L552ZE-Q</p> <p>This module is only available for stm32l552zet6q.</p>"},{"location":"reference/module/modm-board-nucleo-l552ze-q/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-l552ze-q modm_board_nucleo_l552ze_q modm: board: nucleo-l552ze-q modm_architecture_clock modm: architecture: clock modm_board_nucleo_l552ze_q-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l552ze_q-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l552ze_q-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l552ze_q-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l552ze_q-&gt;modm_platform_gpio modm_platform_uart_lpuart1 modm: platform: uart: lpuart1 modm_board_nucleo_l552ze_q-&gt;modm_platform_uart_lpuart1 modm_platform_usb modm: platform: usb modm_board_nucleo_l552ze_q-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-nucleo-u575zi-q/","title":"NUCLEO-U575ZI-Q","text":"<p>lbuild module: <code>modm:board:nucleo-u575zi-q</code></p> <p>Nucleo kit for STM32U575ZI-Q</p> <p>This module is only available for stm32u575zit6q.</p>"},{"location":"reference/module/modm-board-nucleo-u575zi-q/#dependencies","title":"Dependencies","text":"<p> modm:board:nucleo-u575zi-q modm_board_nucleo_u575zi_q modm: board: nucleo-u575zi-q modm_architecture_clock modm: architecture: clock modm_board_nucleo_u575zi_q-&gt;modm_architecture_clock modm_debug modm: debug modm_board_nucleo_u575zi_q-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_u575zi_q-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_u575zi_q-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_u575zi_q-&gt;modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_nucleo_u575zi_q-&gt;modm_platform_uart_1 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_u575zi_q-&gt;modm_platform_usb_fs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-olimexino-stm32/","title":"Olimexino STM32","text":"<p>lbuild module: <code>modm:board:olimexino-stm32</code></p> <p>Modified Maple board with STM32F103RBT6: https://www.olimex.com/Products/Duino/STM32/OLIMEXINO-STM32/open-source-hardware</p> <p>This module is only available for stm32f103rbt6.</p>"},{"location":"reference/module/modm-board-olimexino-stm32/#dependencies","title":"Dependencies","text":"<p> modm:board:olimexino-stm32 modm_board_olimexino_stm32 modm: board: olimexino-stm32 modm_architecture_clock modm: architecture: clock modm_board_olimexino_stm32-&gt;modm_architecture_clock modm_debug modm: debug modm_board_olimexino_stm32-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_olimexino_stm32-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_olimexino_stm32-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_olimexino_stm32-&gt;modm_platform_gpio modm_platform_spi_2 modm: platform: spi: 2 modm_board_olimexino_stm32-&gt;modm_platform_spi_2 modm_platform_uart_1 modm: platform: uart: 1 modm_board_olimexino_stm32-&gt;modm_platform_uart_1 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-rp-pico/","title":"Raspberry Pi Pico","text":"<p>lbuild module: <code>modm:board:rp-pico</code></p> <p>RP2040 Official System Development Board See https://www.raspberrypi.com/products/raspberry-pi-pico</p>"},{"location":"reference/module/modm-board-rp-pico/#programming","title":"Programming","text":""},{"location":"reference/module/modm-board-rp-pico/#uf2","title":"UF2","text":"<p>The RP2040 ships with a UF2 bootloader in ROM.</p> <p>To upload your application, connect the RP2040 via USB, convert the ELF to UF2 format by calling <code>scons uf2</code> or <code>make uf2</code> and copy the generated <code>.uf2</code> file to the mounted virtual disk.</p>"},{"location":"reference/module/modm-board-rp-pico/#openocd","title":"OpenOCD","text":"<p>Another option is to use Picoprobe and custom version of OpenOCD provided by RPi.</p> <p>You would need to build and program one of the boards with the Picoprobe firmware, configure and build RPi OpenOCD, and connect the boards via SWD. The wiring diagram and detailed description is available in the Pico Documentation.</p> <p>The how-to shows steps for building and installing the RPi OpenOCD into your system globally, however, if you still want to be able to work with other OpenOCD binaries, you should only install it locally:</p> <pre><code>sudo apt install automake autoconf build-essential texinfo libtool libftdi-dev libusb-1.0-0-dev\n\ncd ~/pico\ngit clone https://github.com/raspberrypi/openocd.git --branch rp2040 --depth=1 --no-single-branch\n\ncd openocd\n./bootstrap\n\nmkdir build\ncd build\n../configure --enable-picoprobe --prefix=$(realpath ../install)\n\nmake -j4\nmake install\n</code></pre> <p>Additional steps are needed to get access to the device from a non-privileged user on Linux. Edit or create the <code>/etc/udev/rules.d/60-openocd.rules</code> file and append these lines to it:</p> <pre><code># Raspberry Pi Picoprobe\nATTRS{idVendor}==\"2e8a\", ATTRS{idProduct}==\"0004\", MODE=\"660\", GROUP=\"plugdev\", TAG+=\"uaccess\"\n</code></pre> <p>Once you have both of your Pico boards connected according to the wiring diagram, you can run <code>scons program</code> to program the dev board:</p> <pre><code>export MODM_OPENOCD_BINARY=$HOME/pico/openocd/install/bin/openocd\nscons program\n</code></pre> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-board-rp-pico/#dependencies","title":"Dependencies","text":"<p> modm:board:rp-pico modm_board_rp_pico modm: board: rp-pico modm_platform_clock modm: platform: clock modm_board_rp_pico-&gt;modm_platform_clock modm_platform_clockgen modm: platform: clockgen modm_board_rp_pico-&gt;modm_platform_clockgen modm_platform_core modm: platform: core modm_board_rp_pico-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_rp_pico-&gt;modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_rp_pico-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-samd21-mini/","title":"RobotDyn SAMD21 M0 MINI","text":"<p>lbuild module: <code>modm:board:samd21-mini</code></p> <p>The SAMD21 MINI board is a small breakout board for the ATSAMD21G18 ARM Cortex-M0 processor, clocked at 48 MHz and at 3.3V logic.</p> <p>See: https://robotdyn.com/samd21-m0-mini.html</p> <p>It can be bought for little cost from well known Chinese online stores.</p> <p>This module is only available for samd1x/d2x/dax.</p>"},{"location":"reference/module/modm-board-samd21-mini/#dependencies","title":"Dependencies","text":"<p> modm:board:samd21-mini modm_board_samd21_mini modm: board: samd21-mini modm_platform_clock modm: platform: clock modm_board_samd21_mini-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_samd21_mini-&gt;modm_platform_core modm_platform_gclk modm: platform: gclk modm_board_samd21_mini-&gt;modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_board_samd21_mini-&gt;modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_samd21_mini-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-samd21-xplained-pro/","title":"Microchip SAMD21 Xplained Pro","text":"<p>lbuild module: <code>modm:board:samd21-xplained-pro</code></p> <p>This module is only available for samd21j18a-au.</p>"},{"location":"reference/module/modm-board-samd21-xplained-pro/#dependencies","title":"Dependencies","text":"<p> modm:board:samd21-xplained-pro modm_board_samd21_xplained_pro modm: board: samd21-xplained-pro modm_debug modm: debug modm_board_samd21_xplained_pro-&gt;modm_debug modm_platform_core modm: platform: core modm_board_samd21_xplained_pro-&gt;modm_platform_core modm_platform_gclk modm: platform: gclk modm_board_samd21_xplained_pro-&gt;modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_board_samd21_xplained_pro-&gt;modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_samd21_xplained_pro-&gt;modm_platform_uart_3 modm_platform_usb modm: platform: usb modm_board_samd21_xplained_pro-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-same54-xplained-pro/","title":"Microchip SAME54 Xplained Pro","text":"<p>lbuild module: <code>modm:board:same54-xplained-pro</code></p> <p>This module is only available for same54p20a-au.</p>"},{"location":"reference/module/modm-board-same54-xplained-pro/#dependencies","title":"Dependencies","text":"<p> modm:board:same54-xplained-pro modm_board_same54_xplained_pro modm: board: same54-xplained-pro modm_debug modm: debug modm_board_same54_xplained_pro-&gt;modm_debug modm_platform_core modm: platform: core modm_board_same54_xplained_pro-&gt;modm_platform_core modm_platform_gclk modm: platform: gclk modm_board_same54_xplained_pro-&gt;modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_board_same54_xplained_pro-&gt;modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_same54_xplained_pro-&gt;modm_platform_uart_2 modm_platform_usb modm: platform: usb modm_board_same54_xplained_pro-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-same70-xplained/","title":"Microchip SAME70 Xplained","text":"<p>lbuild module: <code>modm:board:same70-xplained</code></p> <p>This module is only available for same70q21a-an.</p>"},{"location":"reference/module/modm-board-same70-xplained/#dependencies","title":"Dependencies","text":"<p> modm:board:same70-xplained modm_board_same70_xplained modm: board: same70-xplained modm_debug modm: debug modm_board_same70_xplained-&gt;modm_debug modm_platform_clockgen modm: platform: clockgen modm_board_same70_xplained-&gt;modm_platform_clockgen modm_platform_core modm: platform: core modm_board_same70_xplained-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_same70_xplained-&gt;modm_platform_gpio modm_platform_usart_1 modm: platform: usart: 1 modm_board_same70_xplained-&gt;modm_platform_usart_1 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-samg55-xplained-pro/","title":"Microchip SAMG55 Xplained Pro","text":"<p>lbuild module: <code>modm:board:samg55-xplained-pro</code></p> <p>This module is only available for samg55j19a-au.</p>"},{"location":"reference/module/modm-board-samg55-xplained-pro/#dependencies","title":"Dependencies","text":"<p> modm:board:samg55-xplained-pro modm_board_samg55_xplained_pro modm: board: samg55-xplained-pro modm_debug modm: debug modm_board_samg55_xplained_pro-&gt;modm_debug modm_platform_clockgen modm: platform: clockgen modm_board_samg55_xplained_pro-&gt;modm_platform_clockgen modm_platform_core modm: platform: core modm_board_samg55_xplained_pro-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_samg55_xplained_pro-&gt;modm_platform_gpio modm_platform_usart_7 modm: platform: usart: 7 modm_board_samg55_xplained_pro-&gt;modm_platform_usart_7 modm_platform_usb modm: platform: usb modm_board_samg55_xplained_pro-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-samv71-xplained-ultra/","title":"Microchip SAMV71 Xplained Ultra","text":"<p>lbuild module: <code>modm:board:samv71-xplained-ultra</code></p> <p>This module is only available for samv71q21b-aab.</p>"},{"location":"reference/module/modm-board-samv71-xplained-ultra/#dependencies","title":"Dependencies","text":"<p> modm:board:samv71-xplained-ultra modm_board_samv71_xplained_ultra modm: board: samv71-xplained-ultra modm_debug modm: debug modm_board_samv71_xplained_ultra-&gt;modm_debug modm_platform_can_1 modm: platform: can: 1 modm_board_samv71_xplained_ultra-&gt;modm_platform_can_1 modm_platform_clockgen modm: platform: clockgen modm_board_samv71_xplained_ultra-&gt;modm_platform_clockgen modm_platform_core modm: platform: core modm_board_samv71_xplained_ultra-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_samv71_xplained_ultra-&gt;modm_platform_gpio modm_platform_i2c_0 modm: platform: i2c: 0 modm_board_samv71_xplained_ultra-&gt;modm_platform_i2c_0 modm_platform_usart_1 modm: platform: usart: 1 modm_board_samv71_xplained_ultra-&gt;modm_platform_usart_1 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-srxe/","title":"Smart Response XE","text":"<p>lbuild module: <code>modm:board:srxe</code></p> <p>Smart Response XE is an obsolete classroom clicker, sold for as little as 5 USD on well known online auction site. It's a compelling platform that's fully reverse engineered and ready to hack out of box, featuring:</p> <ul> <li>ATmega128RFA1 MCU</li> <li>384x136 LCD display</li> <li>QWERTY keyboard</li> <li>External 1MB SPI flash</li> <li>Exposed ISP and JTAG headers</li> <li>ZigBee transciever with antennas</li> <li>Powered by 4 AAA batteries</li> <li>Optional (unpopulated):</li> <li>RS232</li> <li>Debug LED</li> <li>Buzzer</li> <li>Accelerometer</li> </ul> <p>This module is only available for avrmega.</p>"},{"location":"reference/module/modm-board-srxe/#dependencies","title":"Dependencies","text":"<p> modm:board:srxe modm_board_srxe modm: board: srxe modm_debug modm: debug modm_board_srxe-&gt;modm_debug modm_driver_st7586s modm: driver: st7586s modm_board_srxe-&gt;modm_driver_st7586s modm_platform_clock modm: platform: clock modm_board_srxe-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_srxe-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_srxe-&gt;modm_platform_gpio modm_platform_spi modm: platform: spi modm_board_srxe-&gt;modm_platform_spi modm_platform_uart_0 modm: platform: uart: 0 modm_board_srxe-&gt;modm_platform_uart_0 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-stm32_f4ve/","title":"STM32_F4VE","text":"<p>lbuild module: <code>modm:board:stm32_f4ve</code></p> <p>https://stm32-base.org/boards/STM32F407VET6-STM32-F4VE-V2.0.html</p> <p>This module is only available for stm32f407vet6.</p>"},{"location":"reference/module/modm-board-stm32_f4ve/#dependencies","title":"Dependencies","text":"<p> modm:board:stm32_f4ve modm_board_stm32_f4ve modm: board: stm32_f4ve modm_architecture_clock modm: architecture: clock modm_board_stm32_f4ve-&gt;modm_architecture_clock modm_debug modm: debug modm_board_stm32_f4ve-&gt;modm_debug modm_driver_ads7843 modm: driver: ads7843 modm_board_stm32_f4ve-&gt;modm_driver_ads7843 modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_board_stm32_f4ve-&gt;modm_driver_block_device_spi_flash modm_platform_clock modm: platform: clock modm_board_stm32_f4ve-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_stm32_f4ve-&gt;modm_platform_core modm_platform_fsmc modm: platform: fsmc modm_board_stm32_f4ve-&gt;modm_platform_fsmc modm_platform_gpio modm: platform: gpio modm_board_stm32_f4ve-&gt;modm_platform_gpio modm_platform_spi_1 modm: platform: spi: 1 modm_board_stm32_f4ve-&gt;modm_platform_spi_1 modm_platform_spi_2 modm: platform: spi: 2 modm_board_stm32_f4ve-&gt;modm_platform_spi_2 modm_platform_uart_1 modm: platform: uart: 1 modm_board_stm32_f4ve-&gt;modm_platform_uart_1 </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-stm32f030_demo/","title":"STM32F030 Demo Board","text":"<p>lbuild module: <code>modm:board:stm32f030_demo</code></p> <p>STM32F030F4P6 Minimum System Development Board.</p> <p>Cheap and bread-board-friendly board for STM32 F0 series. https://stm32-base.org/boards/STM32F030F4P6-STM32F030-DEMO-BOARD-V1.1</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32f030f4p6.</p>"},{"location":"reference/module/modm-board-stm32f030_demo/#dependencies","title":"Dependencies","text":"<p> modm:board:stm32f030_demo modm_board_stm32f030_demo modm: board: stm32f030_demo modm_architecture_clock modm: architecture: clock modm_board_stm32f030_demo-&gt;modm_architecture_clock modm_debug modm: debug modm_board_stm32f030_demo-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_stm32f030_demo-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_stm32f030_demo-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_stm32f030_demo-&gt;modm_platform_gpio modm_platform_rtt modm: platform: rtt modm_board_stm32f030_demo-&gt;modm_platform_rtt </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-thingplus-rp2040/","title":"SparkFun Thing Plus - RP2040","text":"<p>lbuild module: <code>modm:board:thingplus-rp2040</code></p> <p>The SparkFun Thing Plus - RP2040 is a low-cost, high performance board with flexible digital interfaces featuring the Raspberry Pi Foundation's RP2040 microcontroller. Besides the Thing Plus or Feather footprint (with 18 GPIO pins), the board also includes an SD card slot, 16MB (128Mbit) flash memory, a JST single cell battery connector (with a charging circuit and fuel gauge sensor), an addressable WS2812 RGB LED, JTAG PTH pins, four (4-40 screw) mounting holes, and SparkFun's Qwiic connector.</p> <p>https://www.sparkfun.com/products/17745</p> <p>See <code>modm:rp-pico</code> for programming instructions.</p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-board-thingplus-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:board:thingplus-rp2040 modm_board_thingplus_rp2040 modm: board: thingplus-rp2040 modm_platform_clock modm: platform: clock modm_board_thingplus_rp2040-&gt;modm_platform_clock modm_platform_clockgen modm: platform: clockgen modm_board_thingplus_rp2040-&gt;modm_platform_clockgen modm_platform_core modm: platform: core modm_board_thingplus_rp2040-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_thingplus_rp2040-&gt;modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_thingplus_rp2040-&gt;modm_platform_usb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board-weact-c011f6/","title":"WeAct Studio STM32C011F6 Core Board","text":"<p>lbuild module: <code>modm:board:weact-c011f6</code></p> <p>Documentation</p> <p>This board has no serial port and logs via RTT instead.</p> <p>This module is only available for stm32c011f6p6.</p>"},{"location":"reference/module/modm-board-weact-c011f6/#dependencies","title":"Dependencies","text":"<p> modm:board:weact-c011f6 modm_board_weact_c011f6 modm: board: weact-c011f6 modm_architecture_clock modm: architecture: clock modm_board_weact_c011f6-&gt;modm_architecture_clock modm_debug modm: debug modm_board_weact_c011f6-&gt;modm_debug modm_platform_clock modm: platform: clock modm_board_weact_c011f6-&gt;modm_platform_clock modm_platform_core modm: platform: core modm_board_weact_c011f6-&gt;modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_weact_c011f6-&gt;modm_platform_gpio modm_platform_rtt modm: platform: rtt modm_board_weact_c011f6-&gt;modm_platform_rtt </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-board/","title":"Board Support Packages","text":"<p>lbuild module: <code>modm:board</code></p> <p>modm provides pre-configured BSPs for several commercial off-the-shelf development boards. There are two main components to the BPSs:</p> <ol> <li>An inheritable configuration <code>board.xml</code> containing the HAL target, options    and the board module. This pre-defined configuration is aliased as a repo    configuration so that your <code>project.xml</code> simply <code>&lt;extends&gt;modm:{board-name}&lt;/extends&gt;</code>.</li> <li>A module <code>modm:board:{board-name}</code> that pulls in required dependencies,    configures the modm library and provides the code to initialize the board.    You can then <code>#include &lt;modm/board.hpp&gt;</code> in your project.</li> </ol> <p>The BSPs all use a common interface within a top-level <code>namespace Board</code>:</p> <ul> <li><code>Board::initialize()</code>: Initializes the targets clock system, logger, LEDs and   Buttons.</li> <li><code>Board::initialize{subsystem}()</code>: Initializes optional board subsystems.</li> <li><code>Board::SystemClock</code>: Provides the clock configuration for use in   <code>Peripheral::initialize&lt;Board::SystemClock, ...&gt;()</code>.</li> <li><code>Board::Led{name}</code>: Board-specific LEDs  are initialized as outputs and off.</li> <li><code>Board::Leds</code>: A <code>modm::platform::SoftwareGpioPort</code> containing all board LEDs.</li> <li><code>Board::Button</code>: Board-specific input buttons are initialized as input with   pull-up/down as required.</li> <li><code>Board::{pin-name}</code>: All board-specific pins are aliased to their respective   <code>modm::platform::Gpio{port}{pin}</code>.</li> </ul> <p>If the board supports a dedicated serial logging output the BSP redirects the <code>modm:debug</code> module debug stream <code>MODM_LOG_INFO</code> as well as the output of the standalone <code>printf</code> function.</p> <p>Please note that YOU must explicitly call the <code>Board</code> functions to initialize your hardware, just including the board module is not enough. Here is an example using the <code>modm:disco-f469ni</code> BSP:</p> <pre><code>#include &lt;modm/board.hpp&gt;\n\nint main()\n{\n    // ALWAYS initialize the board first!\n    Board::initialize();\n    // Then initialize the subsystems you want to use\n    Board::initializeDisplay();\n\n    // Set LEDs via the GPIO port\n    Board::Leds::write(0b1011);\n\n    // Use the Arduino pin names\n    Board::D0::setOutput(modm::Gpio::High);\n    Board::D1::setInput();\n\n    // Use the boards serial logging\n    MODM_LOG_INFO &lt;&lt; \"REBOOT!\" &lt;&lt; modm::endl;\n\n    while (true) {\n        // Link the LED to the button\n        Board::LedBlue::set(Board::Button:read());\n    }\n    return 0;\n}\n</code></pre> <p>Only select one BSP module</p> <p>Even though some targets have multiple BSPs modules available (for example: Blue Pill and Black Pill), you can only use one module, since all define the same functions resulting in naming conflicts.</p>"},{"location":"reference/module/modm-board/#programming","title":"Programming","text":"<p>Most development boards have a debug probe on-board and the BSPs are configured to use them automatically.</p> <p>However, for development boards without a debug probe, you need to use an external debug probe (like an STLinkv3) and specify which one you're using. For simple configuration, adding a collector is enough:</p> <pre><code>&lt;library&gt;\n  &lt;collectors&gt;\n    &lt;collect name=\"modm:build:openocd.source\"&gt;interface/stlink.cfg&lt;/collect&gt;\n  &lt;/collectors&gt;\n&lt;/library&gt;\n</code></pre> <p>For more complex configuration, add a custom <code>openocd.cfg</code> file:</p> <pre><code># Replace this with your custom programmer\nsource [find interface/stlink.cfg]\n\n# To select a specific programmer you can specify its serial number\nhla_serial \"\\\\x53\\\\x3f\\\\x6f\\\\x06\\\\x50\\\\x77\\\\x50\\\\x57\\\\x12\\\\x17\\\\x14\\\\x3f\"\n# You can discover the serial via `lsusb -v`.\n</code></pre> <p>Then include this file in your build options like so:</p> <pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:build:openocd.cfg\"&gt;openocd.cfg&lt;/option&gt;\n  &lt;/options&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/module/modm-board/#logging","title":"Logging","text":"<p>Most development boards have a dedicated serial port for logging connected to the on-board debug probe. In that case you can open the serial port independently using the program of your choice, for example <code>picocom</code>:</p> <pre><code>picocom --imap lfcrlf -b 115200 /dev/tty.usbmodem1142101\n</code></pre> <p>In case that the on-board debug probe does not have a dedicated serial port or there is no debug probe at all, the modm boards use RTT as a fallback solution. This requires you to run the debug probe to receive logging data.</p> <pre><code> $ scons log-rtt\n\u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500&gt; Real Time Transfer\n\u2570\u2500\u2500\u2500\u2500\u2500RTT\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt\nInfo : rtt: Searching for control block 'SEGGER RTT'\nInfo : rtt: Control block found at 0x20000008\nListening on port 9090 for rtt connections\nloop 51\nloop 52\nloop 53\n^C\n</code></pre> <p>See the <code>modm:rtt</code> module for more options.</p>"},{"location":"reference/module/modm-board/#customization","title":"Customization","text":"<p>The BSPs contain an opinionated set of pre-defined functionality and settings. This is great for just quickly prototyping something, however, when you want to use custom hardware, or even just change a few settings, it's better to use your own BSP:</p> <ol> <li>Generate the BSP closest to your custom hardware, then copy the files from    <code>modm/src/modm/board/{name}</code> to your own project and modify them.</li> <li>In your <code>project.xml</code> remove the board config inheritance (<code>&lt;extends&gt;</code>) and    instead copy the pre-defined options into your own config.</li> <li>Check what modm modules you need to depend on and add them to your own project    (check for <code>module.depends(...)</code> in the BSPs <code>module.lb</code>).</li> <li>You may need to manually add the pre-defined collector values to your project    configuration (check for <code>env.collect(...)</code> in the BSPs <code>module.lb</code>).</li> </ol>"},{"location":"reference/module/modm-board/#create-the-systemclock-struct","title":"Create the SystemClock struct","text":"<p>The easiest way using ST's CubeMX tool.</p>"},{"location":"reference/module/modm-board/#1-cubemx-clock-graph","title":"1. CubeMX Clock Graph","text":"<p>First we create a project in CubeMX with the desired microcontroller using the largest (pin-count, flash) variant. CubeMX displays something like this in the \"Clock configuration\" tab:</p> <p></p> <p>Then configure all clocks, muxes, multipliers and dividers to the highest allowed clock speeds (*).</p> <p>(*) exceptions: E.g. USB usually requires exactly 48 MHz.</p> <p>This settings are reflected in the constants <code>static constexpr uint32_t Frequency</code>, <code>Apb1</code> and <code>Apb2</code> as well as in <code>const Rcc::PllFactors pllFactors{...}</code> and the following lines. The <code>PllFactors</code> struct should be fairly self-explanatory.</p>"},{"location":"reference/module/modm-board/#2-peripheral-mapping","title":"2. Peripheral Mapping","text":"<p>As we can see in the graphic above, there are different clock ranges. Each peripheral is connected to a clock domain. Some peripherals have an upstream clock mux, this is currently ignored in modm and the default setting for the clock mux is assumed.</p> <p>The figure shows the block diagram of the controller, which can be found at the beginning of the data sheet (not in the reference manual):</p> <p></p> <p>For each peripheral we create a <code>static constexpr uint32_t</code> member in the <code>struct SystemClock</code> and assign the value of the clock domain to which the peripheral is connected.</p>"},{"location":"reference/module/modm-board/#dependencies","title":"Dependencies","text":"<p> modm:board modm_board modm: board modm_architecture_accessor modm: architecture: accessor modm_board-&gt;modm_architecture_accessor modm_architecture_assert modm: architecture: assert modm_board-&gt;modm_architecture_assert modm_architecture_delay modm: architecture: delay modm_board-&gt;modm_architecture_delay </p>"},{"location":"reference/module/modm-build-cmake/","title":"CMake Build Script Generator","text":"<p>lbuild module: <code>modm:build:cmake</code></p> <p>CMake is a widely used build tool supported by almost every IDE.</p> <p>This module generates three files:</p> <ul> <li>a <code>modm/cmake/ModmConfiguration.cmake</code> file: provides all required tools and   compile settings to compile modm for your target.</li> <li>a <code>modm/CMakeLists.txt</code> file: provides the modm library target.</li> </ul> <p>This module is intended to be used inside your IDE via its native CMake support which will choose the compiler, build type, build path and generators for you. Therefore you need to define your own top-level <code>CMakeLists.txt</code> and <code>src/CMakeLists.txt</code> to use this module!</p> <p>Please see this example project for details.</p> <p>Build Path is ignored</p> <p>The <code>modm:build:build.path</code> option is ignored, since the IDE is responsible for setting it. Please consult your IDEs settings for that.</p> <p>See the <code>modm:build:scons</code> or <code>modm:build:make</code> modules for build systems designed for command line usage.</p>"},{"location":"reference/module/modm-build-cmake/#cmake-targets","title":"CMake Targets","text":"<p>Several custom targets are provided to integrate embedded specific tasks into your IDE.</p>"},{"location":"reference/module/modm-build-cmake/#size","title":"size","text":"<p>Displays the static Flash and RAM consumption of your target.</p>"},{"location":"reference/module/modm-build-cmake/#program","title":"program","text":"<p>Writes the executable onto your target via AvrDude or OpenOCD.</p>"},{"location":"reference/module/modm-build-cmake/#program-bmp","title":"program-bmp","text":"<ul> <li>option <code>MODM_BMP_PORT=auto</code> as string.</li> </ul> <p>Writes the executable onto your target via Black Magic Probe. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#program-jlink","title":"program-jlink","text":"<p>Writes the executable onto your target via JLink. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#debug","title":"debug","text":"<ul> <li>option <code>MODM_DBG_UI=tui</code> in {<code>tui</code>, <code>gdbgui</code>}.</li> </ul> <p>Launches OpenOCD in the background, then launches GDB in foreground with the correct executable with text-based or web-based gdbgui UI. When GDB exits, it stops the OpenOCD process. (* only ARM Cortex-M targets)</p> <p>To use gdbgui you must have it installed via <code>pip install gdbgui</code>.</p> <p>We recommend using the IDE provided debug interface instead of this!</p>"},{"location":"reference/module/modm-build-cmake/#debug-bmp","title":"debug-bmp","text":"<ul> <li>option <code>MODM_BMP_PORT=auto</code> as string.</li> </ul> <p>Launches GDB via Black Magic Probe. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#debug-jlink","title":"debug-jlink","text":"<p>Launches GDB via JLink. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#debug-coredump","title":"debug-coredump","text":"<ul> <li>option <code>MODM_DBG_UI=tui</code> in {<code>tui</code>, <code>gdbgui</code>}.</li> </ul> <p>Launches GDB for post-mortem debugging with the using the data in the <code>coredump.txt</code> argument. (* only ARM Cortex-M targets)</p> <p>Use the <code>coredump</code> method to generate a coredump with a debugger attached, otherwise see the <code>modm:platform:fault</code> module for details how to generate and receive the coredump data from the device itself.</p>"},{"location":"reference/module/modm-build-cmake/#coredump","title":"coredump","text":"<p>Launches GDB via OpenOCD and creates a <code>coredump.txt</code> file containing all volatile memories and prints the GNU build ID of the firmware under debug. Note that this command does not require an ELF file, so it can be used to coredump any firmware whose ELF file is currently unavailable. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#coredump-bmp","title":"coredump-bmp","text":"<p>Creates a coredump via Black Magic Probe. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#coredump-jlink","title":"coredump-jlink","text":"<p>Creates a coredump via JLink. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#reset","title":"reset","text":"<p>Resets the executable via OpenOCD. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#reset-bmp","title":"reset-bmp","text":"<p>Resets the executable via Black Magic Probe. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#reset-jlink","title":"reset-jlink","text":"<p>Resets the executable via JLink. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#log-itm","title":"log-itm","text":"<ul> <li>option <code>MODM_ITM_FCPU</code> in Hz</li> </ul> <p>Configures OpenOCD in tracing mode to output ITM channel 0 on SWO pin and displays the serial output stream. (* only ARM Cortex-M targets)</p> <p>See the <code>modm:platform:itm</code> module for details how to use the ITM as a logging output.</p>"},{"location":"reference/module/modm-build-cmake/#log-itm-jlink","title":"log-itm-jlink","text":"<ul> <li>option <code>MODM_ITM_FCPU</code> in Hz</li> </ul> <p>Outputs ITM channel 0 via JLinkSWOViewer. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#log-rtt","title":"log-rtt","text":"<ul> <li>option <code>MODM_RTT_CHANNEL=0</code> as integer.</li> </ul> <p>Configures OpenOCD in RTT mode to output the chosen channel (default 0) via netcat. Stop listening with Ctrl+C. (* only ARM Cortex-M targets)</p> <p>See the <code>modm:platform:rtt</code> module for details how to use RTT for data transfer.</p>"},{"location":"reference/module/modm-build-cmake/#log-rtt-jlink","title":"log-rtt-jlink","text":"<ul> <li>option <code>MODM_RTT_CHANNEL=0</code> as integer.</li> </ul> <p>Configures JLink in RTT mode to output the chosen channel (default 0) via netcat. Stop listening with Ctrl+C. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-cmake/#options","title":"Options","text":""},{"location":"reference/module/modm-build-cmake/#include_cmakelists","title":"include_cmakelists","text":"<p>Generate a CMakeLists.txt</p> <p>This overwrites any top-level <code>CMakeLists.txt</code> file!</p> <p>Default: <code>no</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-build-cmake/#collectors","title":"Collectors","text":""},{"location":"reference/module/modm-build-cmake/#flag_format","title":"flag_format","text":"<p>Formatting compile flags for CMake</p> <p>Inputs: <code>[Callable]</code></p>"},{"location":"reference/module/modm-build-compilation_db/","title":"CompilationDB Generator","text":"<p>lbuild module: <code>modm:build:compilation_db</code></p> <p>This module generates a Python script that generates a CompilationDB file, which allows you to import your project into a code editor like CLion or Qt Creator with working code completion and enhanced refactoring.</p> <p>CompilationDB is not a build system replacement</p> <p>CompilationDB support is currently only implemented as an import mechanism in all IDEs, it cannot be used to compile AND LINK your application correctly. Use a proper build system for that purpose.</p> <p>Since the CompilationDB requires absolute paths making it difficult to share with other users, this module instead generates a script that you can call whenever you need to generate a new <code>compile_commands.json</code> file.</p> <p>The script takes are argument the application folder or files that it should include. The search is recursive and looks only for source files while ignoring any generated files:</p> <pre><code># When calling this from where project.xml is located\n# adding all sources contained in the current folder\npython3 modm/tools/builder_compilation_db.py .\n</code></pre> <p>To generate the CompilationDB for debug mode, use the <code>--debug</code> option:</p> <pre><code># You can also add individual files\npython3 modm/tools/builder_compilation_db.py --debug main.cpp\n</code></pre>"},{"location":"reference/module/modm-build-compilation_db/#scons-integration","title":"SCons integration","text":"<p>When including this module together with the <code>modm:build:scons</code> module, a new command is added to SCons, which wraps the above command line invocation.</p> <pre><code># This command safely wraps the generation script\nscons compilation_db profile=release\nscons compilation_db profile=debug\n</code></pre>"},{"location":"reference/module/modm-build-compilation_db/#collectors","title":"Collectors","text":""},{"location":"reference/module/modm-build-compilation_db/#flag_format","title":"flag_format","text":"<p>Formatting compile flags for CompilationDB</p> <p>Inputs: <code>[Callable]</code></p>"},{"location":"reference/module/modm-build-make/","title":"Makefile Build Script Generator","text":"<p>lbuild module: <code>modm:build:make</code></p> <p>Make is a simple dependency tracking build system. It's very lightweight and available pretty much everywhere.</p> <p>This module generates a set of self contained Makefiles for building modm applications:</p> <ul> <li>a <code>modm/config.mk</code> file: configures the toolchain, device-specific information   and sets up generic and special build rules based on the <code>modm:build</code> options.</li> <li>a <code>modm/repo.mk</code> file: contains all build rules to build the modm library.</li> <li>a top-level BSD-licensed <code>Makefile</code> file: globs the application sources and   provides all the Makefile targets for the device-specific embedded tools.</li> </ul> <p>We do not intend to serve every possible use-case with this module. If you need something special, write your own Makefile, maybe starting by modifying ours. It is intentionally BSD-licensed so that you do not have to publish your changes to it.</p> <p>Remember to set <code>modm:build:make:include_makefile</code> to <code>False</code>, so that your custom <code>Makefile</code> does not get overwritten by <code>lbuild build</code>.</p> <p>No Windows Support</p> <p>Due to issues with the Windows path separator <code>\\</code> the generated Makefile may not work correctly on Windows. We recommend using SCons on Windows instead.</p>"},{"location":"reference/module/modm-build-make/#makefile-targets","title":"Makefile Targets","text":"<p>This module generates these <code>.PHONY</code> targets.</p>"},{"location":"reference/module/modm-build-make/#make","title":"make","text":"<p>Defaults to make build size.</p> <p>You can add these arguments to any of the Make commands:</p> <ul> <li><code>-j8</code>: Process 8 jobs in parallel. You can also <code>export MAKEFLAGS=\"-j8\"</code> in          your <code>.bashrc</code> to have a permanent setting.</li> <li><code>-n</code>: gives a verbose, simulated output, so you can check what options the         compiler is called with.</li> <li><code>profile=release</code>: Compile project with the release profile options (default).</li> <li><code>profile=debug</code>: Compile project with the debug profile options.</li> </ul> <p>For a description of the <code>release</code> and <code>debug</code> profiles, see the <code>modm:build</code> module documentation.</p> <p>Debug Profile</p> <p>When working with the debug profile, make sure to add <code>profile=debug</code> to all commands, especially <code>make program profile=debug</code> and <code>make debug profile=debug</code>!</p>"},{"location":"reference/module/modm-build-make/#make-build","title":"make build","text":"<pre><code>make build profile={debug|release}\n</code></pre> <p>Compiles your application into an executable.</p> <p>Example for an embedded target:</p> <pre><code> $ make build\nCompiling C++\u00b7\u00b7 {debug|release}/main.o\nCompiling C\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/ext/gcc/cabi.o\n    ...\nCompiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o\nArchiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a\nIndexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a\nLinking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-clean","title":"make clean","text":"<pre><code>make clean profile={debug|release}\n</code></pre> <p>Cleans the build artifacts.</p> <pre><code> $ make clean\nRemoving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-run","title":"make run","text":"<p>Compiles and executes your program on your computer. (* only Hosted targets)</p>"},{"location":"reference/module/modm-build-make/#make-size","title":"make size","text":"<pre><code>make size profile={debug|release}\n</code></pre> <p>Displays the static Flash and RAM consumption of your target.</p> <p>Example for a STM32 target with 16MB external heap:</p> <pre><code> $ make size\nMemory usage\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf\nProgram:  12.8 KiB (0.6% used)\n(.data + .fastcode + .fastdata + .hardware_init + .reset + .rodata +\n .table.copy.extern + .table.copy.intern + .table.section_heap +\n .table.zero.intern + .text)\n\nData:      5.8 KiB (1.5% used) = 2936 B static (0.7%) + 3040 B stack (0.8%)\n(.bss + .data + .fastdata + .stack)\n\nHeap:     16.4 MiB\n(.heap0 + .heap1 + .heap2 + .heap3 + .heap5 + .heap_extern)\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-program","title":"make program","text":"<pre><code>make program profile={debug|release} port={serial-port}\n</code></pre> <p>Writes the executable onto your target via Avrdude or OpenOCD. This is a convenience wrapper around the programming options and methods defined in the <code>modm:build</code> module. (* only AVR and ARM Cortex-M targets)</p> <p>Example for a STM32 target:</p> <pre><code> $ make program\nOpen On-Chip Debugger 0.10.0\n    ...\nInfo : using stlink api v2\nInfo : Target voltage: 3.259396\nInfo : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\n    ...\n** Programming Started **\nauto erase enabled\nInfo : device id = 0x10006434\nInfo : flash size = 2048kbytes\nInfo : Dual Bank 2048 kiB STM32F42x/43x/469/479 found\n    ...\nwrote 16384 bytes from file {debug|release}/blink.elf in 0.589736s (27.131 KiB/s)\n** Programming Finished **\n** Verify Started **\nverified 13064 bytes in 0.296308s (43.056 KiB/s)\n** Verified OK **\nshutdown command invoked\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-program-fuses","title":"make program-fuses","text":"<pre><code>make program-fuses profile={debug|release}\n</code></pre> <p>Writes all fuses onto your target connected to avrdude. See the <code>modm:platform:core</code> module for how to define the fuse values. (* only AVR targets)</p>"},{"location":"reference/module/modm-build-make/#make-program-dfu","title":"make program-dfu","text":"<pre><code>make program-dfu profile={debug|release} [delay={seconds}]\n</code></pre> <p>Writes the executable onto your target via Device Firmware Update (DFU) over USB. A DFU bootloader is available on many STM32 microcontrollers and can be accessed by pressing the BOOT0-Button during startup.</p> <p>Some DFU devices require additional delay to re-enumerate, which you can specify with the <code>delay</code> parameter (default is 5 seconds). (* only ARM Cortex-M targets)</p> <pre><code> $ make program-dfu\nBinary File\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.bin\ndfu_stm32_programmer: program /build/{debug|release}/blink.bin\ndfu-util 0.9\nOpening DFU capable USB device...\nID 0483:df11\nRun-time device DFU version 011a\nClaiming USB DFU Interface...\nDetermining device status: state = dfuIDLE, status = 0\ndfuIDLE, continuing\nDFU mode device DFU version 011a\nDevice returned transfer size 2048\nDfuSe interface name: \"Internal Flash  \"\nMemory segment at 0x08000000   4 x 16384 = 65536 (rew)\nMemory segment at 0x08010000   1 x 65536 = 65536 (rew)\nMemory segment at 0x08020000   1 x 131072 = 131072 (rew)\nDownloading to address = 0x08000000, size = 2060\nDownload        [                         ]   0%            0 bytes   Poll timeout 100 ms\n   Poll timeout 0 ms\n Download from image offset 00000000 to memory 08000000-080007ff, size 2048\n   Poll timeout 104 ms\n   Poll timeout 0 ms\n Download from image offset 00000800 to memory 08000800-0800080b, size 12\n   Poll timeout 104 ms\n   Poll timeout 0 ms\nFile downloaded successfully\n   Poll timeout 104 ms\n   Poll timeout 0 ms\nTransitioning to dfuMANIFEST state\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-program-bmp","title":"make program-bmp","text":"<pre><code>make program-bmp profile={debug|release} port={serial-port}\n</code></pre> <p>Black Magic Probe is convenient tool to convert cheap USB ST-LINK V2 clones to a fully functional GDB compatible debug adaptor for ARM Cortex microcontrollers. GDB can directly communicate with the debug adaptor making debugging easy and accessible. (* only ARM Cortex-M targets)</p> <p>Black Magic Probe creates two serial devices, the first being the GDB interface and the second a plain serial adaptor for debugging purposes.</p> <pre><code>$ ls -l /dev/tty.usb*\ncrw-rw-rw-  1 root  wheel   21, 104 Feb 19 09:46 /dev/tty.usbmodemDEADBEEF\ncrw-rw-rw-  1 root  wheel   21, 106 Feb 19 09:46 /dev/tty.usbmodemDEADBEF1\n</code></pre> <p>You can let the tool guess the port or explicitly specify it:</p> <pre><code> $ make program-bmp port=/dev/tty.usbmodemDEADBEEF\nRemote debugging using /dev/tty.usbmodemDEADBEEF\nTarget voltage: unknown\nAvailable Targets:\nNo. Att Driver\n 1      STM32F1 medium density\nAttaching to Remote target\nwarning: No executable has been specified and target does not support\ndetermining executable automatically.  Try using the \"file\" command.\n0x0800038e in ?? ()\nLoading section .vector_rom, size 0xec lma 0x8000000\n[...]\nLoading section .table.section_heap, size 0xc lma 0x80013f8\nStart address 0x8000e6c, load size 5120\nTransfer rate: 10 KB/sec, 365 bytes/write.\nDetaching from program: , Remote target\n[Inferior 1 (Remote target) detached]\nmake: done building targets.\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-program-jlink","title":"make program-jlink","text":"<pre><code>make program-jlink profile={debug|release}\n</code></pre> <p>Writes the executable onto your target via JLink. This is a convenience wrapper around the programming options and methods defined in the <code>modm:build</code> module. (* only ARM Cortex-M targets)</p> <pre><code> $ make program-jlink\nSEGGER J-Link GDB Server V7.84f Command Line Version\n\nJLinkARM.dll V7.84f (DLL compiled Feb  7 2023 16:45:51)\n\n-----GDB Server start settings-----\nGDBInit file:                  none\nGDB Server Listening port:     2331\nSWO raw output listening port: 2332\nTerminal I/O port:             2333\nAccept remote connection:      yes\nGenerate logfile:              off\nVerify download:               off\nInit regs on start:            off\nSilent mode:                   on\nSingle run mode:               off\nTarget connection timeout:     0 ms\n------J-Link related settings------\nJ-Link Host interface:         USB\nJ-Link script:                 none\nJ-Link settings file:          none\n------Target related settings------\nTarget device:                 stm32l476rg\nTarget device parameters:      none\nTarget interface:              SWD\nTarget interface speed:        4000kHz\nTarget endian:                 little\n\nmodm::delay_us (us=&lt;optimized out&gt;) at modm/src/modm/platform/core/delay.cpp:33\n33          if (now - start &gt;= cycles) break;\nLoading section .text, size 0x188 lma 0x8000000\nLoading section .build_id, size 0x24 lma 0x8000188\nLoading section .text, size 0xe7c lma 0x80001b0\nLoading section .rodata, size 0x6c lma 0x800102c\nLoading section .data, size 0x4 lma 0x8001098\nLoading section .fastdata, size 0x8 lma 0x800109c\nLoading section .rodata, size 0x70 lma 0x80010a4\nStart address 0x08000a50, load size 4368\nTransfer rate: 4265 KB/sec, 624 bytes/write.\nResetting target\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-debug","title":"make debug","text":"<pre><code>make debug profile={debug|release} ui={tui|gdbgui}\n</code></pre> <p>Launches OpenOCD in the background, then launches GDB in foreground with the correct executable with text-based or web-based GDBGUI UI. When GDB exits, it stops the OpenOCD process. (* only ARM Cortex-M targets)</p> <p>This is just a convenience wrapper for the debug functionality defined in the <code>modm:build</code> module. To use GDBGUI you must have it installed via <code>pip install gdbgui</code>.</p> <p>Choose the correct profile</p> <p>When debugging, make sure to select the correct compilation profile. The firmware and the executable given to GDB have to be the same or you'll see GDB translate the program counter to the wrong code locations. When you suspect a bug in your firmware, consider that it was most likely compiled with the release profile, since that's the default. First try to <code>make debug profile=release</code>, and if that doesn't help, compile and <code>make program profile=debug</code> and try <code>make debug profile=debug</code> again.</p>"},{"location":"reference/module/modm-build-make/#make-debug-bmp","title":"make debug-bmp","text":"<pre><code>make debug-bmp profile={debug|release} ui={tui|gdbgui} port={serial-port}\n</code></pre> <p>Launches GDB to debug via Black Magic Probe. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#make-debug-jlink","title":"make debug-jlink","text":"<pre><code>make debug-jlink profile={debug|release} ui={tui|gdbgui}\n</code></pre> <p>Launches GDB to debug via JLink. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#make-debug-coredump","title":"make debug-coredump","text":"<pre><code>make debug-coredump profile={debug|release} ui={tui|gdbgui} \\\n                    coredump={path/to/coredump.txt}\n</code></pre> <p>Launches GDB for post-mortem debugging with the latest firmware using the data from the <code>coredump={filepath}</code> argument. (* only ARM Cortex-M targets)</p> <p>See the <code>modm:platform:fault</code> module for details how to receive the coredump data.</p>"},{"location":"reference/module/modm-build-make/#make-coredump","title":"make coredump","text":"<pre><code>make coredump\n</code></pre> <p>Launches GDB via OpenOCD and creates a <code>coredump.txt</code> file containing all volatile memories and prints the GNU build ID of the firmware under debug. Note that this command does not require an ELF file, so it can be used to coredump any firmware whose ELF file is currently unavailable. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#make-coredump-bmp","title":"make coredump-bmp","text":"<pre><code>make coredump-bmp port={serial-port}\n</code></pre> <p>Creates a coredump via Black Magic Probe. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#make-coredump-jlink","title":"make coredump-jlink","text":"<pre><code>make coredump-jlink\n</code></pre> <p>Creates a coredump via JLink. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#make-reset","title":"make reset","text":"<pre><code>make reset\n</code></pre> <p>Resets the executable via OpenOCD. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#make-reset-bmp","title":"make reset-bmp","text":"<pre><code>make reset-bmp port={serial-port}\n</code></pre> <p>Resets the executable via Black Magic Probe. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#make-reset-jlink","title":"make reset-jlink","text":"<pre><code>make reset-jlink\n</code></pre> <p>Resets the executable via JLink. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#make-log-itm","title":"make log-itm","text":"<pre><code>make log-itm fcpu={HCLK in Hz}\n</code></pre> <p>Configures OpenOCD in tracing mode to output ITM channel 0 on SWO pin and displays the serial output stream. (* only ARM Cortex-M targets)</p> <pre><code> $ make log-itm fcpu=64000000\nOpen On-Chip Debugger 0.10.0\nLicensed under GNU GPL v2\nInfo : The selected transport took over low-level target control.\nloop: 57\nloop: 58\nloop: 59\nloop: 60\nloop: 61\n</code></pre> <p>See the <code>modm:platform:itm</code> module for details how to use the ITM as a logging output.</p>"},{"location":"reference/module/modm-build-make/#make-log-itm-jlink","title":"make log-itm-jlink","text":"<pre><code>make log-itm-jlink [channel={int}]\n</code></pre> <p>Outputs the ITM channel via JLinkSWOViewer. Note that JLink auto-detects the CPU frequency. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#make-log-rtt","title":"make log-rtt","text":"<pre><code>make log-rtt [channel={int}]\n</code></pre> <p>Configures OpenOCD in RTT mode to output the chosen channel (default 0) via netcat. Stop listening with Ctrl+C. (* only ARM Cortex-M targets)</p> <pre><code> $ make log-rtt\nInfo : rtt: Searching for control block 'SEGGER RTT'\nInfo : rtt: Control block found at 0x20000008\nloop: 57\nloop: 58\nloop: 59\nloop: 60\nloop: 61\n</code></pre> <p>See the <code>modm:platform:rtt</code> module for details how to use RTT for data transfer.</p>"},{"location":"reference/module/modm-build-make/#make-log-rtt-jlink","title":"make log-rtt-jlink","text":"<pre><code>make log-rtt-jlink [channel={int}]\n</code></pre> <p>Configures JLink in RTT mode to output the chosen channel (default 0) via netcat. Stop listening with Ctrl+C. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#make-library","title":"make library","text":"<pre><code>make library profile={debug|release}\n</code></pre> <p>Generates only the static library <code>libmodm.a</code> without linking it to the application.</p> <pre><code> $ make library\nCompiling C++\u00b7\u00b7 {debug|release}/modm/ext/gcc/assert.o\n    ...\nCompiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o\nArchiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a\nIndexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-symbols","title":"make symbols","text":"<pre><code>make symbols profile={debug|release}\n</code></pre> <p>Dumps the symbol table for your executable.</p> <pre><code> $ make symbols\n536871656 00000001 b (anonymous namespace)::nextOperation\n536871657 00000001 b (anonymous namespace)::checkNextOperation\n536871658 00000001 b (anonymous namespace)::error\n536871444 00000001 b read_touch()::initialized\n    ...\n134228236 00000668 T I2C1_EV_IRQHandler\n134224924 00001136 T otm8009a_init(unsigned char)\n134221192 00001378 t _GLOBAL__sub_I_p\n536871782 00002054 b (anonymous namespace)::txBuffer\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-listing","title":"make listing","text":"<pre><code>make listing profile={debug|release}\n</code></pre> <p>Decompiles your executable into an annotated assembly listing. This is very useful for checking and learning how the compiler translates C++ into assembly instructions:</p> <pre><code> $ make listing\nListing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.lss\n $ less {debug|release}/blink.lss\n    ...\nDisassembly of section .text:\n    ...\n08000d74 &lt;main&gt;:\nmain():\n./main.cpp:315\n\nint\nmain()\n{\n 8000d74:   b508        push    {r3, lr}\n    Board::initialize();\n 8000d76:   f7ff fcc9   bl  800070c &lt;_ZN5Board10initializeEv&gt;\n    Board::initializeDisplay();\n 8000d7a:   f000 fd91   bl  80018a0 &lt;_ZN5Board17initializeDisplayEv&gt;\n    Board::initializeTouchscreen();\n 8000d7e:   f7ff fc55   bl  800062c &lt;_ZN5Board21initializeTouchscreenEv&gt;\n    blink();\n 8000d82:   f7ff feff   bl  8000b84 &lt;_Z12blinkv&gt;\n    ...\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-bin","title":"make bin","text":"<pre><code>make bin profile={debug|release}\n</code></pre> <p>Creates a binary file of your executable.</p> <pre><code> $ make bin\nBinary File\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.bin\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-hex","title":"make hex","text":"<pre><code>make hex profile={debug|release}\n</code></pre> <p>Creates a Intel-hex file of your executable.</p> <pre><code> $ make bin\nHex File\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.hex\n</code></pre>"},{"location":"reference/module/modm-build-make/#make-uf2","title":"make uf2","text":"<pre><code>make uf2 profile={debug|release} [firmware={hash or file}]\n</code></pre> <p>Creates a UF2 compatible file of your executable. UF2 is a bootloader by Microsoft.</p> <pre><code> $ make uf2\nUF2 File\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.uf2\n</code></pre> <p>(* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-make/#information-tool","title":"Information Tool","text":"<p>This tool generates a set of header files containing information about the repository state.</p> <p>Setting the <code>modm:build:info.git</code> option will generate a <code>&lt;info_git.h&gt;</code> header file and add these two defines to the command line CPP options:</p> <ul> <li><code>MODM_GIT_INFO</code></li> <li><code>MODM_GIT_STATUS</code>: defined only with option <code>Git+Status</code>.</li> </ul> <p>Increased build time</p> <p>Since the git repository status can change at any time, it needs to be checked on every build. This adds less than a second to every build.</p> <p>Setting the <code>modm:build:info.build</code> option will generate a <code>&lt;info_build.h&gt;</code> header file and add this define to the command line CPP options:</p> <ul> <li><code>MODM_BUILD_INFO</code></li> </ul> <p>Respect developers privacy</p> <p>This information is placed into the firmware in cleartext, so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need!</p>"},{"location":"reference/module/modm-build-make/#bitmap-tool","title":"Bitmap Tool","text":"<p>If the <code>modm:build:image.source</code> is defined as a path, it'll be searched for <code>.pbm</code> files to convert into C++ data files using the <code>bitmap</code> tool.</p> <p>See the <code>GraphicsDisplay::drawImage()</code> method in the <code>modm:ui:display</code> module for how to use these generated files. The directory is added to the include search paths, so the generated files can be accessed as <code>#include &lt;image.hpp&gt;</code>.</p>"},{"location":"reference/module/modm-build-make/#options","title":"Options","text":""},{"location":"reference/module/modm-build-make/#include_makefile","title":"include_makefile","text":"<p>Generate a Makefile</p> <p>This overwrites any top-level <code>Makefile</code>!</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-build-make/#collectors","title":"Collectors","text":""},{"location":"reference/module/modm-build-make/#flag_format","title":"flag_format","text":"<p>Formatting compile flags for Make</p> <p>Inputs: <code>[Callable]</code></p>"},{"location":"reference/module/modm-build-scons/","title":"SCons Build Script Generator","text":"<p>lbuild module: <code>modm:build:scons</code></p> <p>SCons is a software construction build system written in Python. For a better embedded experience, we've extended it with modm-specific build tools.</p> <p>This module generates two files:</p> <ul> <li>a <code>modm/SConscript</code> file: configures all required SCons tools with   the right settings (also using information from the <code>modm:build</code> module) to   compile the modm library.</li> <li>a top-level BSD-licensed <code>SConstruct</code> file: configures additional, optional   tools and sets up all the relevant SCons functions for your target.</li> </ul> <p>The <code>SConscript</code> file is self contained and does not depend on anything outside of the <code>modm/</code> directory. This allows it to be combined with <code>SConscript</code> of other projects without clashing.</p> <p>In fact, if you look at your generated <code>SConstruct</code> file, you'll notice that it doesn't contain a lot of logic or specific data, it is only meant for calling the right SCons tool with the right arguments.</p> <p>We do not intend to serve every possible use-case with this module. If you need something special, write your own SConstruct file, maybe starting by modifying ours. It is intentionally BSD-licensed so that you do not have to publish your changes to it.</p> <p>Remember to set <code>modm:build:scons:include_sconstruct</code> to <code>False</code>, so that your custom <code>SConstruct</code> does not get overwritten by <code>lbuild build</code>. See the instructions inside our generated default <code>SConstruct</code> file.</p>"},{"location":"reference/module/modm-build-scons/#scons-methods","title":"SCons Methods","text":"<p>This module generates these SCons methods depending on the target.</p>"},{"location":"reference/module/modm-build-scons/#scons","title":"scons","text":"<p>Defaults to scons build size.</p> <p>You can add these arguments to any of the SCons commands:</p> <ul> <li><code>verbose=1</code>: gives a more verbose output, so you can, for example, check what   options the compiler is called with.</li> <li><code>profile=release</code>: Compile project with the release profile options (default).</li> <li><code>profile=debug</code>: Compile project with the debug profile options.</li> </ul> <p>For a description of the <code>release</code> and <code>debug</code> profiles, see the <code>modm:build</code> module documentation.</p> <p>Debug Profile</p> <p>When working with the debug profile, make sure to add <code>profile=debug</code> to all commands, especially <code>scons program profile=debug</code> and <code>scons debug profile=debug</code>!</p> <p>Some SCons commands take a <code>firmware={GNU Build ID or path/to/firmware.elf}</code> argument that specifies which firmware to use for the command. It is useful in combination with the <code>scons artifact</code> command to preserve a specific firmware version for later.</p>"},{"location":"reference/module/modm-build-scons/#scons-build","title":"scons build","text":"<pre><code>scons build profile={debug|release}\n</code></pre> <p>Compiles your application into an executable.</p> <p>Example for a STM32 target:</p> <pre><code> $ scons build\nCompiling C++\u00b7\u00b7 {debug|release}/main.o\nCompiling C\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/ext/gcc/cabi.o\n    ...\nCompiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o\nArchiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a\nIndexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a\nLinking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-c","title":"scons -c","text":"<pre><code>scons -c profile={debug|release}\n</code></pre> <p>Cleans the build artifacts.</p> <pre><code> $ scons -c\nRemoved {debug|release}/main.o\nRemoved {debug|release}/modm/ext/tlsf/tlsf.o\n    ...\nRemoved {debug|release}/modm/src/modm/ui/display/virtual_graphic_display.o\nRemoved {debug|release}/modm/src/modm/utils/dummy.o\nRemoved {debug|release}/modm/libmodm.a\nRemoved {debug|release}/blink.elf\nRemoved {debug|release}/blink.lss\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-size","title":"scons size","text":"<pre><code>scons size profile={debug|release} [firmware={hash or file}]\n</code></pre> <p>Displays the static Flash and RAM consumption of your target.</p> <p>Example for a STM32 target with 16MB external heap:</p> <pre><code> $ scons size\nMemory usage\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf\nProgram:  12.8 KiB (0.6% used)\n(.data + .fastcode + .fastdata + .hardware_init + .reset + .rodata +\n .table.copy.extern + .table.copy.intern + .table.section_heap +\n .table.zero.intern + .text)\n\nData:      5.8 KiB (1.5% used) = 2936 B static (0.7%) + 3040 B stack (0.8%)\n(.bss + .data + .fastdata + .stack)\n\nHeap:     16.4 MiB\n(.heap0 + .heap1 + .heap2 + .heap3 + .heap5 + .heap_extern)\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-program","title":"scons program","text":"<pre><code>scons program profile={debug|release} [firmware={hash or file}]\n</code></pre> <p>Writes the executable onto your target via Avrdude or OpenOCD. This is a convenience wrapper around the programming options and methods defined in the <code>modm:build</code> module. (* only AVR and ARM Cortex-M targets)</p> <p>Example for a STM32 target:</p> <pre><code> $ scons program\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 /build/{debug|release}/blink.elf\n\u2570\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500&gt; stm32f469nih\nOpen On-Chip Debugger 0.10.0\n    ...\nInfo : using stlink api v2\nInfo : Target voltage: 3.259396\nInfo : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\n    ...\n** Programming Started **\nauto erase enabled\nInfo : device id = 0x10006434\nInfo : flash size = 2048kbytes\nInfo : Dual Bank 2048 kiB STM32F42x/43x/469/479 found\n    ...\nwrote 16384 bytes from file {debug|release}/blink.elf in 0.589736s (27.131 KiB/s)\n** Programming Finished **\n** Verify Started **\nverified 13064 bytes in 0.296308s (43.056 KiB/s)\n** Verified OK **\nshutdown command invoked\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-program-fuses","title":"scons program-fuses","text":"<pre><code>scons program-fuses profile={debug|release} [firmware={hash or file}]\n</code></pre> <p>Writes all fuses onto your target connected to avrdude. See the <code>modm:platform:core</code> module for how to define the fuse values. (* only AVR targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-program-dfu","title":"scons program-dfu","text":"<pre><code>scons program-dfu profile={debug|release} [firmware={hash or file}] [delay={seconds}]\n</code></pre> <p>Writes the executable onto your target via Device Firmware Update (DFU) over USB. A DFU bootloader is available on many STM32 microcontrollers and can be accessed by pressing the BOOT0-Button during startup.</p> <p>Some DFU devices require additional delay to re-enumerate, which you can specify with the <code>delay</code> parameter (default is 5 seconds). (* only ARM Cortex-M targets)</p> <pre><code>$ scons program-dfu\nBinary File\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.bin\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 /build/{debug|release}/blink.bin\n\u2570\u2500\u2500\u2500\u2500\u2500DFU\u2500\u2500\u2500\u2500\u2500&gt; stm32f469nih\ndfu_stm32_programmer: program /build/{debug|release}/blink.bin\ndfu-util 0.9\nOpening DFU capable USB device...\nID 0483:df11\nRun-time device DFU version 011a\nClaiming USB DFU Interface...\nDetermining device status: state = dfuIDLE, status = 0\ndfuIDLE, continuing\nDFU mode device DFU version 011a\nDevice returned transfer size 2048\nDfuSe interface name: \"Internal Flash  \"\nMemory segment at 0x08000000   4 x 16384 = 65536 (rew)\nMemory segment at 0x08010000   1 x 65536 = 65536 (rew)\nMemory segment at 0x08020000   1 x 131072 = 131072 (rew)\nDownloading to address = 0x08000000, size = 2060\nDownload        [                         ]   0%            0 bytes   Poll timeout 100 ms\n   Poll timeout 0 ms\n Download from image offset 00000000 to memory 08000000-080007ff, size 2048\n   Poll timeout 104 ms\n   Poll timeout 0 ms\n Download from image offset 00000800 to memory 08000800-0800080b, size 12\n   Poll timeout 104 ms\n   Poll timeout 0 ms\nFile downloaded successfully\n   Poll timeout 104 ms\n   Poll timeout 0 ms\nTransitioning to dfuMANIFEST state\nscons: done building targets.\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-program-bmp","title":"scons program-bmp","text":"<pre><code>scons program-bmp profile={debug|release} port={serial-port} [firmware={hash or file}]\n</code></pre> <p>Black Magic Probe is convenient tool to convert cheap USB ST-LINK V2 clones to a fully functional GDB compatible debug adaptor for ARM Cortex microcontrollers. GDB can directly communicate with the debug adaptor making debugging easy and accessible. (* only ARM Cortex-M targets)</p> <p>Black Magic Probe creates two serial devices, the first being the GDB interface and the second a plain serial adaptor for debugging purposes.</p> <pre><code>$ ls -l /dev/tty.usb*\ncrw-rw-rw-  1 root  wheel   21, 104 Feb 19 09:46 /dev/tty.usbmodemDEADBEEF\ncrw-rw-rw-  1 root  wheel   21, 106 Feb 19 09:46 /dev/tty.usbmodemDEADBEF1\n</code></pre> <p>You can let the tool guess the port or explicitly specify it:</p> <pre><code>$ scons program-bmp port=/dev/tty.usbmodemDEADBEEF\n\u256d\u2500Black\u2500Magic\u2500\u2500 /build/{debug|release}/blink.elf\n\u2570\u2500\u2500\u2500\u2500Probe\u2500\u2500\u2500\u2500&gt; stm32f103rbt6\nRemote debugging using /dev/tty.usbmodemDEADBEEF\nTarget voltage: unknown\nAvailable Targets:\nNo. Att Driver\n 1      STM32F1 medium density\nAttaching to Remote target\nwarning: No executable has been specified and target does not support\ndetermining executable automatically.  Try using the \"file\" command.\n0x0800038e in ?? ()\nLoading section .vector_rom, size 0xec lma 0x8000000\n[...]\nLoading section .table.section_heap, size 0xc lma 0x80013f8\nStart address 0x8000e6c, load size 5120\nTransfer rate: 10 KB/sec, 365 bytes/write.\nDetaching from program: , Remote target\n[Inferior 1 (Remote target) detached]\nscons: done building targets.\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-program-remote","title":"scons program-remote","text":"<pre><code>scons program-remote profile={debug|release} [host={ip or hostname:port}] [firmware={hash or file}]\n</code></pre> <p>Writes the executable onto your target connected to a remote backend process running on your own computer (<code>host=\":3333\"</code>) or somewhere else. You can also connect to JLink (<code>host=\":2331\"</code>) or Black Magic Probe (<code>host=\"/dev/tty.usbserial\"</code>). (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-program-jlink","title":"scons program-jlink","text":"<pre><code>scons program-jlink profile={debug|release} [firmware={hash or file}]\n</code></pre> <p>Writes the executable onto your target via JLink. This is a convenience wrapper around the programming options and methods defined in the <code>modm:build</code> module. (* only ARM Cortex-M targets)</p> <p>Example for a STM32 target:</p> <pre><code> $ scons program-jlink\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 /build/{debug|release}/blink.elf\n\u2570\u2500\u2500\u2500\u2500JLink\u2500\u2500\u2500\u2500&gt; stm32l476rgt6\nSEGGER J-Link GDB Server V7.84f Command Line Version\n\nJLinkARM.dll V7.84f (DLL compiled Feb  7 2023 16:45:51)\n\n-----GDB Server start settings-----\nGDBInit file:                  none\nGDB Server Listening port:     2331\nSWO raw output listening port: 2332\nTerminal I/O port:             2333\nAccept remote connection:      yes\nGenerate logfile:              off\nVerify download:               off\nInit regs on start:            off\nSilent mode:                   on\nSingle run mode:               off\nTarget connection timeout:     0 ms\n------J-Link related settings------\nJ-Link Host interface:         USB\nJ-Link script:                 none\nJ-Link settings file:          none\n------Target related settings------\nTarget device:                 stm32l476rg\nTarget device parameters:      none\nTarget interface:              SWD\nTarget interface speed:        4000kHz\nTarget endian:                 little\n\nwarning: Source file is more recent than executable.\nResetting target\nscons: done building targets.\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-openocd","title":"scons openocd","text":"<pre><code>scons openocd\n</code></pre> <p>Starts an OpenOCD process to attach a remote debugger to (e.g. with <code>scons program-remote</code> or <code>scons debug-remote</code>). (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-jlink","title":"scons jlink","text":"<pre><code>scons jlink\n</code></pre> <p>Starts a JLinkGDBServer process to attach a remote debugger to (e.g. with <code>scons program-remote</code> or <code>scons debug-remote</code>). (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-run","title":"scons run","text":"<p>Compiles and executes your program on your computer. (* only Hosted targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-debug","title":"scons debug","text":"<pre><code>scons debug profile={debug|release} ui={tui|gdbgui} [firmware={hash or file}]\n</code></pre> <p>Launches OpenOCD in the background, then launches GDB in foreground with the correct executable with text-based or web-based GDBGUI UI. When GDB exits, it stops the OpenOCD process. (* only ARM Cortex-M targets)</p> <p>This is just a convenience wrapper for the debug functionality defined in the <code>modm:build</code> module. To use GDBGUI you must have it installed via <code>pip install gdbgui</code>.</p> <p>Choose the correct profile</p> <p>When debugging, make sure to select the correct compilation profile. The firmware and the executable given to GDB have to be the same or you'll see GDB translate the program counter to the wrong code locations. When you suspect a bug in your firmware, consider that it was most likely compiled with the release profile, since that's the default. First try to <code>scons debug profile=release</code>, and if that doesn't help, compile and <code>scons program profile=debug</code> and try <code>scons debug profile=debug</code> again.</p>"},{"location":"reference/module/modm-build-scons/#scons-debug-remote","title":"scons debug-remote","text":"<pre><code>scons debug-remote profile={debug|release} ui={tui|gdbgui} [host={ip or hostname:port}] [firmware={hash or file}]\n</code></pre> <p>Debugs the executable via a remote OpenOCD process running on your own computer (<code>host=\":3333\"</code>) or somewhere else. You can also connect to JLink (<code>host=\":2331\"</code>) or Black Magic Probe (<code>host=\"/dev/tty.usbserial\"</code>). (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-debug-bmp","title":"scons debug-bmp","text":"<pre><code>scons debug-bmp profile={debug|release} ui={tui|gdbgui} port={serial-port} [firmware={hash or file}]\n</code></pre> <p>Launches GDB to debug via Black Magic Probe. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-debug-jlink","title":"scons debug-jlink","text":"<pre><code>scons debug-jlink profile={debug|release} ui={tui|gdbgui} [firmware={hash or file}]\n</code></pre> <p>Launches GDB to debug via JLink. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-debug-coredump","title":"scons debug-coredump","text":"<pre><code>scons debug-coredump profile={debug|release} ui={tui|gdbgui} \\\n                     coredump={path/to/coredump.txt} \\\n                     [firmware={GNU Build ID or path/to/firmware.elf}]\n</code></pre> <p>Launches GDB for post-mortem debugging with the firmware identified by the (optional) <code>firmware={hash or filepath}</code> argument using the data from the <code>coredump={filepath}</code> argument. Note that CrashDebug must be in your path, see the <code>modm:crashcatcher</code> module for details.</p> <p>Use the <code>scons coredump</code> method to generate a coredump with a debugger attached, otherwise see the <code>modm:platform:fault</code> module for details how to generate and receive the coredump data from the device itself. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-coredump","title":"scons coredump","text":"<pre><code>scons coredump\n</code></pre> <p>Launches GDB via OpenOCD and creates a <code>coredump.txt</code> file containing all volatile memories and prints the GNU build ID of the firmware under debug. Note that this command does not require an ELF file, so it can be used to coredump any firmware whose ELF file is currently unavailable. You can use the GNU build ID to find the corresponding ELF file in your artifact store (see <code>scons artifact</code>). (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-coredump-bmp","title":"scons coredump-bmp","text":"<pre><code>scons coredump-bmp port={serial-port}\n</code></pre> <p>Creates a coredump via Black Magic Probe. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-coredump-jlink","title":"scons coredump-jlink","text":"<pre><code>scons coredump-jlink\n</code></pre> <p>Creates a coredump via JLink. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-reset","title":"scons reset","text":"<pre><code>scons reset\n</code></pre> <p>Resets the executable via OpenOCD. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-reset-bmp","title":"scons reset-bmp","text":"<pre><code>scons reset-bmp port={serial-port}\n</code></pre> <p>Resets the executable via Black Magic Probe. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-reset-jlink","title":"scons reset-jlink","text":"<pre><code>scons reset-jlink\n</code></pre> <p>Resets the executable via JLink. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-reset-remote","title":"scons reset-remote","text":"<pre><code>scons reset-remote [host={ip or hostname:port}]\n</code></pre> <p>Resets the executable via a remote OpenOCD process running on your own computer (<code>host=\":3333\"</code>) or somewhere else. You can also connect to JLink (<code>host=\":2331\"</code>) or Black Magic Probe (<code>host=\"/dev/tty.usbserial\"</code>). (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-log-itm","title":"scons log-itm","text":"<pre><code>scons log-itm fcpu={HCLK in Hz}\n</code></pre> <p>Configures OpenOCD in tracing mode to output ITM channel 0 on SWO pin and displays the serial output stream. (* only ARM Cortex-M targets)</p> <pre><code> $ scons log-itm fcpu=64000000\n\u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500&gt; Single Wire Viewer\n\u2570\u2500\u2500\u2500\u2500\u2500SWO\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt6\nOpen On-Chip Debugger 0.10.0\nLicensed under GNU GPL v2\nInfo : The selected transport took over low-level target control.\nloop: 57\nloop: 58\nloop: 59\nloop: 60\nloop: 61\n</code></pre> <p>See the <code>modm:platform:itm</code> module for details how to use the ITM as a logging output.</p>"},{"location":"reference/module/modm-build-scons/#scons-log-itm-jlink","title":"scons log-itm-jlink","text":"<pre><code>scons log-itm-jlink [channel={int}]\n</code></pre> <p>Outputs the ITM channel via JLinkSWOViewer. Note that JLink auto-detects the CPU frequency. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-log-rtt","title":"scons log-rtt","text":"<pre><code>scons log-rtt [channel={int}]\n</code></pre> <p>Configures OpenOCD in RTT mode to output the chosen channel (default 0) via netcat. Stop listening with Ctrl+C. (* only ARM Cortex-M targets)</p> <pre><code> $ scons log-rtt\n\u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500&gt; Real Time Transfer\n\u2570\u2500\u2500\u2500\u2500\u2500RTT\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt6\nInfo : rtt: Searching for control block 'SEGGER RTT'\nInfo : rtt: Control block found at 0x20000008\nloop: 57\nloop: 58\nloop: 59\nloop: 60\nloop: 61\n</code></pre> <p>See the <code>modm:platform:rtt</code> module for details how to use RTT for data transfer.</p>"},{"location":"reference/module/modm-build-scons/#scons-log-rtt-jlink","title":"scons log-rtt-jlink","text":"<pre><code>scons log-rtt-jlink [channel={int}]\n</code></pre> <p>Configures JLink in RTT mode to output the chosen channel (default 0) via netcat. Stop listening with Ctrl+C. (* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-library","title":"scons library","text":"<pre><code>scons library profile={debug|release}\n</code></pre> <p>Generates only the static library <code>libmodm.a</code> without linking it to the application.</p> <pre><code> $ scons library\nCompiling C++\u00b7\u00b7 {debug|release}/modm/ext/gcc/assert.o\n    ...\nCompiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o\nArchiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a\nIndexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-symbols","title":"scons symbols","text":"<pre><code>scons symbols profile={debug|release} [firmware={hash or file}]\n</code></pre> <p>Dumps the symbol table for your executable.</p> <pre><code> $ scons symbols [firmware={hash or file}]\nShow symbols for '{debug|release}/blink.elf':\n536871656 00000001 b (anonymous namespace)::nextOperation\n536871657 00000001 b (anonymous namespace)::checkNextOperation\n536871658 00000001 b (anonymous namespace)::error\n536871444 00000001 b read_touch()::initialized\n    ...\n134228236 00000668 T I2C1_EV_IRQHandler\n134224924 00001136 T otm8009a_init(unsigned char)\n134221192 00001378 t _GLOBAL__sub_I_p\n536871782 00002054 b (anonymous namespace)::txBuffer\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-listing","title":"scons listing","text":"<pre><code>scons listing profile={debug|release} [firmware={hash or file}]\n</code></pre> <p>Decompiles your executable into an annotated assembly listing. This is very useful for checking and learning how the compiler translates C++ into assembly instructions:</p> <pre><code> $ scons listing\nListing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.lss\n $ less {debug|release}/blink.lss\n    ...\nDisassembly of section .text:\n    ...\n08000d74 &lt;main&gt;:\nmain():\n./main.cpp:315\n\nint\nmain()\n{\n 8000d74:   b508        push    {r3, lr}\n    Board::initialize();\n 8000d76:   f7ff fcc9   bl  800070c &lt;_ZN5Board10initializeEv&gt;\n    Board::initializeDisplay();\n 8000d7a:   f000 fd91   bl  80018a0 &lt;_ZN5Board17initializeDisplayEv&gt;\n    Board::initializeTouchscreen();\n 8000d7e:   f7ff fc55   bl  800062c &lt;_ZN5Board21initializeTouchscreenEv&gt;\n    blink();\n 8000d82:   f7ff feff   bl  8000b84 &lt;_Z12blinkv&gt;\n    ...\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-bin","title":"scons bin","text":"<pre><code>scons bin profile={debug|release} [firmware={hash or file}]\n</code></pre> <p>Creates a binary file of your executable.</p> <pre><code> $ scons bin\nBinary File\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.bin\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-hex","title":"scons hex","text":"<pre><code>scons hex profile={debug|release} [firmware={hash or file}]\n</code></pre> <p>Creates a Intel-hex file of your executable.</p> <pre><code> $ scons hex\nHex File\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.hex\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-uf2","title":"scons uf2","text":"<pre><code>scons uf2 profile={debug|release} [firmware={hash or file}]\n</code></pre> <p>Creates a UF2 compatible file of your executable. UF2 is a bootloader by Microsoft.</p> <pre><code> $ scons uf2\nUF2 File\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.uf2\n</code></pre> <p>(* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build-scons/#scons-artifact","title":"scons artifact","text":"<pre><code>scons artifact profile={debug|release}\n</code></pre> <p>Caches the ELF and binary file of the newest compiled executable identified by the hash of the binary file in <code>artifacts/{hash}.elf</code>. You can change this path with the <code>modm:build:scons:path.artifact</code> option.</p> <pre><code> $ scons artifact\n\u256d\u2500\u2500\u2500Artifact\u2500\u2500\u2500 /build/release/blink.elf\n\u2570\u2500\u2500\u2500\u2500Cache\u2500\u2500\u2500\u2500&gt; artifacts/0214523ab713bc7bdfb37d902e65dae8305f4754.elf\n</code></pre>"},{"location":"reference/module/modm-build-scons/#scons-qtcreator","title":"scons qtcreator","text":"<p>Generates several files so that the project can be imported into Qt Creator via the <code>.creator</code> file importer. Note, that no compiliation or debugging features are supported, this is only meant for using the IDE as an editor.</p> <p>Consider this an unstable feature</p>"},{"location":"reference/module/modm-build-scons/#protobuf-generator-tool","title":"Protobuf Generator Tool","text":"<p>The <code>modm:nanopb</code> module contains a Python generator to translate the messages defined in <code>*.proto</code> files by the <code>modm:nanopb:source</code> option into <code>*.pb.cpp</code> and <code>*.pb.hpp</code> files. This module contains a SCons wrapper tool that automatically updates the generated files when it becomes necessary:</p> <pre><code>cpp_sources += env.NanopbProtofile(\n    sources=options[\":nanopb:sources\"],\n    path=options[\":nanopb:path\"],\n)\n</code></pre> <p>The generated files are available as a top-level <code>#include &lt;protofile.pb.hpp&gt;</code>.</p>"},{"location":"reference/module/modm-build-scons/#xpcc-generator-tool","title":"XPCC Generator Tool","text":"<p>The <code>modm:communication:xpcc:generator</code> module contains the Python tools to translate the XPCC XML declarations into various language implementations. This module contains a SCons wrapper tool, that understands the XML dependencies and automatically updates the generated files when it becomes necessary.</p> <p>The wrapper tool is automatically used when the generator module is detected, and its options are evaluated for the wrapper as follows:</p> <pre><code>cpp_sources += env.XpccCommunication(\n    xmlfile=options[\"::xpcc:generator:source\"],\n    container=options[\"::xpcc:generator:container\"],\n    path=options[\"::xpcc:generator:path\"],\n    namespace=options[\"::xpcc:generator:namespace\"]\n)\n</code></pre> <p>The generated files are available as a top-level <code>#include &lt;identifiers.hpp&gt;</code>.</p>"},{"location":"reference/module/modm-build-scons/#information-tool","title":"Information Tool","text":"<p>Our <code>info</code> SCons tool generates a set of header files containing information about the repository state.</p> <p>A call to <code>env.InfoGit(with_status={True, False})</code> will generate a <code>&lt;info_git.h&gt;</code> header file and add these two defines to the command line CPP options:</p> <ul> <li><code>MODM_GIT_INFO</code></li> <li><code>MODM_GIT_STATUS</code>: defined only if called with <code>with_state=True</code>.</li> </ul> <p>You can enable this by setting the <code>modm:build:info.git</code> option.</p> <p>Increased build time</p> <p>Since the git repository status can change at any time, it needs to be checked on every build. This adds less than a second to every build.</p> <p>A call to <code>env.InfoBuild()</code> will generate a <code>&lt;info_build.h&gt;</code> header file and add this define to the command line CPP options:</p> <ul> <li><code>MODM_BUILD_INFO</code></li> </ul> <p>You can enable this by setting the <code>modm:build:info.build</code> option.</p> <p>Respect developers privacy</p> <p>This information is placed into the firmware in cleartext, so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need!</p>"},{"location":"reference/module/modm-build-scons/#bitmap-tool","title":"Bitmap Tool","text":"<p>If the <code>modm:build:image.source</code> is defined as a path, it'll be searched for <code>.pbm</code> files to convert into C++ data files using the <code>bitmap</code> tool:</p> <pre><code>source, header = env.Bitmap(bpm_file)\n</code></pre> <p>See the <code>GraphicsDisplay::drawImage()</code> method in the <code>modm:ui:display</code> module for how to use these generated files. The directory is added to the include search paths, so the generated files can be accessed as <code>#include &lt;image.hpp&gt;</code>.</p>"},{"location":"reference/module/modm-build-scons/#options","title":"Options","text":""},{"location":"reference/module/modm-build-scons/#cache_dir","title":"cache_dir","text":"<p>Path to SConstruct CacheDir</p> <p>If value is <code>$cache</code>, the cache is placed into the top-level <code>build/</code> folder. You can disable CacheDir by setting an empty string.</p> <p>Default: <code>[]</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-build-scons/#include_sconstruct","title":"include_sconstruct","text":"<p>Generate a SConstruct file</p> <p>This overwrites any top-level <code>SConstruct</code> file!</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-build-scons/#pathartifact","title":"path.artifact","text":"<p>Path to Artifact Store</p> <p>The artifact folder contains ELF files named by their GNU build id hash. This allows identification of firmware on the device via serial output and is useful for archiving or post-mortem debugging.</p> <p>Default: <code>artifacts</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-build-scons/#collectors","title":"Collectors","text":""},{"location":"reference/module/modm-build-scons/#flag_format","title":"flag_format","text":"<p>Formatting compile flags for SCons</p> <p>Inputs: <code>[Callable]</code></p>"},{"location":"reference/module/modm-build-scons/#pathtools","title":"path.tools","text":"<p>SCons tool paths to be added to the Environment</p> <p>Inputs: <code>[Path]</code></p>"},{"location":"reference/module/modm-build-scons/#tools","title":"tools","text":"<p>SCons tools to be added to the Environment</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/","title":"Build System Generators","text":"<p>lbuild module: <code>modm:build</code></p> <p>This parent module defines a common set of functionality that is independent of the specific build system generator implementation. This includes straight-forward options like project name and build path but also more complicated configuration for programming your target via AvrDude or OpenOCD and debugging via GDB.</p> <p>Note that this module does not compile your project, you will need to choose the <code>modm:build:scons</code> or <code>modm:build:cmake</code> submodule for that, or provide your own build system.</p>"},{"location":"reference/module/modm-build/#compiler-options","title":"Compiler Options","text":"<p>We maintain a common set of compiler options for all build system generator, so that they all have feature parity. We currently only support compiling modm with GCC for AVR, ARM Cortex-M and x86/posix with the options mentioned in the offical GCC options documentation.</p> <p>You can find all compiler options inside the generated build script for your project, the options presented here are only the most important ones.</p>"},{"location":"reference/module/modm-build/#shared-for-c-and-c","title":"Shared for C and C++","text":"<ul> <li><code>-W{all, extra}</code>: a basic set of warnings.</li> <li><code>-Werror={format, maybe-uninitialized, overflow, sign-compare}</code>: these warnings are treated as errors.</li> <li><code>-f{data, function}-sections</code>: puts data and functions into their own linker section.</li> <li><code>-funsigned-{char, bitfields}</code>: modm tries to use <code>stdint.h</code> types everywhere, but just in case.</li> <li><code>-fwrapv</code>: integer overflows wrap around according to 2s complement.</li> </ul> <p>For release builds:</p> <ul> <li><code>-Os</code>: optimize for smaller size.</li> </ul> <p>For debug builds:</p> <ul> <li><code>-Og</code>: optimize for debugging experience.</li> <li><code>MODM_DEBUG_BUILD</code>: this macro is only defined in debug profile. You can use                       it with <code>#ifdef MODM_DEBUG_BUILD</code> to enable debug code.</li> </ul>"},{"location":"reference/module/modm-build/#only-c","title":"Only C","text":"<ul> <li><code>-std=gnu2x</code>: use C23 with GNU extensions (for <code>asm volatile</code>).</li> </ul>"},{"location":"reference/module/modm-build/#only-c_1","title":"Only C++","text":"<ul> <li><code>-std=c++23</code>: use C++23</li> </ul> <p>For exception and RTTI flags, see <code>modm:stdc++</code> module.</p>"},{"location":"reference/module/modm-build/#linker","title":"Linker","text":"<ul> <li><code>--gc-section</code>: garbage collecting sections throws out a lot of unused data/code.</li> <li><code>-L{linkdir} -Tlinkerscript.ld</code>: modm uses a custom linkerscript.</li> </ul> <p>For target specific flags, see the <code>modm:platform:core</code> and related modules.</p>"},{"location":"reference/module/modm-build/#configuration","title":"Configuration","text":"<p>This module generates a common set of configuration files that are used by the common tooling. Please note that these files are the foundation of more extensive tooling available as Python scripts which are then again wrapped by your chosen build system for convenience.</p>"},{"location":"reference/module/modm-build/#openocd","title":"OpenOCD","text":"<p>For accessing your ARM Cortex-M based device, we use OpenOCD by default and generate a <code>modm/openocd.cfg</code> file with the target specific configuration:</p> <ul> <li>Search directories passed via the <code>path.openocd</code> collector.</li> <li>User configuration files passed via the <code>openocd.source</code> collector.   Your custom <code>modm:build:openocd.cfg</code> is added here too.</li> </ul> <p>You need to start openocd with this configuration file:</p> <pre><code>openocd -f modm/openocd.cfg\n</code></pre> <p>Be careful attaching to a running target</p> <p>The OpenOCD implementation halts the target at least while the device's debug peripheral is initialized. Only connect to systems that cannot create any damage while being halted! For example halting motor controllers may damage motors!!</p>"},{"location":"reference/module/modm-build/#avrdude","title":"AvrDude","text":"<p>Unfortunately AvrDude does not support a project-specific configuration file like OpenOCD does (only a undocumented user config in <code>~/.avrduderc</code>), so there is no convenient one-line command to issue. You have to use the wrapper support of the specific build system or simply call AvrDude yourself via its command line.</p>"},{"location":"reference/module/modm-build/#gdb","title":"GDB","text":"<p>A few commands are provided for convenience via the <code>modm/gdbinit</code> configuration:</p> <ul> <li><code>reset</code>: resets the device and halts.</li> <li><code>rerun</code>: resets the device and continues execution.</li> <li><code>modm_coredump</code>: Dumps all volatile memories into a <code>coredump.txt</code> file.                    See the <code>modm:platform:fault</code> module for details.</li> <li><code>modm_build_id</code>: Finds and prints the GNU build id of the firmware.</li> </ul> <p>GDB continues running the target after attaching, but does not load an ELF file! Please pass the ELF file as a command line argument.</p> <p>You can start your GDB session like so:</p> <pre><code>arm-none-eabi-gdb -x modm/gdbinit path/to/project.elf\n</code></pre>"},{"location":"reference/module/modm-build/#generic-python-tools","title":"Generic Python Tools","text":"<p>We have written a number of pure Python tools to provide common functionality that get wrapped by the build system.</p> <p>Here is a selection of tools that have a command line interface, so you can call them even without build system support in case you have a special setup. Note that there are even more tools that can be called in Python only, so have a look in your generated <code>modm/modm_tools</code> folder.</p> <p>Add <code>modm_tools</code> to your Python path</p> <p>To call <code>modm_tools</code> via module syntax, you need to add the generated modm folder to your Python path: <code>export PYTHONPATH=path/to/generated/modm</code>. You can also use the module in this repository directly.</p>"},{"location":"reference/module/modm-build/#avrdude_1","title":"AvrDude","text":"<p>This tool simply wraps the <code>avrdude</code> command to provide two features:</p> <ul> <li>guessing the serial port when a baudrate was set.</li> <li>inspecting the ELF file to decide whether EEPROM needs to be programmed.</li> </ul> <pre><code>python3 -m modm_tools.avrdude -p m328p -c arduino -P auto -b 57600 \\\\\n                              path/to/project.elf\n</code></pre> <p>Fuses stored in the ELF file can be programmed by passing <code>--fuse</code> arguments:</p> <pre><code>python3 -m modm_tools.avrdude -p m328p -c stk500v2 path/to/project.elf \\\\\n                              --fuse hfuse --fuse lfuse --fuse efuse\n</code></pre> <p>(* only AVR targets)</p>"},{"location":"reference/module/modm-build/#openocd_1","title":"OpenOCD","text":"<p>Simply wraps OpenOCD and issues the right command to program the target.</p> <pre><code>python3 -m modm_tools.openocd -f modm/openocd.cfg path/to/project.elf\n</code></pre> <p>You can also reset the target:</p> <pre><code>python3 -m modm_tools.openocd -f modm/openocd.cfg --reset\n</code></pre> <p>You can use a different OpenOCD binary by setting the <code>MODM_OPENOCD_BINARY</code> environment variable before calling this script. This can be useful when using a custom OpenOCD build for specific targets.</p> <pre><code>export MODM_OPENOCD_BINARY=/path/to/other/openocd\n</code></pre> <p>(* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build/#black-magic-probe","title":"Black Magic Probe","text":"<p>This tool wraps GDB to program an ELF file onto a target connected to a BMP. You can explictly pass the serial port, or let the tool guess it.</p> <pre><code>python3 -m modm_tools.bmp path/to/project.elf\n# or choose the port explicitly\npython3 -m modm_tools.bmp path/to/project.elf -p /dev/tty.usbserial-123\n</code></pre> <p>You can also reset the target:</p> <pre><code>python3 -m modm_tools.bmp --reset\n</code></pre> <p>(* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build/#gdb_1","title":"GDB","text":"<p>For debugging your program on ARM Cortex-M device, this Python tool wraps <code>arm-none-eabi-gdb</code> and connects it to a number of programmers running in the background or remotely.</p> <p>The tool can be called from the command line. Here is a typical use-case using the openocd backend with the common configuration files:</p> <pre><code>python3 -m modm_tools.gdb --elf path/to/project.elf --ui=tui \\\n                          -x modm/gdbinit -x modm/openocd_gdbinit \\\n                          openocd -f modm/openocd.cfg\n</code></pre> <p>Or you can call the Python API directly:</p> <pre><code>import sys\nsys.path.append(\"modm\")\nfrom modm_tools import gdb\nfrom modm_tools.openocd import OpenOcdBackend\n\nbackend = OpenOcdBackend(config=\"modm/openocd.cfg\")\ngdb.call(source=\"path/to/project.elf\", backend=backend,\n         config=[\"modm/gdbinit\", \"modm/openocd_gdbinit\"], ui=\"tui\")\n</code></pre> <p>This configuration starts the OpenOCD process in the background for you, however, if you want to connect to an already running process, you can use the remote backend with the <code>--host={ip or hostname}</code> via the command line:</p> <pre><code># Extended-Remote running remotely\npython3 -m modm_tools.gdb --elf path/to/project.elf -x modm/gdbinit --ui=tui \\\n                          remote --host 123.45.67.89\n</code></pre> <p>Note that you can use different programmer backends to GDB, for example the Black Magic Probe:</p> <pre><code># Black Magic Probe\npython3 -m modm_tools.gdb --elf path/to/project.elf -x modm/gdbinit --ui=tui \\\n                          bmp --port /dev/tty.usbserial-123\n</code></pre> <p>To analyze a core dump, you can use the <code>CrashDebug</code> GDB backend. See the <code>modm:crashcatcher</code> module for details.</p> <pre><code># Using CrashDebug for Post-Mortem debugging\npython3 -m modm_tools.gdb --elf path/to/project.elf -x modm/gdbinit --ui=tui \\\n                          crashdebug --dump coredump.txt\n</code></pre> <p>(* only ARM Cortex-M targets)</p> <p>Currently three UIs are implemented for debugging:</p> <ul> <li><code>--ui=cmd</code>: No UI, only the GDB command shell.</li> <li><code>--ui=tui</code>: Text-based UI in your shell.</li> <li><code>--ui=gdbgui</code>: Web-based UI in your browser, based on gdbgui.</li> </ul>"},{"location":"reference/module/modm-build/#text-ui","title":"Text UI","text":"<p>This UI is builtin to GDB and is therefore always available.</p> <pre><code>   \u250c\u2014\u2014main.cpp\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2510\n  &gt;\u2502194             DRAW(x+1, y+3);                                  \u2502\n   \u2502195             DRAW(x+2, y+3);                                  \u2502\n   \u2502196     #else                                                    \u2502\n   \u2502197             DRAW(x  , y  );                                  \u2502\n   \u2502198     #endif                                                   \u2502\n   \u2502199     #undef DRAW                                              \u2502\n   \u2502200     }                                                        \u2502\n   \u2502201                                                              \u2502\n   \u2502202     static inline void drawScreen(framebuffer_t before, frame\u2502\n   \u2514\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2518\n  &gt;\u25020x80017a0 &lt;game_of_life()+1692&gt; strh.w r3, [r4, r12, lsl #1]     \u2502\n   \u25020x80017a4 &lt;game_of_life()+1696&gt; add    r0, lr                    \u2502\n   \u25020x80017a6 &lt;game_of_life()+1698&gt; ldr    r2, [r2, #0]              \u2502\n   \u25020x80017a8 &lt;game_of_life()+1700&gt; strh.w r3, [r2, r0, lsl #1]      \u2502\n   \u25020x80017ac &lt;game_of_life()+1704&gt; ldr    r3, [sp, #12]             \u2502\n   \u25020x80017ae &lt;game_of_life()+1706&gt; ldr    r2, [sp, #0]              \u2502\n   \u25020x80017b0 &lt;game_of_life()+1708&gt; add    r2, r3                    \u2502\n   \u25020x80017b2 &lt;game_of_life()+1710&gt; ldrb   r3, [r7, r1]              \u2502\n   \u25020x80017b4 &lt;game_of_life()+1712&gt; strb   r3, [r2, r1]              \u2502\n   \u2514\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2518\nextended-r Remote target In: game_of_life         L194  PC: 0x80017a0\n\nProgram received signal SIGINT, Interrupt.\n0x080017a0 in drawPixel (color=&lt;optimized out&gt;, y=42, x=578) at main.c\n(gdb)\n</code></pre> <p>GDB can change terminal configuration</p> <p>Sometimes GDB quits uncleanly and a part of the TUI configuration is not reset, in particular, the terminal may not display carriage returns correctly anymore. In this case, calling <code>stty sane</code> can reset the terminal to its correct rendering state.</p>"},{"location":"reference/module/modm-build/#web-ui","title":"Web UI","text":"<p>This UI simply uses the gdbgui project and works very well as an advanced IDE-independent debugging solution.</p> <p></p>"},{"location":"reference/module/modm-build/#size-report","title":"Size Report","text":"<p>Inspects the ELF file and generates a size report of the static usage of the device's memories. You must pass the available memory segments as a Python dictionary:</p> <pre><code>python3 -m modm_tools.size path/to/project.elf \\\\\n    \"[{'name': 'flash', 'access': 'rx', 'start': 134217728, 'size': 65536}, \\\\\n    {'name': 'sram1', 'access': 'rwx', 'start': 536870912, 'size': 20480}]\"\n\nProgram:   1.4 KiB /  64.0 KiB (2.2% used)\n(.build_id + .fastcode + .fastdata + .hardware_init + .rodata +\n .table.copy.intern + .table.heap + .table.zero.intern + .text + .vector_rom)\n\nData:      3.0 KiB /  20.0 KiB (15.1% used) = 20 B static (0.1%) + 3072 B stack (15.0%)\n(.bss + .fastdata + .stack)\n\nHeap:     17.0 KiB /  20.0 KiB (84.9% available)\n(.heap1)\n</code></pre> <p>(* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build/#information-tool","title":"Information Tool","text":"<p>This tool generates a set of source files containing information about the repository state.</p> <p>You can use the <code>--check-rebuild</code> flag to only write the output file when the information changed. This prevents unnecessary rebuilding and relinking.</p> <p>Respect developers privacy</p> <p>This information is placed into the firmware in cleartext, so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need!</p>"},{"location":"reference/module/modm-build/#git-information","title":"Git Information","text":"<pre><code>python3 -m modm_tools.info -o git_info.c -t git        [--check-rebuild]\npython3 -m modm_tools.info -o git_info.c -t git_status [--check-rebuild]\n</code></pre> <p>The <code>git_info(directory)</code> function returns a dictionary with these values:</p> <ul> <li><code>MODM_GIT_SHA</code>: commit hash: <code>%H</code>.</li> <li><code>MODM_GIT_SHA_ABBR</code>: short commit hash: <code>%h</code>.</li> <li><code>MODM_GIT_SUBJECT</code>: commit subject as text: <code>%s</code>.</li> <li><code>MODM_GIT_AUTHOR</code>: author name: <code>%an</code>.</li> <li><code>MODM_GIT_AUTHOR_EMAIL</code>: author email: <code>%ae</code>.</li> <li><code>MODM_GIT_AUTHOR_DATE</code>: authoring date: <code>%ad</code>.</li> <li><code>MODM_GIT_AUTHOR_DATE_TIMESTAMP</code>: authoring date as Unix timestamp: <code>%at</code>.</li> <li><code>MODM_GIT_COMMITTER</code>: committer name: <code>%cn</code>.</li> <li><code>MODM_GIT_COMMITTER_EMAIL</code>: committer email: <code>%ce</code>.</li> <li><code>MODM_GIT_COMMITTER_DATE</code>: committer date: <code>%cd</code>.</li> <li><code>MODM_GIT_COMMITTER_DATE_TIMESTAMP</code>: committer das as Unix timestamp: <code>%ct</code>.</li> <li><code>MODM_GIT_CONFIG_USER_NAME</code>: local user name: <code>user.name</code>.</li> <li><code>MODM_GIT_CONFIG_USER_EMAIL</code>: local user email: <code>user.email</code>.</li> </ul> <p>The <code>git_info(directory, with_status=True)</code> function returns these additional values:</p> <ul> <li><code>MODM_GIT_MODIFIED</code>: number of modified files: <code>M</code>.</li> <li><code>MODM_GIT_ADDED</code>: number of added files: <code>A</code>.</li> <li><code>MODM_GIT_DELETED</code>: number of deleted files: <code>D</code>.</li> <li><code>MODM_GIT_RENAMED</code>: number of renamed files: <code>R</code>.</li> <li><code>MODM_GIT_COPIED</code>: number of copied files: <code>C</code>.</li> <li><code>MODM_GIT_UNTRACKED</code>: number of untracked files: <code>?</code>.</li> </ul> <p>This example project is showing an unclean repository state with uncommitted changes. This can give you a few hints as to where a firmware came from and help you pinpoint the source of a bug or feature.</p> <pre><code>Local Git User:\nName:  Name Surname\nEmail: name.surname@example.com\nLast Commit:\nSHA:             1b5a9a642857182161a615039c92907e59881614\nAbbreviated SHA: 1b5a9a642\nSubject:         wip\n\nAuthor:\nName:      Name Surname\nEmail:     name.surname@example.com\nDate:      Tue Jul 17 22:23:20 2018 +0200\nTimestamp: 1531859000\n\nCommitter:\nName:      Name Surname\nEmail:     name.surname@example.com\nDate:      Tue Jul 17 22:23:20 2018 +0200\nTimestamp: 1531859000\n\nFile Status:\nModified:  10\nAdded:     0\nDeleted:   0\nRenamed:   0\nCopied:    0\nUntracked: 6\n</code></pre>"},{"location":"reference/module/modm-build/#build-information","title":"Build Information","text":"<pre><code>python3 -m modm_tools.info -o build_info.c -t build --compiler=gcc [--check-rebuild]\n</code></pre> <p>Generates a files with these values defined as <code>const char *</code> strings:</p> <ul> <li><code>MODM_BUILD_PROJECT_NAME</code>: as defined in the <code>modm:build:project.name</code> option.</li> <li><code>MODM_BUILD_MACHINE</code>: machine information.</li> <li><code>MODM_BUILD_USER</code>: user information.</li> <li><code>MODM_BUILD_OS</code>: OS version string (best effort, may not be useful!).</li> <li><code>MODM_BUILD_COMPILER</code>: compiler information.</li> </ul> <p>Example output on macOS:</p> <pre><code>Project:  build_info\nMachine:  name.local\nUser:     user\nOS:       macOS 10.14.6 (x86_64)\nCompiler: g++-10 10.2.0\n</code></pre>"},{"location":"reference/module/modm-build/#jlink","title":"JLink","text":"<p>Simply wraps JLinkGDBServer and issues the right command to program the target.</p> <pre><code>python3 -m modm_tools.jlink -device STM32F469NI path/to/project.elf\n</code></pre> <p>You can also reset the target:</p> <pre><code>python3 -m modm_tools.jlink -device STM32F469NI --reset\n</code></pre> <p>You can set the <code>MODM_JLINK_BINARY</code> environment variable to point this script to a specific <code>JLinkGDBServer</code> binary:</p> <pre><code>export MODM_JLINK_BINARY=/path/to/other/JLinkGDBServer\n</code></pre> <p>(* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build/#unittest","title":"Unittest","text":"<p>This tools scans a directory for files ending in <code>_test.hpp</code>, extracts their test cases and generates a source file containing the test runner.</p> <pre><code>python3 -m modm_tools.unit_test path/containing/tests path/to/generated_runner.cpp\n</code></pre> <p>Note that the files containing unittests must contain one class that inherits from the <code>unittest::TestSuite</code> class, and test case names must begin with <code>test</code>:</p> <pre><code>class TestClass : public unittest::TestSuite\n{\npublic:\n    void testCase1();\n}\n</code></pre>"},{"location":"reference/module/modm-build/#logging-via-single-wire-output-swo","title":"Logging via Single-Wire Output (SWO)","text":"<p>Logging using the SWO protocol is supported by the <code>modm:platform:itm</code> module. You can use OpenOCD to receive the output, but you must manually supply the CPU frequency:</p> <pre><code>python3 -m modm_tools.itm openocd -f modm/openocd.cfg --fcpu 48000000\n</code></pre> <p>JLink is also supported and can determine the CPU frequency automatically:</p> <pre><code>python3 -m modm_tools.itm jlink -device STM32F469NI\n</code></pre> <p>(* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build/#logging-via-real-time-transport-rtt","title":"Logging via Real-Time Transport (RTT)","text":"<p>Logging using the RTT protocol is supported by the <code>modm:platform:rtt</code> module. You can use OpenOCD to send and receive on a channel of your choice using the built-in Python telnet client:</p> <pre><code>python3 -m modm_tools.rtt --channel 0 openocd -f modm/openocd.cfg\n</code></pre> <p>JLink is also supported and may have faster transfer rates:</p> <pre><code>python3 -m modm_tools.rtt --channel 0 jlink -device STM32F469NI\n</code></pre> <p>(* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build/#gnu-build-id","title":"GNU Build-ID","text":"<p>To extract the build ID from an ELF file:</p> <pre><code>python3 -m modm_tools.build_id path/to/project.elf\nfa8918e6971ed783b25bff0ad11a0541be47a933\n</code></pre> <p>To copy the ELF file to a artifact cache:</p> <pre><code>python3 -m modm_tools.build_id path/to/project.elf --cache path/to/folder\n# copies to `path/to/folder/fa8918e6971ed783b25bff0ad11a0541be47a933.elf`\n</code></pre> <p>(* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build/#bitmap","title":"Bitmap","text":"<p>This tool can convert P1 <code>.pbm</code> files into C++ source code.</p> <pre><code>python3 -m modm_tools.bitmap image.pbm --outpath .\n# creates `image.hpp` and `image.cpp` in the CWD\n</code></pre>"},{"location":"reference/module/modm-build/#uf2-converter","title":"UF2 Converter","text":"<p>UF2 is a Microsoft file format to pass to a on-device bootloader.</p> <pre><code>python3 -m modm_tools.elf2uf2 firmware.elf -o firmware.uf2 --target rp2040 \\\n    --range 0x10000000:0x15000000:CONTENTS \\\n    --range 0x20000000:0x20042000:NO_CONTENTS\n</code></pre> <p>(* only ARM Cortex-M targets)</p>"},{"location":"reference/module/modm-build/#options","title":"Options","text":""},{"location":"reference/module/modm-build/#avrdudebaudrate","title":"avrdude.baudrate","text":"<p>AvrDude programmer baudrate</p> <p>This option is only available for avr.</p> <p>Default: <code>0</code> Inputs: <code>[0 ... +Inf]</code> </p>"},{"location":"reference/module/modm-build/#avrdudeoptions","title":"avrdude.options","text":"<p>AvrDude programmer options</p> <p>This option is only available for avr.</p> <p>Default: <code>\"\"</code> Inputs: <code>[String]</code> </p>"},{"location":"reference/module/modm-build/#avrdudeport","title":"avrdude.port","text":"<p>AvrDude programmer port</p> <p>This option is only available for avr.</p> <p>Default: <code>\"\"</code> Inputs: <code>[String]</code> </p>"},{"location":"reference/module/modm-build/#avrdudeprogrammer","title":"avrdude.programmer","text":"<p>AvrDude programmer</p> <p>This option is only available for avr.</p> <p>Default: <code>\"\"</code> Inputs: <code>[String]</code> </p>"},{"location":"reference/module/modm-build/#buildpath","title":"build.path","text":"<p>Build Path</p> <p>The build path is defaulted to <code>build/{modm:build:project.name}</code>.</p> <p>If you have a lot of embedded projects, you may want to change the build path to a common directory so that you don't have <code>build/</code> folders everywhere. Remember to add your build path to your <code>.gitignore</code>.</p> <p>You should use a relative path instead of an absolute one, so that this option still works for other developers.</p> <p>Default: <code>build/modm</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-build/#imagesource","title":"image.source","text":"<p>Path to directory containing .pbm files</p> <p>Default: <code>[]</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-build/#infobuild","title":"info.build","text":"<p>Generate build state information</p> <p>Default: <code>no</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-build/#infogit","title":"info.git","text":"<p>Generate git repository state information</p> <ul> <li><code>Info</code>: generates information about the last commit.</li> <li><code>Info+Status</code>: like <code>Info</code> plus git file status.</li> </ul> <p>Default: <code>Disabled</code> Inputs: <code>[Disabled, Info, Info+Status]</code> </p>"},{"location":"reference/module/modm-build/#openocdcfg","title":"openocd.cfg","text":"<p>Path to a custom OpenOCD configuration file</p> <p>If you have a custom configuration file for your target, it will get included by the generated <code>modm/openocd.cfg</code>.</p> <p>This is useful for not having to duplicate your config if you have several projects using the same target (like small bring-up and test projects).</p> <p>Do not execute commands by default</p> <p>When providing your own config file, wrap your specific commands into functions and do not execute them by default. A stray <code>init</code> or similar in your script will mess with modm's ability to program and debug a device correctly.</p> <p>This option is only available for rp, sam, stm32.</p> <p>Default: <code>[]</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-build/#projectname","title":"project.name","text":"<p>Project Name</p> <p>The project name defaults to the folder name you're calling lbuild from.</p> <p>It's used by your build system to name the executable and it may also be passed to your application via a string constant or CPP define.</p> <p>Default: <code>modm</code> Inputs: <code>[String]</code> </p>"},{"location":"reference/module/modm-build/#unittestsource","title":"unittest.source","text":"<p>Path to directory containing unittests</p> <p>When this path is declared, the generated build script will compile only the unittests, not your application source code! You must use separate project configurations for compiling your unittest and application!</p> <p>Default: <code>[]</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-build/#collectors","title":"Collectors","text":""},{"location":"reference/module/modm-build/#archflags","title":"archflags","text":"<p>Compiler flags related to the target architecture</p> <p>Flags must start with '-'! See Machine-Dependent Options</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#archflagsdebug","title":"archflags.debug","text":"<p>Compiler flags related to the target architecture (debug profile)</p> <p>Flags must start with '-'! See Machine-Dependent Options</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#archflagsrelease","title":"archflags.release","text":"<p>Compiler flags related to the target architecture (release profile)</p> <p>Flags must start with '-'! See Machine-Dependent Options</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#asflags","title":"asflags","text":"<p>Assembler flags</p> <p>Flags must start with '-'! See Assembler Options</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#asflagsdebug","title":"asflags.debug","text":"<p>Assembler flags (debug profile)</p> <p>Flags must start with '-'! See Assembler Options</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#asflagsrelease","title":"asflags.release","text":"<p>Assembler flags (release profile)</p> <p>Flags must start with '-'! See Assembler Options</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#bossacoptions","title":"bossac.options","text":"<p>Additional BOSSAc options</p> <p>This collector is only available for sam.</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#ccflags","title":"ccflags","text":"<p>Compiler flags for both C and C++ sources</p> <p>Flags must start with '-'! See Options that Control Optimization See Options to Request or Suppress Warnings See Options for Debugging Your Program</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#ccflagsdebug","title":"ccflags.debug","text":"<p>Compiler flags for both C and C++ sources (debug profile)</p> <p>Flags must start with '-'! See Options that Control Optimization See Options to Request or Suppress Warnings See Options for Debugging Your Program</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#ccflagsrelease","title":"ccflags.release","text":"<p>Compiler flags for both C and C++ sources (release profile)</p> <p>Flags must start with '-'! See Options that Control Optimization See Options to Request or Suppress Warnings See Options for Debugging Your Program</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#cflags","title":"cflags","text":"<p>Compiler flags only for C sources</p> <p>Flags must start with '-'! See Options Controlling C Dialect</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#cflagsdebug","title":"cflags.debug","text":"<p>Compiler flags only for C sources (debug profile)</p> <p>Flags must start with '-'! See Options Controlling C Dialect</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#cflagsrelease","title":"cflags.release","text":"<p>Compiler flags only for C sources (release profile)</p> <p>Flags must start with '-'! See Options Controlling C Dialect</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#cppdefines","title":"cppdefines","text":"<p>Preprocessor definitions</p> <p>Accepted values are <code>NAME</code> or <code>NAME=DEFINITION</code>. See <code>-D name=definition</code> in Preprocessor Options</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#cppdefinesdebug","title":"cppdefines.debug","text":"<p>Preprocessor definitions (debug profile)</p> <p>Accepted values are <code>NAME</code> or <code>NAME=DEFINITION</code>. See <code>-D name=definition</code> in Preprocessor Options</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#cppdefinesrelease","title":"cppdefines.release","text":"<p>Preprocessor definitions (release profile)</p> <p>Accepted values are <code>NAME</code> or <code>NAME=DEFINITION</code>. See <code>-D name=definition</code> in Preprocessor Options</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#cxxflags","title":"cxxflags","text":"<p>Compiler flags only for C++ sources</p> <p>Flags must start with '-'! See Options Controlling C++ Dialect</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#cxxflagsdebug","title":"cxxflags.debug","text":"<p>Compiler flags only for C++ sources (debug profile)</p> <p>Flags must start with '-'! See Options Controlling C++ Dialect</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#cxxflagsrelease","title":"cxxflags.release","text":"<p>Compiler flags only for C++ sources (release profile)</p> <p>Flags must start with '-'! See Options Controlling C++ Dialect</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#defaultavrdudebaudrate","title":"default.avrdude.baudrate","text":"<p>Default AvrDude baudrate</p> <p>This collector is only available for avr.</p> <p>Inputs: <code>[0 ... +Inf]</code></p>"},{"location":"reference/module/modm-build/#defaultavrdudeoptions","title":"default.avrdude.options","text":"<p>Default AvrDude options</p> <p>This collector is only available for avr.</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#defaultavrdudeport","title":"default.avrdude.port","text":"<p>Default AvrDude port</p> <p>This collector is only available for avr.</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#defaultavrdudeprogrammer","title":"default.avrdude.programmer","text":"<p>Default AvrDude programmer</p> <p>This collector is only available for avr.</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#gitignore","title":"gitignore","text":"<p>Generated files that need to be ignored by Git</p> <p>Inputs: <code>[Path]</code></p>"},{"location":"reference/module/modm-build/#library","title":"library","text":"<p>Libraries to link against</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#linkflags","title":"linkflags","text":"<p>Linker flags</p> <p>Flags must start with '-'! See Options for Linking</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#linkflagsdebug","title":"linkflags.debug","text":"<p>Linker flags (debug profile)</p> <p>Flags must start with '-'! See Options for Linking</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#linkflagsrelease","title":"linkflags.release","text":"<p>Linker flags (release profile)</p> <p>Flags must start with '-'! See Options for Linking</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#openocdsource","title":"openocd.source","text":"<p>Additional OpenOCD source files</p> <p>You can add multiple source files that will get included by the generated <code>modm/openocd.cfg</code> to provide a default config for targets and boards. You can add source files that are shipped with OpenOCD, for example, <code>board/stm32f469discovery.cfg</code>, or custom source files from your own repository.</p> <p>To avoid name clashes with the built-in config files, you should copy your own source files into a separate folder and add it as a search path:</p> <pre><code>def build(env):\n    # Add a custom folder to the OpenOCD search paths\n    env.collect(\"modm:build:path.openocd\", \"repo/src/openocd/\")\n\n    # Namespace this folder with your repository name to prevent name clashes\n    env.outbasepath = \"repo/src/openocd/repo/board\"\n    env.copy(\"board.cfg\", \"name.cfg\")\n    # Now use a *relative* path to the source file inside this folder\n    env.collect(\"modm:build:openocd.source\", \"repo/board/name.cfg\")\n\n    # Alternatively for a target config\n    env.outbasepath = \"repo/src/openocd/repo/target\"\n    env.copy(\"target.cfg\", \"name.cfg\")\n    env.collect(\"modm:build:openocd.source\", \"repo/target/name.cfg\")\n</code></pre> <p>This collector is only available for rp, sam, stm32.</p> <p>Inputs: <code>[Path]</code></p>"},{"location":"reference/module/modm-build/#pathinclude","title":"path.include","text":"<p>Search path for header files</p> <p>Inputs: <code>[Path]</code></p>"},{"location":"reference/module/modm-build/#pathlibrary","title":"path.library","text":"<p>Search path for static libraries</p> <p>Inputs: <code>[Path]</code></p>"},{"location":"reference/module/modm-build/#pathopenocd","title":"path.openocd","text":"<p>Search path for OpenOCD configuration files.</p> <p>This collector is only available for rp, sam, stm32.</p> <p>Inputs: <code>[Path]</code></p>"},{"location":"reference/module/modm-build/#pkg-config","title":"pkg-config","text":"<p>Packages to configure against</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-build/#queries","title":"Queries","text":""},{"location":"reference/module/modm-build/#avrdude_options","title":"avrdude_options","text":"<p>Merges the default AvrDude options with the user options (* post-build only):</p> <ul> <li><code>avrdude_programmer</code></li> <li><code>avrdude_port</code></li> <li><code>avrdude_baudrate</code></li> <li><code>avrdude_options</code></li> </ul> <p>:returns: options dictionary</p>"},{"location":"reference/module/modm-build/#collect_flags","title":"collect_flags","text":"<p>Scans the collections for module compile flags. Converts them into SCons-compatible names and places them into a dictionary of the form: <code>flags[filename][name][profile] = list(values)</code> (* post-build only).</p> <p>:param env: the post_build step env :param scope_filter: the collection scope filter :returns: compile flags dictionary</p>"},{"location":"reference/module/modm-build/#device","title":"device","text":"<p>Extracts common properties from a modm:target device:</p> <ul> <li>platform</li> <li>family</li> <li>partname</li> <li>core</li> <li>mcu (AVR only)</li> </ul> <p>:returns: a dictionary of common properties.</p>"},{"location":"reference/module/modm-build/#memories","title":"memories","text":"<p>Extracts the memory map of the device. A memory region is a dictionary containing:</p> <ul> <li><code>name</code> of region</li> <li><code>start</code> address of region</li> <li><code>size</code> of region</li> <li><code>access</code> of region</li> </ul> <p>:returns: a list of memory regions.</p>"},{"location":"reference/module/modm-build/#source_files","title":"source_files","text":"<p>Builds a list of files that need to be compiled per repository (* post-build only).</p> <p>:returns: a dictionary of sorted lists of filenames, keyed by repository.</p>"},{"location":"reference/module/modm-cmsis-core/","title":"ARM CMSIS-CORE","text":"<p>lbuild module: <code>modm:cmsis:core</code></p> <p>This module provides these files for accessing the ARM Cortex-M CPU and peripherals:</p> <ul> <li><code>cmsis_gcc.h</code>: Contains the GCC-specific API.</li> <li><code>core_cm{core}.h</code>: Contains the core-specific API.</li> </ul> <p>Please see the API documentation for their content and how to use them.</p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-device-rp2040/","title":"modm:cmsis:device","text":"<p>lbuild module: <code>modm:cmsis:device</code></p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-cmsis-device-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:device modm_cmsis_device modm: cmsis: device modm_cmsis_core modm: cmsis: core modm_cmsis_device-&gt;modm_cmsis_core </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-device-sam/","title":"modm:cmsis:device","text":"<p>lbuild module: <code>modm:cmsis:device</code></p> <p>This module is only available for sam.</p>"},{"location":"reference/module/modm-cmsis-device-sam/#queries","title":"Queries","text":""},{"location":"reference/module/modm-cmsis-device-sam/#clock-map","title":"clock-map","text":""},{"location":"reference/module/modm-cmsis-device-sam/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:device modm_cmsis_device modm: cmsis: device modm_cmsis_core modm: cmsis: core modm_cmsis_device-&gt;modm_cmsis_core </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-device-stm32/","title":"STM32 CMSIS Headers","text":"<p>lbuild module: <code>modm:cmsis:device</code></p> <p>This module wraps the CMSIS headers for STM32 devices and provides the header file and CPP definitions for accessing the <code>modm:target</code> peripherals. Specifically, it copies the target header file which provides the CMSIS implementation of the target's language interface for its memory-mapped peripherals.</p> <p>Discrepancies between documentation and headers</p> <p>These CMSIS headers should reflect what's written in the documentation, however, in our experience there may be small differences in naming, behavior and availability between it and this implementation.</p> <p>The generated header file <code>modm/platform/device.hpp</code> contains the necessary target define <code>STM32{FAMILY}{NAME}xx</code> or similar and includes the <code>modm:target</code>-specific header.</p> <p>Include only <code>modm/platform/device.hpp</code>!</p> <p>This file is only included by interface implementations inside the <code>modm/platform</code> folder! If you need to implement your own drivers, include only this file.</p>"},{"location":"reference/module/modm-cmsis-device-stm32/#cmsis-compliance","title":"CMSIS Compliance","text":"<p>modm implements the target specific CMSIS functionality itself, without using the CMSIS interface. This is necessary to provide similar functionality on non-Cortex-M based targets.</p> <ul> <li><code>uint32_t SystemCoreClock</code> contains an up-to-date value of CPU frequency.</li> <li><code>void SystemCoreClockUpdate()</code> does nothing, it's a weak empty function.</li> <li><code>void SystemInit()</code> is undefined: modm defines its own startup   architecture, see the <code>modm:platform:core</code> module for details.</li> </ul>"},{"location":"reference/module/modm-cmsis-device-stm32/#debugging-peripherals","title":"Debugging Peripherals","text":"<p>When debugging with GDB, it can sometimes be difficult to access peripherals, due to the CMSIS implementation with CPP defines and GCC optimization flags. Depending on these circumstances, GDB may only \"see\" a peripheral in a certain context, which can make the debugging experience quite frustrating.</p> <p>To aid this, we generate a linkerscript fragment and source file, which place the peripherals memory as real objects in the peripheral memory space. You can then access these peripherals inside GDB at any time, regardless of context and build profile setting:</p> <pre><code>(gdb) p/x *GPIOB\n$1 = {\n  MODER = 0xaa0280,\n  OTYPER = 0x300,\n  OSPEEDR = 0x2a00c0,\n  PUPDR = 0x400100,\n  IDR = 0xfd0,\n  ODR = 0x100,\n  BSRR = 0x0,\n  LCKR = 0x0,\n  AFR = {0x0, 0x7744}\n}\n</code></pre> <p>This does not have any effect on your firmware! It is purely a debug helper feature and none of these definitions make it into the executable.</p> <p>Beware read/write side-effects</p> <p>When debugging be aware of the side-effects that your read or write to a peripheral memory location can have. It's fairly obvious that a write may have consequences, but also reads can modify peripheral state, for example, a hardware FIFO buffer may pop the queue if your read the top of it.</p> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-cmsis-device-stm32/#queries","title":"Queries","text":""},{"location":"reference/module/modm-cmsis-device-stm32/#headers","title":"headers","text":"<p>Gives information about the STM32 header files. For example the STM32F469:</p> <ul> <li>family_define: <code>STM32F4</code></li> <li>define: <code>STM32F469xx</code></li> <li>core_header: <code>core_cm4.h</code></li> <li>system_header: <code>system_stm32f4xx.h</code></li> <li>family_header: <code>stm32f4xx.h</code></li> <li>device_header: <code>stm32f469xx.h</code></li> </ul> <p>:returns: a dictionary with the above keys</p>"},{"location":"reference/module/modm-cmsis-device-stm32/#peripherals","title":"peripherals","text":"<p>All peripherals translated to the modm naming convention.</p> <p>:returns: a sorted list of all peripheral names.</p>"},{"location":"reference/module/modm-cmsis-device-stm32/#rcc-map","title":"rcc-map","text":"<p>Finds all CMSIS bit fields related to enabling and resetting peripherals in the RCC of the format <code>RCC_(REGISTER)_(PERIPHERAL)_(TYPE)</code> where:</p> <ul> <li>REGISTER: a variation of <code>(BUS)(ID?)(ENR|RSTR)</code>, e.g. <code>AHB1ENR</code></li> <li>PERIPHERAL: typical peripheral name, e.g. <code>GPIOA</code></li> <li>TYPE: either <code>EN</code> or <code>RST</code>.</li> </ul> <p>:returns: a 2D-dictionary: <code>map[PERIPHERAL][TYPE] = REGISTER</code></p>"},{"location":"reference/module/modm-cmsis-device-stm32/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:device modm_cmsis_device modm: cmsis: device modm_cmsis_core modm: cmsis: core modm_cmsis_device-&gt;modm_cmsis_core </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-basic_math/","title":"DSP Basic Math","text":"<p>lbuild module: <code>modm:cmsis:dsp:basic_math</code></p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-bayes/","title":"DSP Bayes","text":"<p>lbuild module: <code>modm:cmsis:dsp:bayes</code></p>"},{"location":"reference/module/modm-cmsis-dsp-bayes/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:dsp:bayes modm_cmsis_dsp_bayes modm: cmsis: dsp: bayes modm_cmsis_dsp_statistics modm: cmsis: dsp: statistics modm_cmsis_dsp_bayes-&gt;modm_cmsis_dsp_statistics </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-complex_math/","title":"DSP Complex Math","text":"<p>lbuild module: <code>modm:cmsis:dsp:complex_math</code></p>"},{"location":"reference/module/modm-cmsis-dsp-complex_math/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:dsp:complex_math modm_cmsis_dsp_complex_math modm: cmsis: dsp: complex_math modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_complex_math-&gt;modm_cmsis_dsp_fast_math </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-controller/","title":"DSP Controller","text":"<p>lbuild module: <code>modm:cmsis:dsp:controller</code></p>"},{"location":"reference/module/modm-cmsis-dsp-controller/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:dsp:controller modm_cmsis_dsp_controller modm: cmsis: dsp: controller modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_controller-&gt;modm_cmsis_dsp_tables </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-distance/","title":"DSP Distance","text":"<p>lbuild module: <code>modm:cmsis:dsp:distance</code></p>"},{"location":"reference/module/modm-cmsis-dsp-distance/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:dsp:distance modm_cmsis_dsp_distance modm: cmsis: dsp: distance modm_cmsis_dsp_basic_math modm: cmsis: dsp: basic_math modm_cmsis_dsp_distance-&gt;modm_cmsis_dsp_basic_math modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_distance-&gt;modm_cmsis_dsp_fast_math modm_cmsis_dsp_statistics modm: cmsis: dsp: statistics modm_cmsis_dsp_distance-&gt;modm_cmsis_dsp_statistics modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_distance-&gt;modm_cmsis_dsp_tables </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-fast_math/","title":"DSP Fast Math","text":"<p>lbuild module: <code>modm:cmsis:dsp:fast_math</code></p>"},{"location":"reference/module/modm-cmsis-dsp-fast_math/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:dsp:fast_math modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_fast_math-&gt;modm_cmsis_dsp_tables </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-filtering/","title":"DSP Filtering","text":"<p>lbuild module: <code>modm:cmsis:dsp:filtering</code></p>"},{"location":"reference/module/modm-cmsis-dsp-filtering/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:dsp:filtering modm_cmsis_dsp_filtering modm: cmsis: dsp: filtering modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_filtering-&gt;modm_cmsis_dsp_fast_math modm_cmsis_dsp_support modm: cmsis: dsp: support modm_cmsis_dsp_filtering-&gt;modm_cmsis_dsp_support modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_filtering-&gt;modm_cmsis_dsp_tables </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-interpolation/","title":"DSP Interpolation","text":"<p>lbuild module: <code>modm:cmsis:dsp:interpolation</code></p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-matrix/","title":"DSP Matrix","text":"<p>lbuild module: <code>modm:cmsis:dsp:matrix</code></p>"},{"location":"reference/module/modm-cmsis-dsp-matrix/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:dsp:matrix modm_cmsis_dsp_matrix modm: cmsis: dsp: matrix modm_cmsis_dsp_basic_math modm: cmsis: dsp: basic_math modm_cmsis_dsp_matrix-&gt;modm_cmsis_dsp_basic_math modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_matrix-&gt;modm_cmsis_dsp_fast_math </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-quaternion_math/","title":"DSP Quaternion Math","text":"<p>lbuild module: <code>modm:cmsis:dsp:quaternion_math</code></p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-statistics/","title":"DSP Statistics","text":"<p>lbuild module: <code>modm:cmsis:dsp:statistics</code></p>"},{"location":"reference/module/modm-cmsis-dsp-statistics/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:dsp:statistics modm_cmsis_dsp_statistics modm: cmsis: dsp: statistics modm_cmsis_dsp_basic_math modm: cmsis: dsp: basic_math modm_cmsis_dsp_statistics-&gt;modm_cmsis_dsp_basic_math modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_statistics-&gt;modm_cmsis_dsp_fast_math </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-support/","title":"DSP Support","text":"<p>lbuild module: <code>modm:cmsis:dsp:support</code></p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-svm/","title":"DSP Svm","text":"<p>lbuild module: <code>modm:cmsis:dsp:svm</code></p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-tables/","title":"DSP Tables","text":"<p>lbuild module: <code>modm:cmsis:dsp:tables</code></p>"},{"location":"reference/module/modm-cmsis-dsp-tables/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:dsp:tables modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_transform modm: cmsis: dsp: transform modm_cmsis_dsp_tables-&gt;modm_cmsis_dsp_transform </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-transform/","title":"DSP Transform","text":"<p>lbuild module: <code>modm:cmsis:dsp:transform</code></p>"},{"location":"reference/module/modm-cmsis-dsp-transform/#dependencies","title":"Dependencies","text":"<p> modm:cmsis:dsp:transform modm_cmsis_dsp_transform modm: cmsis: dsp: transform modm_cmsis_dsp_basic_math modm: cmsis: dsp: basic_math modm_cmsis_dsp_transform-&gt;modm_cmsis_dsp_basic_math modm_cmsis_dsp_complex_math modm: cmsis: dsp: complex_math modm_cmsis_dsp_transform-&gt;modm_cmsis_dsp_complex_math modm_cmsis_dsp_matrix modm: cmsis: dsp: matrix modm_cmsis_dsp_transform-&gt;modm_cmsis_dsp_matrix modm_cmsis_dsp_statistics modm: cmsis: dsp: statistics modm_cmsis_dsp_transform-&gt;modm_cmsis_dsp_statistics modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_transform-&gt;modm_cmsis_dsp_tables </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp-window/","title":"DSP Window","text":"<p>lbuild module: <code>modm:cmsis:dsp:window</code></p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis-dsp/","title":"ARM CMSIS-DSP","text":"<p>lbuild module: <code>modm:cmsis:dsp</code></p> <p>This module provides the CMSIS-DSP library. Please see the API documentation for details.</p> <p>Note: - The library should be accessed through the <code>arm_math.h</code> and <code>arm_math_f16.h</code> headers, as these include necessary configuration options. - This module splits up the library into submodules to speed up compilation by only including the math functions you really need. - You can enable 16-bit floating point support via the option <code>with_f16</code>.</p>"},{"location":"reference/module/modm-cmsis-dsp/#configuration","title":"Configuration","text":"<p>You can define your own configuration in the <code>&lt;arm_math_local.h&gt;</code> file which will automatically be included at the beginning of the <code>arm_math.h</code> and <code>arm_math_f16.h</code> files. This way changes to your CMSIS-DSP configuration will only affect its source files and not recompile your whole project.</p> <p>Example <code>&lt;arm_math_local.h&gt;</code> configuration:</p> <pre><code>// Check the input and output sizes of matrices\n#define ARM_MATH_MATRIX_CHECK 1\n// enable manual loop unrolling in DSP functions\n#define ARM_MATH_LOOPUNROLL 1\n</code></pre>"},{"location":"reference/module/modm-cmsis-dsp/#options","title":"Options","text":""},{"location":"reference/module/modm-cmsis-dsp/#with_f16","title":"with_f16","text":"<p>Include f16 format functions</p> <p>16-bit floating point is only used for storage, since the Cortex-M FPU does not support the format in hardware.</p> <p>Default: <code>no</code> Inputs: <code>[yes, no]</code> </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-cmsis/","title":"ARM CMSIS Support","text":"<p>lbuild module: <code>modm:cmsis</code></p> <p>The Cortex Microcontroller Software Interface Standard is a software standard by ARM that defines a number of foundational interfaces for Cortex-M microcontrollers.</p>  ![][overview]  <p>We use only use these parts of CMSIS:</p> <ul> <li>The <code>modm:cmsis:core</code> module provides access to the ARM Cortex-M peripherals   via CMSIS-CORE.</li> <li>The <code>modm:cmsis:device</code> module provides access to the peripherals of the   <code>modm:target</code> devices via the vendor's CMSIS implementation.</li> <li>The <code>modm:cmsis:dsp</code> module provides an optimized compute library via   CMSIS-DSP.</li> </ul> <p>This module is only available for rp, sam, stm32.</p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-communication-amnb/","title":"Asynchronous Multi-Node Bus (AMNB)","text":"<p>lbuild module: <code>modm:communication:amnb</code></p> <p>The AMNB (Asynchronous Multi-Node Bus) is a RPC communication system over a shared half-duplex UART bus. It is intended as a low-cost replacement for higher level protocols like CAN or Ethernet, which are not available in every device unlike UART.</p> <p>A node can provide two communication services, each with an 8-bit ID:</p> <ul> <li>publish/subscribe: sent to everyone and received by anyone.</li> <li>request/response: sent to one node which then sends a response.</li> </ul> <p>Messages support up to 28 bytes of in-place data, and up to 8kB of heap data and are protected with 8-bit and 16-bit CCIT CRC sums. The receiving node can refuse to allocate any data, which will discard messages with &gt;28B payload, or define a dynamic allocation threshold (for example &lt;=1kB) above which the message will also be refused. This allows devices with very little RAM resources to share the same bus and same protocol as larger devices.</p> <p>Nodes are identified with a unique 8-bit address. The protocol does not define a central node, so any node can initiate communication as arbitration is provided via a CSMA/CD mechanism, with the retransmission count and backoff time controlled by the service ID, with higher IDs having higher priority.</p> <p>Data serialization is done by copying their memory representation and are described as C/C++ types which must be available for both the sender and receiver, for example, in the form of shared header files. The types must be trivially constructable, since no constructor (or destructor) is called.</p>"},{"location":"reference/module/modm-communication-amnb/#electrical-configuration","title":"Electrical Configuration","text":"<p>The protocol requires an open-drain + pullup config on the UART TX pin and an input + pullup config on the RX pin. Additionally, a loopback from TX to RX is required so that collisions can be detected.</p> <p>There are three bus configurations:</p> <ol> <li>Some UART peripherals have a built-in half-duplex mode, where the TX/RX pins    are connected internally. The bus is just one pin now with an external pullup    or if you use internal pullups with a slow baudrate, zero external    components.</li> </ol> <pre><code> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502  Node  \u2502  \u2502  Node  \u2502  \u2502  Node  \u2502\n \u2502  TxRx  \u2502  \u2502  TxRx  \u2502  \u2502  TxRx  \u2502\n \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li>Alternately you can connect all TX pins and RX pins together in two separate    lines and use a diode from RX -&gt;- TX to create the loopback with    internal or external pullups:</li> </ol> <pre><code> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502  Node  \u2502  \u2502  Node  \u2502  \u2502  Node  \u2502\n \u2502 Tx  Rx \u2502  \u2502 Tx  Rx \u2502  \u2502 Tx  Rx \u2502\n \u2514\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2518  \u2514\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2518  \u2514\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2518\n   \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2518\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2500\u25c4\u2500\u2518  &lt;- diode\n</code></pre> <ol> <li>And lastly you can use a differential transceiver with automatic direction    control (like a CAN transceiver) to connect nodes that are further away.    Note that you can still connect local nodes before the transceiver (but    without the diode now):</li> </ol> <pre><code> \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502  Node  \u2502  \u2502  Node  \u2502                               \u2502  Node  \u2502\n \u2502 Tx  Rx \u2502  \u2502 Tx  Rx \u2502                               \u2502 Tx  Rx \u2502\n \u2514\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2518  \u2514\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2518  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2514\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2518\n   \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2524 Trans- \u255e\u2550\u2566\u2550\u2566\u2550\u2566\u2550\u2561 Trans- \u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2518\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 ceiver \u255e\u2550\u2569\u2550\u2569\u2550\u2569\u2550\u2561 ceiver \u251c\u2500\u2500\u2500\u2500\u2518\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Note that small glitches on the bus can be interpreted as a UART start condition and will trigger a byte reception. In order to recognize this, the UART must be configured as 8 data bits and 1 even parity bit (9E1)!</p> <pre><code>Uart::initialize&lt;SystemClock, Baudrate&gt;(Uart::Parity::Even, Uart::WordLength::Bit9);\nUart::connect&lt;GpioRx::Rx, GpioTx::Tx&gt;(Gpio::InputType::PullUp, Gpio::OutputType::OpenDrain);\nGpioTx::configure(Gpio::InputType::PullUp); // if using internal pullups\n</code></pre>"},{"location":"reference/module/modm-communication-amnb/#subscription-and-response-handlers","title":"Subscription and Response Handlers","text":"<p>A list of the types <code>modm::amnb::Listener</code> and <code>modm::amnb::Action</code> store the callbacks for the IDs you want to subscribe to. The callbacks store a closure up to size <code>MODM_AMNB_HANDLER_STORAGE</code>, which can be overwritten to increase storage. The argument type is deduced from the callback's signature and it must match the message size otherwise the message is discarded.</p> <p>Data lifetime ends after callback</p> <p>The received message is deallocated immediately after all callback have been executed. You must therefore copy any data you want to keep inside the callback.</p> <p>All listeners are given the sender ID as first argument and return nothing. The second argument is optional and may be a type passed as const reference or a const data buffer:</p> <pre><code>using namespace modm::amnb;\n\nListener listeners[] =\n{\n    {0, [](uint8_t sender)\n        {\n            // a broadcast without payload\n        }\n    },\n    {1, [](uint8_t sender, const ArgumentType&amp; arg)\n        {\n            // a broadcast with an argument\n        }\n    },\n    {2, [obj_ptr](uint8_t sender, const uint8_t *data, size_t length)\n        {\n            // a broadcast with a variable length memory buffer\n            // forward to member function of a specific object\n            obj_ptr-&gt;member_function(sender, data, length);\n        }\n    },\n    // You can have multiple listeners on the same ID *with a closure*\n    {0, [count = uint32_t(0)](uint8_t sender) mutable\n        {\n            // keeps track how many times it has been published\n            MODM_LOG_DEBUG \"ID0 count=\" &lt;&lt; count++ &lt;&lt; modm::endl;\n        }\n    },\n};\n</code></pre> <p>Actions don't know the sender, and are passed either nothing, a const argument reference or a const data buffer. They can return a <code>modm::amnb::Response</code> with an optional return type, or a <code>modm::amnb::ErrorResponse</code> with an optional user error type. Not returning anything still sends an implicit (good) Response.</p> <pre><code>using namespace modm::amnb;\n\nAction actions[] =\n{\n    {0, []\n        {\n            // request without payload, automatic good reponse\n        }\n    },\n    {1, [] -&gt; Response\n        {\n            // return user error or response without payloads\n            return failure ? ErrorReponse() : Response();\n        }\n    },\n    {2, [](const ArgumentType&amp; arg) -&gt; Response\n        {\n            // return user return type\n            ReturnType return_arg = ...;\n            return return_arg;\n        }\n    },\n    {3, [](const uint8_t *data, size_t length) -&gt; Response\n        {\n            // return user error code\n            return ErrorResponse(UserErrorType());\n        }\n    },\n};\n</code></pre>"},{"location":"reference/module/modm-communication-amnb/#publish-and-request-node","title":"Publish and Request Node","text":"<p>The node class manages the whole stack via its <code>update()</code> function which must be called in the main loop continuously.</p> <p>To broadcast, the <code>node.broadcast(id, args)</code> function places the message in the transmit queue, the size of which you can control. It returns false if the queue is full.</p> <p>Requests <code>node.request&lt;ReturnType=void&gt;(id, args)</code> must be made from within a fiber, since they can take some time. The response is a <code>modm::amnb::Result</code> object, which contains the result, system error and user error.</p> <p>Note that if a request returns a user error type, you must define it as <code>node.request&lt;ReturnType, UserErrorType&gt;(id, args)</code> and then explicitly check for it via <code>response.hasUserError()</code>. Note that the request itself may fail at a system level, for example sending a request with a payload too large for the receiver will return with a <code>modm::amnb::Error::RequestAllocationFailed</code> error.</p> <p>Result lifetime only valid until node.update()</p> <p>The result is only valid until the next call to <code>node.update()</code>, therefore you must copy the result into your own storage!</p> <p>Do not use requests in the main function!</p> <p><code>node.update()</code> must be called during requests to service the protocol and <code>node.request(...)</code> won't call it, creating a deadlock!</p> <pre><code>using namespace modm::amnb;\n\nDeviceWrapper&lt;Usart1&gt; device;\nNode&lt;/* TX msg queue size =*/10, /* max heap allocation = */1024&gt;\n    node(device, /*address=*/0x10, actions, listeners);\n\nmodm::Fiber fiberComms([]\n{\n    // Broadcasts are buffered in a transmit queue\n    node.broadcast(0);                     // no payload\n    node.broadcast(1, ArgumentType());     // with argument\n    node.broadcast(2, data, sizeof(data)); // with memory buffer\n\n    // Requests must be called from within a fiber\n    auto response = node.request&lt;&gt;(0);\n    // The request may fail, in that case check the error\n    if (not response) Error error = response.error();\n\n    // Responses can also be called from within a resumable function\n    auto response = node.request&lt;ReturnType&gt;(1, ArgumentType());\n    // The response is temporary, copy it before the next call to node.update()\n    if (response) ReturnType result = *response;\n\n    // User Error types must be declared\n    auto response = node.request&lt;ReturnType, UserErrorType&gt;(2, data, sizeof(data));\n    // The user error must be checked for explicitly now\n    if (response) ReturnType result = *response;\n    else if (response.hasUserError())\n        UserErrorType error = *response.userError();\n    else Error error = response.error();\n});\n\n// One fiber per update function\nmodm::Fiber fiberNodeTransmit([]{ node.update_transmit(); });\nmodm::Fiber fiberNodeReceive([]{ node.update_receive(); });\n</code></pre>"},{"location":"reference/module/modm-communication-amnb/#wire-format","title":"Wire Format","text":"<p>There are three message formats:</p> <ol> <li>Messages without payload</li> <li>Messages with payloads up to 28B</li> <li>Messages with payloads up to 8kB</li> </ol> <p>The header contains these common fields:</p> <ul> <li><code>SYNC</code>: Synchronization sequence</li> <li><code>CRC8</code>: checksum for the header</li> <li><code>ADDR</code>: Node address (sender or receiver)</li> <li><code>COMMAND</code>: Command code (listener/action ID)</li> <li><code>TYPE</code>: Message type (upper 3 bits)</li> </ul> Type Meaning 000 Broadcast 010 Request 011 Response 100 System Error 101 User Error <p>Note that there are two sync bytes prefixed to every messages, since the UART hardware in most devices does not signal when it is receiving, therefore collision avoidance it not possible for the first byte, only collision detection and only after the first byte has been sent. The second byte acts as a \"detection buffer\" in case another node starts sending during the first byte.</p> <pre><code>  1  2    3      4        5       6\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SYNC \u2502 CRC8 \u2502 ADDR \u2502 COMMAND \u2502 TYPE \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Messages with &lt;=28B data:</p> <ul> <li><code>CRC8</code>: checksum for the header and data</li> <li><code>TYPE/LENGTH</code>: Message type (upper 3 bits) and length (lower 5 bits) &lt;= 28</li> </ul> <pre><code>  1  2    3      4        5           6         7      ...\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SYNC \u2502 CRC8 \u2502 ADDR \u2502 COMMAND \u2502 TYPE/LENGTH \u2502 ... &lt;=28B DATA ... \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Messages with &lt;8kB data:</p> <ul> <li><code>TYPE</code>: lower 5 bits &gt;28</li> <li><code>LENGTH</code>: &gt;28 and &lt;8k</li> <li><code>CRC16</code>: checksum for the data</li> <li><code>DATA</code>: Up to 8kB payload (nodes may support much less though!)</li> </ul> <pre><code>  1  2    3      4        5       6      7   8   9  10    11    ...\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SYNC \u2502 CRC8 \u2502 ADDR \u2502 COMMAND \u2502 TYPE \u2502 LENGTH \u2502 CRC16 \u2502 ... &lt;8kB DATA ... \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/module/modm-communication-amnb/#options","title":"Options","text":""},{"location":"reference/module/modm-communication-amnb/#with_heap","title":"with_heap","text":"<p>Allow large messages to allocate on the heap.</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-communication-amnb/#dependencies","title":"Dependencies","text":"<p> modm:communication:amnb modm_communication_amnb modm: communication: amnb modm_architecture_fiber modm: architecture: fiber modm_communication_amnb-&gt;modm_architecture_fiber modm_container modm: container modm_communication_amnb-&gt;modm_container modm_math_utils modm: math: utils modm_communication_amnb-&gt;modm_math_utils modm_processing_timer modm: processing: timer modm_communication_amnb-&gt;modm_processing_timer modm_utils modm: utils modm_communication_amnb-&gt;modm_utils </p>"},{"location":"reference/module/modm-communication-ros/","title":"Drivers for rosserial","text":"<p>lbuild module: <code>modm:communication:ros</code></p>"},{"location":"reference/module/modm-communication-ros/#dependencies","title":"Dependencies","text":"<p> modm:communication:ros modm_communication_ros modm: communication: ros modm_architecture_clock modm: architecture: clock modm_communication_ros-&gt;modm_architecture_clock modm_architecture_uart modm: architecture: uart modm_communication_ros-&gt;modm_architecture_uart modm_processing_timer modm: processing: timer modm_communication_ros-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-communication-sab/","title":"Sensor Actuator Bus (SAB)","text":"<p>lbuild module: <code>modm:communication:sab</code></p> <p>The SAB (**S**ensor **A**ctuator **B**us) is a simple master-slave bus system. It is primarily used to query simple sensors and control actuators inside our robots.</p> <p>One master can communicate with up to 32 slaves. The slaves are only allowed to transmit after a direct request by the master. They may signal an event by an extra IO line, but this depends on the slave.</p>"},{"location":"reference/module/modm-communication-sab/#protocol","title":"Protocol","text":"<p>Features: - Baudrate is 115200 Baud. - Maximum payload length is 32 byte. - CRC8 (1-Wire)</p>"},{"location":"reference/module/modm-communication-sab/#structure","title":"Structure","text":"<pre><code>+------+--------+--------+---------+--------------+-----+\n| SYNC | LENGTH | HEADER | COMMAND | ... DATA ... | CRC |\n+------+--------+--------+---------+--------------+-----+\n</code></pre> <ul> <li><code>SYNC</code> - Synchronization byte (always 0x54)</li> <li><code>LENGTH</code> - Length of the payload (without header, command and CRC byte)</li> <li><code>HEADER</code> - Address of the slave and two flag bits</li> <li><code>COMMAND</code> - Command code</li> <li><code>DATA</code> - Up to 32 byte of payload</li> <li><code>CRC</code> - CRC-8 checksum (iButton)</li> </ul>"},{"location":"reference/module/modm-communication-sab/#header","title":"Header","text":"<pre><code>  7   6   5   4   3   2   1   0\n+---+---+---+---+---+---+---+---+\n| Flags |      ADDRESS          |\n+---+---+---+---+---+---+---+---+\n\n  Flags | Meaning\n--------+---------\n  0   0 | request by the master\n  0   1 | reserved\n  1   0 | negative response from the slave (NACK)\n  1   1 | positive response from the slave (ACK)\n</code></pre> <p>The second bit is always <code>false</code> when the master is transmitting. In the other direction, when the slaves are responding, the second bit has to following meaning:</p> <ul> <li><code>true</code> - Message is an positive response and may contain a payload</li> <li><code>false</code> - Message signals an error condition and carries only one byte of    payload. This byte is an error code.</li> </ul>"},{"location":"reference/module/modm-communication-sab/#electrical-characteristics","title":"Electrical characteristics","text":"<p>Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller.</p> <p>Within a single PCB, standard digital levels are used (either 0-3,3V or 0-5V) in a multi-drop configuration. Meaning it does not allow multiple drivers but multiple receivers. The idle state of a UART transmission line is high, so standard TTL-AND gates have to be used for bundling transmission lines from multiple slaves.</p> <p>Both approaches can be combined to reduce the number of needed CAN transceivers on a single board. Between two boards you should always use transceivers and therefore differential signaling to improve noise immunity.</p> <p>The signal lines to indicate events by the slave are strict optional, you may or may not use them (if the slave provides them).</p>"},{"location":"reference/module/modm-communication-sab/#dependencies","title":"Dependencies","text":"<p> modm:communication:sab modm_communication_sab modm: communication: sab modm_architecture_accessor modm: architecture: accessor modm_communication_sab-&gt;modm_architecture_accessor modm_debug modm: debug modm_communication_sab-&gt;modm_debug modm_processing_timer modm: processing: timer modm_communication_sab-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-communication-sab2/","title":"Sensor Actuator Bus Version 2 (SAB2)","text":"<p>lbuild module: <code>modm:communication:sab2</code></p> <p>The SAB (**S**ensor **A**ctuator **B**us) is a simple master-slave bus system. It is primarily used to query simple sensors and control actuators inside our robots.</p> <p>One master can communicate with up to 32 slaves. The slaves are only allowed to transmit after a direct request by the master. They may signal an event by an extra IO line, but this depends on the slave.</p>"},{"location":"reference/module/modm-communication-sab2/#protocol","title":"Protocol","text":"<p>Features: - Baudrate is 115200 Baud. - Maximum payload length is 32 byte. - CRC8 (1-Wire)</p>"},{"location":"reference/module/modm-communication-sab2/#structure","title":"Structure","text":"<pre><code>+------+--------+--------+---------+--------------+-----+\n| SYNC | LENGTH | HEADER | COMMAND | ... DATA ... | CRC |\n+------+--------+--------+---------+--------------+-----+\n</code></pre> <ul> <li><code>SYNC</code> - Synchronization byte (always 0x54)</li> <li><code>LENGTH</code> - Length of the payload (without header, command and CRC byte)</li> <li><code>HEADER</code> - Address of the slave and two flag bits</li> <li><code>COMMAND</code> - Command code</li> <li><code>DATA</code> - Up to 32 byte of payload</li> <li><code>CRC</code> - CRC-8 checksum (iButton)</li> </ul>"},{"location":"reference/module/modm-communication-sab2/#header","title":"Header","text":"<pre><code>  7   6   5   4   3   2   1   0\n+---+---+---+---+---+---+---+---+\n| Flags |      ADDRESS          |\n+---+---+---+---+---+---+---+---+\n\n  Flags | Meaning\n--------+---------\n  0   0 | request by the master\n  0   1 | reserved\n  1   0 | negative response from the slave (NACK)\n  1   1 | positive response from the slave (ACK)\n</code></pre> <p>The second bit is always <code>false</code> when the master is transmitting. In the other direction, when the slaves are responding, the second bit has to following meaning:</p> <ul> <li><code>true</code> - Message is an positive response and may contain a payload</li> <li><code>false</code> - Message signals an error condition and carries only one byte of    payload. This byte is an error code.</li> </ul>"},{"location":"reference/module/modm-communication-sab2/#electrical-characteristics","title":"Electrical characteristics","text":"<p>Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller.</p> <p>Within a single PCB, standard digital levels are used (either 0-3,3V or 0-5V) in a multi-drop configuration. Meaning it does not allow multiple drivers but multiple receivers. The idle state of a UART transmission line is high, so standard TTL-AND gates have to be used for bundling transmission lines from multiple slaves.</p> <p>Both approaches can be combined to reduce the number of needed CAN transceivers on a single board. Between two boards you should always use transceivers and therefore differential signaling to improve noise immunity.</p> <p>The signal lines to indicate events by the slave are strict optional, you may or may not use them (if the slave provides them).</p>"},{"location":"reference/module/modm-communication-sab2/#dependencies","title":"Dependencies","text":"<p> modm:communication:sab2 modm_communication_sab2 modm: communication: sab2 modm_architecture_accessor modm: architecture: accessor modm_communication_sab2-&gt;modm_architecture_accessor modm_communication_sab modm: communication: sab modm_communication_sab2-&gt;modm_communication_sab modm_debug modm: debug modm_communication_sab2-&gt;modm_debug modm_processing_timer modm: processing: timer modm_communication_sab2-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-communication-xpcc-generator/","title":"XPCC Generator","text":"<p>lbuild module: <code>modm:communication:xpcc:generator</code></p>"},{"location":"reference/module/modm-communication-xpcc-generator/#options","title":"Options","text":""},{"location":"reference/module/modm-communication-xpcc-generator/#container","title":"container","text":"<p>Name of the XPCC container to generate for</p> <p>Default: <code>\"\"</code> Inputs: <code>[String]</code> </p>"},{"location":"reference/module/modm-communication-xpcc-generator/#namespace","title":"namespace","text":"<p>Namespace of the generated XPCC communications</p> <p>Default: <code>robot</code> Inputs: <code>[String]</code> </p>"},{"location":"reference/module/modm-communication-xpcc-generator/#path","title":"path","text":"<p>Path to the XPCC generated folder</p> <p>Default: <code>generated/xpcc</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-communication-xpcc-generator/#source","title":"source","text":"<p>Path to the XPCC source file</p> <p>Default: <code>[]</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-communication-xpcc/","title":"Cross Platform Component Communication (XPCC)","text":"<p>lbuild module: <code>modm:communication:xpcc</code></p>"},{"location":"reference/module/modm-communication-xpcc/#options","title":"Options","text":""},{"location":"reference/module/modm-communication-xpcc/#timeoutacknowledge","title":"timeout.acknowledge","text":"<p>Timeout in ms of an reception acknowledgement</p> <p>Default: <code>100</code> Inputs: <code>[10 .. 100 .. 10000]</code> </p>"},{"location":"reference/module/modm-communication-xpcc/#timeoutresponse","title":"timeout.response","text":"<p>Timeout in ms of an request response</p> <p>Default: <code>200</code> Inputs: <code>[10 .. 200 .. 10000]</code> </p>"},{"location":"reference/module/modm-communication-xpcc/#dependencies","title":"Dependencies","text":"<p> modm:communication:xpcc modm_communication_xpcc modm: communication: xpcc modm_architecture_can modm: architecture: can modm_communication_xpcc-&gt;modm_architecture_can modm_container modm: container modm_communication_xpcc-&gt;modm_container modm_debug modm: debug modm_communication_xpcc-&gt;modm_debug modm_io modm: io modm_communication_xpcc-&gt;modm_io modm_math_utils modm: math: utils modm_communication_xpcc-&gt;modm_math_utils modm_processing_resumable modm: processing: resumable modm_communication_xpcc-&gt;modm_processing_resumable modm_processing_timer modm: processing: timer modm_communication_xpcc-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-communication/","title":"Communication Protocols","text":"<p>lbuild module: <code>modm:communication</code></p>"},{"location":"reference/module/modm-container/","title":"Containers","text":"<p>lbuild module: <code>modm:container</code></p> <p>A container is a holder object that stores a collection other objects (its elements). They are implemented as class templates, which allows a great flexibility in the types supported as elements.</p> <p>Many containers have several member functions in common, and share functionalities. The decision of which type of container to use for a specific need does not generally depend only on the functionality offered by the container, but also on the efficiency of some of its members (complexity). This is especially true for sequence containers, which offer different trade-offs in complexity between inserting/removing elements and accessing them.</p> <p><code>modm::Stack</code> and <code>modm::Queue</code> are implemented as container adapters. Container adapters are not full container classes, but classes that provide a specific interface relying on an object of one of the container classes (such as <code>modm::BoundedDeque</code> or <code>modm::LinkedList</code>) to handle the elements. The underlying container is encapsulated in such a way that its elements are accessed by the members of the container class independently of the underlying container class used.</p> <p>Sequence containers:</p> <ul> <li><code>modm::DynamicArray</code></li> <li><code>modm::LinkedList</code></li> <li><code>modm::DoublyLinkedList</code></li> <li><code>modm::BoundedDeque</code></li> </ul> <p>Container adapters:</p> <ul> <li><code>modm::Queue</code></li> <li><code>modm::Stack</code></li> <li><code>modm::BoundedStack</code></li> <li><code>modm::BoundedQueue</code></li> </ul> <p>Other:</p> <ul> <li><code>modm::SmartPointer</code></li> <li><code>modm::Pair</code></li> </ul> <p>Two special containers hiding in the <code>modm:architecture:atomic</code> module:</p> <ul> <li><code>modm::atomic::Queue</code></li> <li><code>modm::atomic::Container</code></li> </ul> <p>The first is a simple, interrupt-safe queue (but only for the AVRs). Whenever you need to exchange data between a interrupt routine and the normal program consider using this queue.</p> <p>The atomic container wraps objects and provides atomic access to them. This comes in handy when simple objects are accessed by an interrupt and the main program. The container provides secure access without much work in this case.</p>"},{"location":"reference/module/modm-container/#generic-interface","title":"Generic Interface","text":"<p>All implementation share a common set of function. Not every container implement every one of it, only a subset which is sufficient for the container.</p> <ul> <li>append</li> <li>prepend</li> <li>(insert)</li> <li>removeFront</li> <li>removeBack</li> <li>(remove)</li> <li>getFront</li> <li> <p>getBack</p> </li> <li> <p>push (only Stack and Queue)</p> </li> <li>pop (only Stack and Queue)</li> <li> <p>get (only Stack and Queue)</p> </li> <li> <p>at</p> </li> <li> <p>operator[]</p> </li> <li> <p>clear</p> </li> <li> <p>isEmpty</p> </li> <li>isFull</li> <li>getSize</li> <li>getMaxSize</li> <li>getCapacity</li> </ul>"},{"location":"reference/module/modm-container/#dependencies","title":"Dependencies","text":"<p> modm:container modm_container modm: container modm_architecture modm: architecture modm_container-&gt;modm_architecture modm_io modm: io modm_container-&gt;modm_io </p>"},{"location":"reference/module/modm-crashcatcher/","title":"CrashCatcher","text":"<p>lbuild module: <code>modm:crashcatcher</code></p> <p>CrashCatcher hooks into the ARM Cortex-M HardFault handler and generates a coredump that can be used with CrashDebug for post-mortem debugging. You must place the <code>CrashDebug</code> binary in your path or alternatively set the environment variable <code>MODM_CRASHDEBUG_BINARY</code> to point to the enclosing folder:</p> <pre><code>export MODM_CRASHDEBUG_BINARY=/path/to/crashdebug/bin/CrashDebug\n</code></pre> <ul> <li>https://github.com/adamgreen/CrashCatcher</li> <li>https://github.com/adamgreen/CrashDebug</li> </ul> <p>The debugger can generate coredumps too</p> <p>In case you encounter a hardfault while debugging or you simply want to store the current system state for later analysis or to share with other developers, you can simply call the <code>modm_coredump</code> function in GDB and it will generate a <code>coredump.txt</code> file. Consult your chosen build system module for additional integration.</p> <p>This module is only available for rp, sam, stm32.</p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-debug/","title":"Logging","text":"<p>lbuild module: <code>modm:debug</code></p> <p>The <code>modm::log::Logger</code> uses a <code>modm::IOStream</code> to read messages and write them to a given output device.</p> <p>Write a log message with streams:</p> <pre><code>MODM_LOG_DEBUG &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; \", y=\" &lt;&lt; y &lt;&lt; modm::flush;\n</code></pre> <p>The name of the stream represents the log level of the message. Available are:</p> <ul> <li><code>MODM_LOG_DEBUG</code></li> <li><code>MODM_LOG_INFO</code></li> <li><code>MODM_LOG_WARNING</code></li> <li><code>MODM_LOG_ERROR</code></li> </ul> <p>A log message can also be generated separately:</p> <pre><code>int a[3] = {1,2,3};\nMODM_LOG_DEBUG &lt;&lt; \"a = \";\nfor(int i = 0; i &lt; sizeof(a); ++i) {\n    MODM_LOG_DEBUG &lt;&lt; a[i] &lt;&lt; \", \";\n}\nMODM_LOG_DEBUG &lt;&lt; modm::flush;\n</code></pre>"},{"location":"reference/module/modm-debug/#flow-of-a-call","title":"Flow of a call","text":"<p>This is to give an estimation how many resources a call of the logger use. All considerations are for a PC program.</p> <p>The given call is:</p> <pre><code>MODM_LOG_DEBUG &lt;&lt; 123456;\n</code></pre> <p>The macro resolves to:</p> <pre><code>if (MODM_LOG_LEVEL &lt;= modm::log::DEBUG)\n    modm::log::debug\n</code></pre> <ul> <li><code>modm::log::debug</code> is an instance of <code>modm::Logger</code>:    Call of <code>modm::Logger::operator &lt;&lt; (T)</code> (with <code>T = int32_t</code>) which is inline</li> <li><code>IOStream::operator &lt;&lt; (T)</code> (with <code>T = int32_t</code>) is inline</li> <li><code>IOStream::writeInteger(int32_t)</code></li> <li><code>IOStream::writeInteger(int32_t)</code> will create the formatted string</li> <li>virtual call of <code>IODevice::write(const char*)</code></li> <li>redirect to <code>std::cout</code></li> </ul> <p>In sum there are two nested method calls with one of them being virtual.</p>"},{"location":"reference/module/modm-debug/#dependencies","title":"Dependencies","text":"<p> modm:debug modm_debug modm: debug modm_architecture modm: architecture modm_debug-&gt;modm_architecture modm_driver_terminal modm: driver: terminal modm_debug-&gt;modm_driver_terminal modm_io modm: io modm_debug-&gt;modm_io modm_utils modm: utils modm_debug-&gt;modm_utils </p>"},{"location":"reference/module/modm-docs/","title":"Documentation Generator","text":"<p>lbuild module: <code>modm:docs</code></p> <p>This module creates the documentation groups and hierarchy according to the modm module structure into <code>modm/docs</code>.</p> <p>The documentation can be generated using Doxygen or Doxypress.</p>"},{"location":"reference/module/modm-docs/#doxygen","title":"Doxygen","text":"<p>To generate the C++ documentation call Doxygen manually:</p> <pre><code>(cd modm/docs &amp;&amp; doxygen doxyfile.cfg)\n</code></pre> <p>Then open <code>modm/docs/html/index.html</code> in your web browser of choice.</p>"},{"location":"reference/module/modm-docs/#doxypress","title":"Doxypress","text":"<p>Install Doxypress.</p> <p>To generate the C++ documentation call Doxypress:</p> <pre><code>(cd modm/docs &amp;&amp; doxypress doxypress.json)\n</code></pre> <p>Then open <code>modm/docs/html/index.html</code> in your web browser of choice.</p>"},{"location":"reference/module/modm-docs/#options","title":"Options","text":""},{"location":"reference/module/modm-docs/#enable_qch","title":"enable_qch","text":"<p>Generate the Doxygen docs as Qt Help format (qch)</p> <p>Default: <code>no</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-driver-ad7280a/","title":"AD7280A Lithium Ion Battery Monitoring System","text":"<p>lbuild module: <code>modm:driver:ad7280a</code></p> <p>The AD7280A is monitor for lithium ion battery packs with up to six cells. It contains six 12-ADCs with 1\u00b5s conversion per channel and a cell balancing interface. Up to 7 devices can be added through a Daisy-Chain interface (chain of 8 devices).</p> <ul> <li>cell voltage accuracy of \u00b11.6 mV.</li> <li>Supply voltage 8-30V</li> <li>six auxiliary ADC input channels</li> </ul> <p>Recommended SPI Clk frequency is 1 MHz. With a 1 MHz Clk, it takes approximately 1.54 ms to read back the voltage conversions on 48 channels.</p> <p>When addressing devices in the chain directly the frequency needs to be lower than 1 MHz because delays introduced in each stage of the chain.</p>"},{"location":"reference/module/modm-driver-ad7280a/#dependencies","title":"Dependencies","text":"<p> modm:driver:ad7280a modm_driver_ad7280a modm: driver: ad7280a modm_architecture_fiber modm: architecture: fiber modm_driver_ad7280a-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_ad7280a-&gt;modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_ad7280a-&gt;modm_architecture_spi modm_math_utils modm: math: utils modm_driver_ad7280a-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-ad7928/","title":"AD79x8 ADC","text":"<p>lbuild module: <code>modm:driver:ad7928</code></p> <p>The AD7928/AD7918/AD7908 are, respectively, 12/10/8 bit analog-digital converters. The conversion time is determined by the Spi clock frequency. A maximum Spi clock of 20 Mhz is supported.</p>"},{"location":"reference/module/modm-driver-ad7928/#dependencies","title":"Dependencies","text":"<p> modm:driver:ad7928 modm_driver_ad7928 modm: driver: ad7928 modm_architecture_fiber modm: architecture: fiber modm_driver_ad7928-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_ad7928-&gt;modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_ad7928-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ad7928-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-adc_sampler/","title":"ADC Sampler","text":"<p>lbuild module: <code>modm:driver:adc_sampler</code></p> <p>This template class stores 8, 16 or 32bit ADC values in a buffer and provides an easy interface for managing that data.</p> <p>The code will read the ADC channels you specify in an array. This means you can remap the ADC channels in the order that they should appear in the buffer. The array must obviously have as many elements as channels! For example, if channels 0,2,7 are connected, but the sensors are in the wrong order, just remap them with the array {7,0,2}.</p> <p>To make use of oversampling and averaging, set <code>Oversamples &gt; 0</code>. This will loop <code>Oversamples</code> times through the ADC channels, adding the average of each result to the buffer.</p> <p>This class will choose the smallest data width for you. It decides this by adding the ADC resolution and the oversample size and choosing the next smallest size (not larger than 32bit though!).</p> <p>Warning</p> <p>The averaging algorithm only works for unsigned ADC data!</p>"},{"location":"reference/module/modm-driver-adc_sampler/#dependencies","title":"Dependencies","text":"<p> modm:driver:adc_sampler modm_driver_adc_sampler modm: driver: adc_sampler modm_architecture_adc modm: architecture: adc modm_driver_adc_sampler-&gt;modm_architecture_adc modm_math_utils modm: math: utils modm_driver_adc_sampler-&gt;modm_math_utils modm_utils modm: utils modm_driver_adc_sampler-&gt;modm_utils </p>"},{"location":"reference/module/modm-driver-adis16470/","title":"ADIS16470 Inertial Measurement Unit","text":"<p>lbuild module: <code>modm:driver:adis16470</code></p> <p>Datasheet</p>"},{"location":"reference/module/modm-driver-adis16470/#dependencies","title":"Dependencies","text":"<p> modm:driver:adis16470 modm_driver_adis16470 modm: driver: adis16470 modm_architecture_fiber modm: architecture: fiber modm_driver_adis16470-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_adis16470-&gt;modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_adis16470-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_adis16470-&gt;modm_architecture_spi_device modm_math_utils modm: math: utils modm_driver_adis16470-&gt;modm_math_utils modm_processing_timer modm: processing: timer modm_driver_adis16470-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-driver-adns9800/","title":"ADNS-9800 Laser Motion Sensor","text":"<p>lbuild module: <code>modm:driver:adns9800</code></p> <p>Based on work of Alexander Entinger, MSc / LXRobotics Based on https://github.com/mrjohnk/ADNS-9800</p>"},{"location":"reference/module/modm-driver-adns9800/#options","title":"Options","text":""},{"location":"reference/module/modm-driver-adns9800/#firmware","title":"firmware","text":"<p>Select the firmware version to initialize the device with.</p> <p>Default: <code>a6</code> Inputs: <code>[a4, a4b, a5, a6]</code> </p>"},{"location":"reference/module/modm-driver-adns9800/#dependencies","title":"Dependencies","text":"<p> modm:driver:adns9800 modm_driver_adns9800 modm: driver: adns9800 modm_architecture_fiber modm: architecture: fiber modm_driver_adns9800-&gt;modm_architecture_fiber modm_architecture_spi modm: architecture: spi modm_driver_adns9800-&gt;modm_architecture_spi modm_debug modm: debug modm_driver_adns9800-&gt;modm_debug </p>"},{"location":"reference/module/modm-driver-ads101x/","title":"ADS101x ADC","text":"<p>lbuild module: <code>modm:driver:ads101x</code></p> <p>The ADS1013/ADS1014/ADS1015 are ultra-low power, high precision analog-digital converters.</p>"},{"location":"reference/module/modm-driver-ads101x/#dependencies","title":"Dependencies","text":"<p> modm:driver:ads101x modm_driver_ads101x modm: driver: ads101x modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ads101x-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_ads101x-&gt;modm_architecture_register </p>"},{"location":"reference/module/modm-driver-ads7828/","title":"ADS7828 ADC","text":"<p>lbuild module: <code>modm:driver:ads7828</code></p> <p>The ADS7828 is a single-supply, low-power, 12-bit data acquisition device</p>"},{"location":"reference/module/modm-driver-ads7828/#dependencies","title":"Dependencies","text":"<p> modm:driver:ads7828 modm_driver_ads7828 modm: driver: ads7828 modm_architecture_fiber modm: architecture: fiber modm_driver_ads7828-&gt;modm_architecture_fiber modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ads7828-&gt;modm_architecture_i2c_device </p>"},{"location":"reference/module/modm-driver-ads7843/","title":"ADS7843 Resistive Touch Controller","text":"<p>lbuild module: <code>modm:driver:ads7843</code></p> <p>The ADS7843 by Texas Instruments is the de-facto standard for cheap resistive touch screens.</p> <p>There are many compatible devices from other manufacturers available, such as the UH7843 by Zilltek.</p> <p>TSC2046, XPT2046 and other *2046 chips seem to be not fully compatible with the ADS7843 and have their own driver \"modm:driver:touch2046\".</p>"},{"location":"reference/module/modm-driver-ads7843/#dependencies","title":"Dependencies","text":"<p> modm:driver:ads7843 modm_driver_ads7843 modm: driver: ads7843 modm_architecture_fiber modm: architecture: fiber modm_driver_ads7843-&gt;modm_architecture_fiber modm_ui_display modm: ui: display modm_driver_ads7843-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-ads816x/","title":"ADS816x ADC","text":"<p>lbuild module: <code>modm:driver:ads816x</code></p> <p>The ADS8166/ADS8167/ADS8168 are, 16 bit analog-digital converters with, sample rates of 1 MSPS (ADS8168), 500 kSPS (ADS8167), and 250 kSPS (ADS8166). The conversion time is determined by the chip select signal. A maximum Spi clock of 70 MHz is supported.</p> <p>This driver only implements the manual mode and auto sequence mode using the SPI interface. Only the default multiplexer configuration with 8 single-ended inputs and no pseudo-differential inputs is supported by now.</p>"},{"location":"reference/module/modm-driver-ads816x/#dependencies","title":"Dependencies","text":"<p> modm:driver:ads816x modm_driver_ads816x modm: driver: ads816x modm_architecture_fiber modm: architecture: fiber modm_driver_ads816x-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_ads816x-&gt;modm_architecture_gpio modm_architecture_spi_device modm: architecture: spi.device modm_driver_ads816x-&gt;modm_architecture_spi_device modm_io modm: io modm_driver_ads816x-&gt;modm_io </p>"},{"location":"reference/module/modm-driver-ams5915/","title":"AMS 5915 Pressure Sensor","text":"<p>lbuild module: <code>modm:driver:ams5915</code></p> <p>Driver for the AMS 5915 differential and absolute pressure sensors. The device runs a cyclic program, which will store a corrected pressure value with 12 bit resolution about every 500 \u03bcs within the output registers of the internal ASIC.</p> <p>Datasheet</p>"},{"location":"reference/module/modm-driver-ams5915/#dependencies","title":"Dependencies","text":"<p> modm:driver:ams5915 modm_driver_ams5915 modm: driver: ams5915 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ams5915-&gt;modm_architecture_i2c_device modm_math_utils modm: math: utils modm_driver_ams5915-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-apa102/","title":"APA102 RGB LED Driver","text":"<p>lbuild module: <code>modm:driver:apa102</code></p> <p>Drives any number of chained APA102 RGB LEDs using SPI signals SCK and MOSI up to a few dozen MHz. Due to the synchronous clock, there are no special restrictions on protocol timing, making this driver safe to use with interrupts enabled and/or with an RTOS.</p> <p>The internal data buffer size is 4B for start of frame, 4B for every LED and 1B for every 16 LEDs as end of frame.</p> <p>References:</p> <ul> <li>\"APA102 aka Superled\".</li> <li>\"Understanding the APA102 Superled\".</li> </ul>"},{"location":"reference/module/modm-driver-apa102/#dependencies","title":"Dependencies","text":"<p> modm:driver:apa102 modm_driver_apa102 modm: driver: apa102 modm_architecture_fiber modm: architecture: fiber modm_driver_apa102-&gt;modm_architecture_fiber modm_architecture_spi modm: architecture: spi modm_driver_apa102-&gt;modm_architecture_spi modm_ui_color modm: ui: color modm_driver_apa102-&gt;modm_ui_color </p>"},{"location":"reference/module/modm-driver-as5047/","title":"AS5047 14 bit Absolute Encoder SPI Driver","text":"<p>lbuild module: <code>modm:driver:as5047</code></p> <p>Datasheet</p>"},{"location":"reference/module/modm-driver-as5047/#dependencies","title":"Dependencies","text":"<p> modm:driver:as5047 modm_driver_as5047 modm: driver: as5047 modm_architecture_fiber modm: architecture: fiber modm_driver_as5047-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_as5047-&gt;modm_architecture_gpio modm_architecture_spi_device modm: architecture: spi.device modm_driver_as5047-&gt;modm_architecture_spi_device modm_math_geometry modm: math: geometry modm_driver_as5047-&gt;modm_math_geometry </p>"},{"location":"reference/module/modm-driver-as5600/","title":"AS5600 10 bit absolute encoder I2C driver","text":"<p>lbuild module: <code>modm:driver:as5600</code></p> <p>Datasheet</p>"},{"location":"reference/module/modm-driver-as5600/#dependencies","title":"Dependencies","text":"<p> modm:driver:as5600 modm_driver_as5600 modm: driver: as5600 modm_architecture_fiber modm: architecture: fiber modm_driver_as5600-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_as5600-&gt;modm_architecture_gpio modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_as5600-&gt;modm_architecture_i2c_device modm_math_geometry modm: math: geometry modm_driver_as5600-&gt;modm_math_geometry </p>"},{"location":"reference/module/modm-driver-at24mac402/","title":"AT24MAC404 I\u00b2C EEPROM","text":"<p>lbuild module: <code>modm:driver:at24mac402</code></p> <p>2 kBit I\u00b2C EEPROM with pre-programmed read-only 48 bit MAC address and 128 bit unique id.</p>"},{"location":"reference/module/modm-driver-at24mac402/#dependencies","title":"Dependencies","text":"<p> modm:driver:at24mac402 modm_driver_at24mac402 modm: driver: at24mac402 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_at24mac402-&gt;modm_architecture_i2c_device modm_driver_i2c_eeprom modm: driver: i2c.eeprom modm_driver_at24mac402-&gt;modm_driver_i2c_eeprom </p>"},{"location":"reference/module/modm-driver-block-allocator/","title":"Block Allocator","text":"<p>lbuild module: <code>modm:driver:block.allocator</code></p>"},{"location":"reference/module/modm-driver-block-allocator/#dependencies","title":"Dependencies","text":"<p> modm:driver:block.allocator modm_driver_block_allocator modm: driver: block.allocator modm_architecture modm: architecture modm_driver_block_allocator-&gt;modm_architecture modm_math_utils modm: math: utils modm_driver_block_allocator-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-block-device-file/","title":"File Block Device","text":"<p>lbuild module: <code>modm:driver:block.device:file</code></p> <p>This module is only available for hosted.</p>"},{"location":"reference/module/modm-driver-block-device-file/#dependencies","title":"Dependencies","text":"<p> modm:driver:block.device:file modm_driver_block_device_file modm: driver: block.device: file modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_file-&gt;modm_architecture_block_device </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-driver-block-device-heap/","title":"Heap Block Device","text":"<p>lbuild module: <code>modm:driver:block.device:heap</code></p>"},{"location":"reference/module/modm-driver-block-device-heap/#dependencies","title":"Dependencies","text":"<p> modm:driver:block.device:heap modm_driver_block_device_heap modm: driver: block.device: heap modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_heap-&gt;modm_architecture_block_device modm_utils modm: utils modm_driver_block_device_heap-&gt;modm_utils </p>"},{"location":"reference/module/modm-driver-block-device-mirror/","title":"Mirroring Block Device","text":"<p>lbuild module: <code>modm:driver:block.device:mirror</code></p>"},{"location":"reference/module/modm-driver-block-device-mirror/#dependencies","title":"Dependencies","text":"<p> modm:driver:block.device:mirror modm_driver_block_device_mirror modm: driver: block.device: mirror modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_mirror-&gt;modm_architecture_block_device </p>"},{"location":"reference/module/modm-driver-block-device-spi-flash/","title":"SPI Flash Block Device","text":"<p>lbuild module: <code>modm:driver:block.device:spi.flash</code></p> <p>Microchip SST26VF064B 64MBit flash chip in SOIJ-8, WDFN-8 or SOIC-16.</p>"},{"location":"reference/module/modm-driver-block-device-spi-flash/#dependencies","title":"Dependencies","text":"<p> modm:driver:block.device:spi.flash modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_spi_flash-&gt;modm_architecture_block_device modm_architecture_register modm: architecture: register modm_driver_block_device_spi_flash-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_block_device_spi_flash-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-block-device-spi-stack-flash/","title":"SpiStack homogeneous flash memory","text":"<p>lbuild module: <code>modm:driver:block.device:spi.stack.flash</code></p>"},{"location":"reference/module/modm-driver-block-device-spi-stack-flash/#dependencies","title":"Dependencies","text":"<p> modm:driver:block.device:spi.stack.flash modm_driver_block_device_spi_stack_flash modm: driver: block.device: spi.stack.flash modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_spi_stack_flash-&gt;modm_architecture_block_device </p>"},{"location":"reference/module/modm-driver-block-device/","title":"Block Devices","text":"<p>lbuild module: <code>modm:driver:block.device</code></p>"},{"location":"reference/module/modm-driver-bme280/","title":"BME280 Pressure Sensor","text":"<p>lbuild module: <code>modm:driver:bme280</code></p> <p>The BME280 is a high precision digital temperature, pressure and humidity sensor with I2C interface.</p> <p>It is known that many BME280-modules suffer from self-heating (I2C pull-ups?). So the reported temperature is about 1 to 3 degree higher than with other sensors. Forced ventilation can drop the temperature by 2 to 3 degrees.</p>"},{"location":"reference/module/modm-driver-bme280/#dependencies","title":"Dependencies","text":"<p> modm:driver:bme280 modm_driver_bme280 modm: driver: bme280 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bme280-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_bme280-&gt;modm_architecture_register modm_debug modm: debug modm_driver_bme280-&gt;modm_debug modm_math_utils modm: math: utils modm_driver_bme280-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-bmi088/","title":"BMI088 Inertial Measurement Unit","text":"<p>lbuild module: <code>modm:driver:bmi088</code></p> <p>Datasheet</p>"},{"location":"reference/module/modm-driver-bmi088/#dependencies","title":"Dependencies","text":"<p> modm:driver:bmi088 modm_driver_bmi088 modm: driver: bmi088 modm_architecture_fiber modm: architecture: fiber modm_driver_bmi088-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_bmi088-&gt;modm_architecture_gpio modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bmi088-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_bmi088-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_bmi088-&gt;modm_architecture_spi_device modm_math_geometry modm: math: geometry modm_driver_bmi088-&gt;modm_math_geometry modm_processing_timer modm: processing: timer modm_driver_bmi088-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-driver-bmp085/","title":"BMP085 Pressure Sensor","text":"<p>lbuild module: <code>modm:driver:bmp085</code></p> <p>The BMP085 is a high precision digital pressure sensor with I2C interface. Unfortunately this sensor is so sensitive, it will give you wrong results when there is traffic on the I2C during either temperature or pressure conversion. So during that time make sure no other sensors on the bus are read out.</p> <p>For further information, consult the product homepage. Also compatible to and tested with BMP180.</p>"},{"location":"reference/module/modm-driver-bmp085/#dependencies","title":"Dependencies","text":"<p> modm:driver:bmp085 modm_driver_bmp085 modm: driver: bmp085 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bmp085-&gt;modm_architecture_i2c_device modm_debug modm: debug modm_driver_bmp085-&gt;modm_debug modm_math_utils modm: math: utils modm_driver_bmp085-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-bno055/","title":"BNO055 9-DOF Inertial Measurement Unit","text":"<p>lbuild module: <code>modm:driver:bno055</code></p> <p>The BNO055 is a System in Package (SiP), integrating a triaxial 14-bit accelerometer, a triaxial 16-bit gyroscope with a range of \u00b12000 degrees per second, a triaxial geomagnetic sensor and a 32-bit ARM Cortex-M0+ microcontroller running Bosch Sensortec sensor fusion software, in a single package.</p>"},{"location":"reference/module/modm-driver-bno055/#dependencies","title":"Dependencies","text":"<p> modm:driver:bno055 modm_driver_bno055 modm: driver: bno055 modm_architecture_fiber modm: architecture: fiber modm_driver_bno055-&gt;modm_architecture_fiber modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bno055-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_bno055-&gt;modm_architecture_register modm_math_geometry modm: math: geometry modm_driver_bno055-&gt;modm_math_geometry modm_math_utils modm: math: utils modm_driver_bno055-&gt;modm_math_utils modm_processing_timer modm: processing: timer modm_driver_bno055-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-driver-cat24aa/","title":"CAT24AAxx I2C Eeprom","text":"<p>lbuild module: <code>modm:driver:cat24aa</code></p> <p>Compatible with the OnSemi CAT24AA I2C eeprom (1 kBit to 16 kBit). It  uses a 8-bit address pointer, the top 3 bits of the address pointer are added to the the slave address, which is fixed to 0x50.</p>"},{"location":"reference/module/modm-driver-cat24aa/#dependencies","title":"Dependencies","text":"<p> modm:driver:cat24aa modm_driver_cat24aa modm: driver: cat24aa modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_cat24aa-&gt;modm_architecture_i2c_device </p>"},{"location":"reference/module/modm-driver-cycle_counter/","title":"Cycle Counter","text":"<p>lbuild module: <code>modm:driver:cycle_counter</code></p> <p>Allows you to measure time with cycle accuracy on AVR and ARM devices. This module wraps common functionality around different timers:</p> <ul> <li>AVR: uses 16-bit TC1.</li> <li>ARMv6-M (Cortex-M0/M0+): uses the 24-bit SysTick with limitations.</li> <li>ARMv7-M (Cortex-M3 and above): uses the 32-bit DWT-&gt;CYCCNT.</li> </ul> <pre><code>// place counter in the fastest memory to limit sampling overhead\nmodm_fastdata modm::CycleCounter counter;\n// initialize once before sampling\ncounter.initialize();\n\n// Sample the timer now\ncounter.start();\n// perform your operation and then sample again\ncounter.stop();\n\n// you can now get cycles or milli-/micro-/nanoseconds\ncounter.cycles();\ncounter.nanoseconds();\ncounter.microseconds();\ncounter.milliseconds();\n</code></pre> <p>AVR TC1 Limitations</p> <p>The 16-bit timer limits the maximum measurable time to just 4ms at 16MHz!</p> <p>Cortex-M0 SysTick Limitations</p> <p>The ARMv6-M architecture does not come with a free running counter, therefore this class uses the SysTick timer. However, the timer is already used by the <code>modm:platform:systick</code> module to provide <code>modm::Clock</code>, which limits the maximum measurable time to just 1ms! The systick may also be run with a /8 prescaler, which this class compensates for but this still reduces sampling resolution to 8 cycles!</p> <p>In case these limitations are not acceptable, you may force initialize the SysTick, which will break <code>modm::Clock</code> functionality in favor of accurate measurements. You may of course reinitialize the SysTick after your measurement to regain <code>modm::Clock</code> functionality! However, the software timers of the <code>modm:processing:timer</code> module may not work correctly anymore and may need to be reinitialized.</p> <pre><code>// Always initializes the SysTick for `modm::Clock`\nBoard::initialize();\n\n// but we need an accurate cycle counter\ncounter.initialize(/*force=*/true);\n// do longer and more accurate measurement now\ncounter.start();\n// do measurement operation\ncounter.stop();\n\n// reinitialize the SysTick timer for `modm::Clock`\nmodm::platform::SysTick::initialize&lt;Board::SystemClock&gt;();\n</code></pre> <p>If this solution is not acceptable either, we recommend using a platform specific hardware timer instead.</p> <p>This module is only available for avr, rp, sam, stm32.</p>"},{"location":"reference/module/modm-driver-cycle_counter/#dependencies","title":"Dependencies","text":"<p> modm:driver:cycle_counter modm_driver_cycle_counter modm: driver: cycle_counter modm_platform_core modm: platform: core modm_driver_cycle_counter-&gt;modm_platform_core modm_platform_cortex_m modm: platform: cortex-m modm_driver_cycle_counter-&gt;modm_platform_cortex_m </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-driver-drv832x_spi/","title":"DRV832xS: Three-Phase Smart Gate Driver","text":"<p>lbuild module: <code>modm:driver:drv832x_spi</code></p> <p>This driver only covers the gate driver configuration accessible via SPI interface. DRV832x Datasheet.</p>"},{"location":"reference/module/modm-driver-drv832x_spi/#dependencies","title":"Dependencies","text":"<p> modm:driver:drv832x_spi modm_driver_drv832x_spi modm: driver: drv832x_spi modm_architecture_fiber modm: architecture: fiber modm_driver_drv832x_spi-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_drv832x_spi-&gt;modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_drv832x_spi-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_drv832x_spi-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-ds1302/","title":"DS1302 Real-Time Clock","text":"<p>lbuild module: <code>modm:driver:ds1302</code></p>"},{"location":"reference/module/modm-driver-ds1302/#dependencies","title":"Dependencies","text":"<p> modm:driver:ds1302 modm_driver_ds1302 modm: driver: ds1302 modm_architecture_fiber modm: architecture: fiber modm_driver_ds1302-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_ds1302-&gt;modm_architecture_gpio </p>"},{"location":"reference/module/modm-driver-ds1631/","title":"DS1x31 Temperature Sensor","text":"<p>lbuild module: <code>modm:driver:ds1631</code></p>"},{"location":"reference/module/modm-driver-ds1631/#dependencies","title":"Dependencies","text":"<p> modm:driver:ds1631 modm_driver_ds1631 modm: driver: ds1631 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ds1631-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_ds1631-&gt;modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_ds1631-&gt;modm_driver_lm75 modm_processing_timer modm: processing: timer modm_driver_ds1631-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-driver-ds18b20/","title":"1-Wire Thermometer","text":"<p>lbuild module: <code>modm:driver:ds18b20</code></p> <p>Programmable resolution 1-wire digital thermometer.</p> <p>The DS18B20 digital thermometer provides 9-bit to 12-bit Celsius temperature measurements and has an alarm function with non-volatile user-programmable upper and lower trigger points. The DS18B20 communicates over a 1-Wire bus that by definition requires only one data line (and ground) for communication with a central microprocessor.</p> <p>It has an operating temperature range of -55\u00b0C to +125\u00b0C and is accurate to \u00b10.5\u00b0C over the range of -10\u00b0C to +85\u00b0C.</p> <p>In addition, the DS18B20 can derive power directly from the data line (\"parasite power\"), eliminating the need for an external power supply.</p> <p>Features: - Power Supply Range is 3.0V to 5.5V - Each device has a unique 64-Bit Serial Code Stored in an On-Board ROM - Thermometer Resolution is User Selectable from 9 to 12 Bits - Converts Temperature to 12-Bit Digital Word in 750ms (Max)</p>"},{"location":"reference/module/modm-driver-ds18b20/#dependencies","title":"Dependencies","text":"<p> modm:driver:ds18b20 modm_driver_ds18b20 modm: driver: ds18b20 modm_architecture_1_wire modm: architecture: 1-wire modm_driver_ds18b20-&gt;modm_architecture_1_wire </p>"},{"location":"reference/module/modm-driver-dw3110/","title":"DW3110 Drivers","text":"<p>lbuild module: <code>modm:driver:dw3110</code></p>"},{"location":"reference/module/modm-driver-dw3110/#dependencies","title":"Dependencies","text":"<p> modm:driver:dw3110 modm_driver_dw3110 modm: driver: dw3110 modm_architecture_fiber modm: architecture: fiber modm_driver_dw3110-&gt;modm_architecture_fiber modm_architecture_register modm: architecture: register modm_driver_dw3110-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_dw3110-&gt;modm_architecture_spi_device modm_debug modm: debug modm_driver_dw3110-&gt;modm_debug modm_processing_timer modm: processing: timer modm_driver_dw3110-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-driver-ea_dog/","title":"EA-DOG Displays","text":"<p>lbuild module: <code>modm:driver:ea_dog</code></p>"},{"location":"reference/module/modm-driver-ea_dog/#options","title":"Options","text":""},{"location":"reference/module/modm-driver-ea_dog/#st7036_voltage","title":"ST7036_voltage","text":"<p>Select the supply voltage of the ST7036.</p> <p>Default: <code>3.3V</code> Inputs: <code>[3.3V, 5V]</code> </p>"},{"location":"reference/module/modm-driver-ea_dog/#dependencies","title":"Dependencies","text":"<p> modm:driver:ea_dog modm_driver_ea_dog modm: driver: ea_dog modm_architecture_accessor modm: architecture: accessor modm_driver_ea_dog-&gt;modm_architecture_accessor modm_architecture_fiber modm: architecture: fiber modm_driver_ea_dog-&gt;modm_architecture_fiber modm_ui_display modm: ui: display modm_driver_ea_dog-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-encoder_input-bitbang/","title":"Quadrature Encoder Input","text":"<p>lbuild module: <code>modm:driver:encoder_input.bitbang</code></p> <p>This driver decodes an AB (incremental) encoder signal. Ported from code created by Peter Dannegger: https://www.mikrocontroller.net/articles/Drehgeber.</p>"},{"location":"reference/module/modm-driver-encoder_input-bitbang/#dependencies","title":"Dependencies","text":"<p> modm:driver:encoder_input.bitbang modm_driver_encoder_input_bitbang modm: driver: encoder_input.bitbang modm_architecture_atomic modm: architecture: atomic modm_driver_encoder_input_bitbang-&gt;modm_architecture_atomic modm_architecture_fiber modm: architecture: fiber modm_driver_encoder_input_bitbang-&gt;modm_architecture_fiber modm_platform_gpio modm: platform: gpio modm_driver_encoder_input_bitbang-&gt;modm_platform_gpio </p>"},{"location":"reference/module/modm-driver-encoder_input/","title":"Quadrature Encoder Input using STM32 general purpose Timer","text":"<p>lbuild module: <code>modm:driver:encoder_input</code></p> <p>This driver decodes an AB (incremental) encoder signal.</p> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-driver-encoder_input/#dependencies","title":"Dependencies","text":"<p> modm:driver:encoder_input modm_driver_encoder_input modm: driver: encoder_input modm_architecture_atomic modm: architecture: atomic modm_driver_encoder_input-&gt;modm_architecture_atomic </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-driver-encoder_output-bitbang/","title":"Quadrature Encoder Output","text":"<p>lbuild module: <code>modm:driver:encoder_output.bitbang</code></p> <p>This driver generates a AB (incremental) encoder signal to emulate a hardware encoder with a microcontroller.</p>"},{"location":"reference/module/modm-driver-encoder_output-bitbang/#dependencies","title":"Dependencies","text":"<p> modm:driver:encoder_output.bitbang modm_driver_encoder_output_bitbang modm: driver: encoder_output.bitbang modm_architecture_gpio modm: architecture: gpio modm_driver_encoder_output_bitbang-&gt;modm_architecture_gpio modm_processing_timer modm: processing: timer modm_driver_encoder_output_bitbang-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-driver-ft245/","title":"FT245 USB FIFO","text":"<p>lbuild module: <code>modm:driver:ft245</code></p> <p>The FT245R USB FIFO from Future Technology Devices International is a single chip USB to parallel FIFO bidirectional data transfer interface.</p> <p>Wr and Rd must be GpioOutputs and set to output mode before. Rxf and Txe must be GpioInputs. Port is switched between input and output mode.</p>"},{"location":"reference/module/modm-driver-ft245/#example","title":"Example","text":"<pre><code>#include &lt;modm/architecture.hpp&gt;\n#include &lt;modm/driver/usb/ft245.hpp&gt;\nusing namespace modm::platform;\n\nusing myPort = GpioPort&lt;GpioD0, 8&gt;;\nusing Rxf    = GpioInputC11;\nusing Txe    = GpioInputC10;\nusing Rd     = GpioOutputA15;\nusing Wr     = GpioOutputA9;\n\nusing myFt = modm::Ft245&lt;myPort, Rd, Wr, Rxf, Txe&gt;;\n\nint\nmain()\n{\n    Rd::setOutput(modm::Gpio::High);\n    Wr::setOutput(modm::Gpio::Low);\n\n    while (true)\n    {\n        uint8_t c;\n        if (myFt::read(c)) {\n            myFt::write(c + 1);\n        }\n    }\n}\n</code></pre>"},{"location":"reference/module/modm-driver-ft245/#dependencies","title":"Dependencies","text":"<p> modm:driver:ft245 modm_driver_ft245 modm: driver: ft245 modm_architecture_gpio modm: architecture: gpio modm_driver_ft245-&gt;modm_architecture_gpio </p>"},{"location":"reference/module/modm-driver-ft6x06/","title":"FT6x06 Capacitive Touch Controller","text":"<p>lbuild module: <code>modm:driver:ft6x06</code></p>"},{"location":"reference/module/modm-driver-ft6x06/#dependencies","title":"Dependencies","text":"<p> modm:driver:ft6x06 modm_driver_ft6x06 modm: driver: ft6x06 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ft6x06-&gt;modm_architecture_i2c_device </p>"},{"location":"reference/module/modm-driver-gpio_sampler/","title":"Gpio Sampling via Interrupts","text":"<p>lbuild module: <code>modm:driver:gpio_sampler</code></p> <p>This module is only available for stm32{f1,f2,f3,f4,g4,l1,l4,l5,u5}.</p>"},{"location":"reference/module/modm-driver-gpio_sampler/#dependencies","title":"Dependencies","text":"<p> modm:driver:gpio_sampler modm_driver_gpio_sampler modm: driver: gpio_sampler modm_architecture_interrupt modm: architecture: interrupt modm_driver_gpio_sampler-&gt;modm_architecture_interrupt modm_platform_core modm: platform: core modm_driver_gpio_sampler-&gt;modm_platform_core modm_platform_exti modm: platform: exti modm_driver_gpio_sampler-&gt;modm_platform_exti modm_platform_gpio modm: platform: gpio modm_driver_gpio_sampler-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-driver-hclax/","title":"HCLA Pressure Sensor","text":"<p>lbuild module: <code>modm:driver:hclax</code></p> <p>Driver for the HCLA differential pressure sensors.</p> <p>The device runs a cyclic program, which will store a corrected pressure value with 12 bit resolution about every 250 \u03bcs within the output registers of the internal ASIC.</p>"},{"location":"reference/module/modm-driver-hclax/#dependencies","title":"Dependencies","text":"<p> modm:driver:hclax modm_driver_hclax modm: driver: hclax modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hclax-&gt;modm_architecture_i2c_device modm_math_utils modm: math: utils modm_driver_hclax-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-hd44780/","title":"HD44780 Displays","text":"<p>lbuild module: <code>modm:driver:hd44780</code></p>"},{"location":"reference/module/modm-driver-hd44780/#dependencies","title":"Dependencies","text":"<p> modm:driver:hd44780 modm_driver_hd44780 modm: driver: hd44780 modm_architecture_delay modm: architecture: delay modm_driver_hd44780-&gt;modm_architecture_delay modm_architecture_fiber modm: architecture: fiber modm_driver_hd44780-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_hd44780-&gt;modm_architecture_gpio modm_ui_display modm: ui: display modm_driver_hd44780-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-hmc58x/","title":"HMC58x3 3-Axis Digital Magnetometer","text":"<p>lbuild module: <code>modm:driver:hmc58x</code></p> <p>The HMC58x3 is a surface-mount, multi-chip module designed for low-field magnetic sensing with a digital interface for applications such as low-cost compassing and magnetometry. The HMC58x3 includes high-resolution magneto-resistive sensors plus an ASIC containing amplification, automatic degaussing strap drivers, offset cancellation, and a 12-bit ADC that enables 1-2 degrees compass heading accuracy.</p>"},{"location":"reference/module/modm-driver-hmc58x/#dependencies","title":"Dependencies","text":"<p> modm:driver:hmc58x modm_driver_hmc58x modm: driver: hmc58x modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hmc58x-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_hmc58x-&gt;modm_architecture_register modm_math_utils modm: math: utils modm_driver_hmc58x-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-hmc6343/","title":"HMC6343 3-Axis Compass","text":"<p>lbuild module: <code>modm:driver:hmc6343</code></p> <p>The Honeywell HMC6343 is a fully integrated compass module that includes firmware for heading computation and calibration for magnetic distortions. The module combines 3-axis magneto-resistive sensors and 3-axis MEMS accelerometers, analog and digital support circuits, microprocessor and algorithms required for heading computation.</p>"},{"location":"reference/module/modm-driver-hmc6343/#dependencies","title":"Dependencies","text":"<p> modm:driver:hmc6343 modm_driver_hmc6343 modm: driver: hmc6343 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hmc6343-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_hmc6343-&gt;modm_architecture_register modm_math_utils modm: math: utils modm_driver_hmc6343-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-hx711/","title":"HX711 Load Cell Amplifier and ADC","text":"<p>lbuild module: <code>modm:driver:hx711</code></p> <p>The HX711 is an integrated load cell amplifier designed for weight scales and industrial control applications to interface directly with a bridge sensor. The interface is bit-bang and timing based, so only GPIO is needed. In a complete system the SCK pin's timing while reading must be met.</p>"},{"location":"reference/module/modm-driver-hx711/#dependencies","title":"Dependencies","text":"<p> modm:driver:hx711 modm_driver_hx711 modm: driver: hx711 modm_architecture_fiber modm: architecture: fiber modm_driver_hx711-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_hx711-&gt;modm_architecture_gpio </p>"},{"location":"reference/module/modm-driver-i2c-eeprom/","title":"I2C Eeprom","text":"<p>lbuild module: <code>modm:driver:i2c.eeprom</code></p> <p>Compatible with the 24C256 (ST) and 24FC1025 (Microchip) family and other I2C eeprom with an 16-bit address pointer as well as devices with an 8-bit address pointer. Base address for most 24xxyyyy eeproms is 0x50.</p>"},{"location":"reference/module/modm-driver-i2c-eeprom/#dependencies","title":"Dependencies","text":"<p> modm:driver:i2c.eeprom modm_driver_i2c_eeprom modm: driver: i2c.eeprom modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_i2c_eeprom-&gt;modm_architecture_i2c_device </p>"},{"location":"reference/module/modm-driver-ili9341/","title":"ILI9341 Display with parallel and SPI bus transports","text":"<p>lbuild module: <code>modm:driver:ili9341</code></p>"},{"location":"reference/module/modm-driver-ili9341/#dependencies","title":"Dependencies","text":"<p> modm:driver:ili9341 modm_driver_ili9341 modm: driver: ili9341 modm_architecture_fiber modm: architecture: fiber modm_driver_ili9341-&gt;modm_architecture_fiber modm_architecture_spi_device modm: architecture: spi.device modm_driver_ili9341-&gt;modm_architecture_spi_device modm_ui_display modm: ui: display modm_driver_ili9341-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-is31fl3733/","title":"IS31FL3733 Matrix Driver","text":"<p>lbuild module: <code>modm:driver:is31fl3733</code></p>"},{"location":"reference/module/modm-driver-is31fl3733/#dependencies","title":"Dependencies","text":"<p> modm:driver:is31fl3733 modm_driver_is31fl3733 modm: driver: is31fl3733 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_is31fl3733-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_is31fl3733-&gt;modm_architecture_register </p>"},{"location":"reference/module/modm-driver-itg3200/","title":"ITG3200 Digital Gyroscope","text":"<p>lbuild module: <code>modm:driver:itg3200</code></p> <p>For further information on the special sensing functions, consult the product homepage.</p>"},{"location":"reference/module/modm-driver-itg3200/#dependencies","title":"Dependencies","text":"<p> modm:driver:itg3200 modm_driver_itg3200 modm: driver: itg3200 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_itg3200-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_itg3200-&gt;modm_architecture_register modm_math_utils modm: math: utils modm_driver_itg3200-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-ixm42xxx/","title":"InvenSense 6-Axis IMU","text":"<p>lbuild module: <code>modm:driver:ixm42xxx</code></p> <p>High Precision 6-Axis MEMS MotionTracking Device</p> <p>The registers in user bank 1, 2, 3 and 4 are currently not mapped out</p> <p>The IXM-42xxx driver has been developed for IIM-42652</p> <p>Some functionality may not be implemented or may not be applicable for other InvenSense 6-Axis IMU</p> <p>The IXM-42xxx driver I2C transport layer is untested</p>"},{"location":"reference/module/modm-driver-ixm42xxx/#dependencies","title":"Dependencies","text":"<p> modm:driver:ixm42xxx modm_driver_ixm42xxx modm: driver: ixm42xxx modm_architecture_fiber modm: architecture: fiber modm_driver_ixm42xxx-&gt;modm_architecture_fiber modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ixm42xxx-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_ixm42xxx-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ixm42xxx-&gt;modm_architecture_spi_device modm_math_geometry modm: math: geometry modm_driver_ixm42xxx-&gt;modm_math_geometry modm_math_utils modm: math: utils modm_driver_ixm42xxx-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-l3gd20/","title":"L3GD20 3-Axis Gyroscope","text":"<p>lbuild module: <code>modm:driver:l3gd20</code></p> <p>The L3GD20 is a low-power three-axis angular rate sensor. The L3GD20 has a full scale of \u00b1250/\u00b1500/\u00b12000 dps and is capable of measuring rates with a user-selectable bandwidth.</p>"},{"location":"reference/module/modm-driver-l3gd20/#dependencies","title":"Dependencies","text":"<p> modm:driver:l3gd20 modm_driver_l3gd20 modm: driver: l3gd20 modm_architecture_fiber modm: architecture: fiber modm_driver_l3gd20-&gt;modm_architecture_fiber modm_architecture_register modm: architecture: register modm_driver_l3gd20-&gt;modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_l3gd20-&gt;modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_l3gd20-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-lan8720a/","title":"LAN8720A Ethernet Transceiver","text":"<p>lbuild module: <code>modm:driver:lan8720a</code></p> <p>Microchip's LAN8720A/LAN8720Ai are high-performance, small-footprint, low-power 10BASE-T/100BASE-TX transceiver connected via an RMII interface.</p>"},{"location":"reference/module/modm-driver-lawicel/","title":"Lawicel Format Converter","text":"<p>lbuild module: <code>modm:driver:lawicel</code></p> <p>Converts <code>modm::can::Message</code> to and from the Lawicel string format (<code>char *</code>).</p> <p>Lawicel AB (http://www.lawicel.com) offers medium sized CAN to USB and CAN to RS232 converters. Their data format is widely used.</p> <p>This converter only understands messages of type 'r', 't', 'R' and 'T' which transmits CAN frames. It does not understand commands to change the baud rate.</p>"},{"location":"reference/module/modm-driver-lawicel/#dependencies","title":"Dependencies","text":"<p> modm:driver:lawicel modm_driver_lawicel modm: driver: lawicel modm_architecture_can modm: architecture: can modm_driver_lawicel-&gt;modm_architecture_can </p>"},{"location":"reference/module/modm-driver-lis3-transport/","title":"LIS3xx Transport Layer","text":"<p>lbuild module: <code>modm:driver:lis3.transport</code></p>"},{"location":"reference/module/modm-driver-lis3-transport/#dependencies","title":"Dependencies","text":"<p> modm:driver:lis3.transport modm_driver_lis3_transport modm: driver: lis3.transport modm_architecture_fiber modm: architecture: fiber modm_driver_lis3_transport-&gt;modm_architecture_fiber modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lis3_transport-&gt;modm_architecture_i2c_device modm_architecture_spi_device modm: architecture: spi.device modm_driver_lis3_transport-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-lis302dl/","title":"LIS302DL 3-Axis Accelerometer","text":"<p>lbuild module: <code>modm:driver:lis302dl</code></p> <p>The LIS302DL is an ultra compact low-power three axes linear accelerometer. It includes a sensing element and an IC interface able to provide the measured acceleration to the external world through an I2C/SPI serial interface.</p>"},{"location":"reference/module/modm-driver-lis302dl/#dependencies","title":"Dependencies","text":"<p> modm:driver:lis302dl modm_driver_lis302dl modm: driver: lis302dl modm_architecture_fiber modm: architecture: fiber modm_driver_lis302dl-&gt;modm_architecture_fiber modm_architecture_register modm: architecture: register modm_driver_lis302dl-&gt;modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis302dl-&gt;modm_driver_lis3_transport </p>"},{"location":"reference/module/modm-driver-lis3dsh/","title":"LIS3DSH 3-Axis Accelerometer","text":"<p>lbuild module: <code>modm:driver:lis3dsh</code></p> <p>The LIS3DSH is an ultra low-power high performance three-axis linear accelerometer belonging to the \"nano\" family with embedded state machine that can be programmed to implement autonomous applications. The LIS3DSH has dynamically selectable full scales of \u00b12g/\u00b14g/\u00b16g/\u00b18g/\u00b116g and it is capable of measuring accelerations with output data rates from 3.125 Hz to 1.6 kHz.</p>"},{"location":"reference/module/modm-driver-lis3dsh/#dependencies","title":"Dependencies","text":"<p> modm:driver:lis3dsh modm_driver_lis3dsh modm: driver: lis3dsh modm_architecture_register modm: architecture: register modm_driver_lis3dsh-&gt;modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3dsh-&gt;modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_lis3dsh-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-lis3mdl/","title":"LIS3MDL Magnetic Sensor","text":"<p>lbuild module: <code>modm:driver:lis3mdl</code></p> <p>The LIS3MDL is an ultra-low-power high-performance three-axis magnetic sensor. The sensor has user-selectable full scales of 4/ 8/ 12/ 16 gauss. The LIS3MDL includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz.</p>"},{"location":"reference/module/modm-driver-lis3mdl/#dependencies","title":"Dependencies","text":"<p> modm:driver:lis3mdl modm_driver_lis3mdl modm: driver: lis3mdl modm_architecture_register modm: architecture: register modm_driver_lis3mdl-&gt;modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3mdl-&gt;modm_driver_lis3_transport modm_math_geometry modm: math: geometry modm_driver_lis3mdl-&gt;modm_math_geometry modm_math_utils modm: math: utils modm_driver_lis3mdl-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-lm75/","title":"LM75 Thermometer","text":"<p>lbuild module: <code>modm:driver:lm75</code></p> <p>LM75 digital temperature sensor driver.</p> <p>The LM75 is a digital temperature sensor with an I2C interface and measures temperature over a range of -55 to +125 deg Celsius with a resolution of 0.5 deg C and an accuracy of up to 2 deg C.</p> <p>The sensor has a default refresh rate between 3Hz and 10Hz which is hardcoded into the sensor and cannot be changed.</p>"},{"location":"reference/module/modm-driver-lm75/#dependencies","title":"Dependencies","text":"<p> modm:driver:lm75 modm_driver_lm75 modm: driver: lm75 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lm75-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_lm75-&gt;modm_architecture_register modm_math_utils modm: math: utils modm_driver_lm75-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-lp503x/","title":"LP503x 30/36 channel LED PWM driver","text":"<p>lbuild module: <code>modm:driver:lp503x</code></p> <p>LP5030/LP5036 30/36-channel, 12-bit PWM LED driver with I2C interface.</p>"},{"location":"reference/module/modm-driver-lp503x/#options","title":"Options","text":""},{"location":"reference/module/modm-driver-lp503x/#multichannel_write","title":"multichannel_write","text":"<p>Allow setting multiple channels in one I2C transaction. This feature requires additional 34 bytes of static storage. It can be disabled for very small devices</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-driver-lp503x/#dependencies","title":"Dependencies","text":"<p> modm:driver:lp503x modm_driver_lp503x modm: driver: lp503x modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lp503x-&gt;modm_architecture_i2c_device </p>"},{"location":"reference/module/modm-driver-lsm303a/","title":"LSM303DLHC 3-Axis Accelerometer","text":"<p>lbuild module: <code>modm:driver:lsm303a</code></p> <p>The LSM303DLHC is a system-in-package featuring a 3D digital linear acceleration sensor and a 3D digital magnetic sensor. The sensor has linear acceleration full scales of \u00b12g/\u00b14g/\u00b18g/\u00b116g and a magnetic field full scale of \u00b11.3/\u00b11.9/\u00b12.5/\u00b14.0/\u00b14.7/\u00b15.6/\u00b18.1 gauss. The LSM303DLHC includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz.</p> <p>Since the device actually features two I2C devices which are just placed in the same package, this class only implements the acceleration sensor.</p>"},{"location":"reference/module/modm-driver-lsm303a/#dependencies","title":"Dependencies","text":"<p> modm:driver:lsm303a modm_driver_lsm303a modm: driver: lsm303a modm_architecture_register modm: architecture: register modm_driver_lsm303a-&gt;modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lsm303a-&gt;modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_lsm303a-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-lsm6ds33/","title":"LSM6DS33 always-on 3D accelerometer and 3D gyroscope","text":"<p>lbuild module: <code>modm:driver:lsm6ds33</code></p> <p>The LSM6DS33 is a system-in-package featuring a 3D digital accelerometer and a 3D digital gyroscope performing at 1.25 mA (up to 1.6 kHz ODR) in high-performance mode. has a full-scale acceleration range of \u00b12/\u00b14/\u00b18/\u00b116 g and an angular rate range of \u00b1125/\u00b1245/\u00b1500/\u00b11000/\u00b12000 dps. The LSM6DS33 includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz.</p> <p>This driver only supports the raw data output of the sensor. Functions like tap recognition, step counter, free fall recogition, etc. are not supported</p>"},{"location":"reference/module/modm-driver-lsm6ds33/#dependencies","title":"Dependencies","text":"<p> modm:driver:lsm6ds33 modm_driver_lsm6ds33 modm: driver: lsm6ds33 modm_architecture_register modm: architecture: register modm_driver_lsm6ds33-&gt;modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lsm6ds33-&gt;modm_driver_lis3_transport modm_math_geometry modm: math: geometry modm_driver_lsm6ds33-&gt;modm_math_geometry modm_math_utils modm: math: utils modm_driver_lsm6ds33-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-lsm6dso/","title":"LSM6DSO 3D accelerometer and 3D gyroscope","text":"<p>lbuild module: <code>modm:driver:lsm6dso</code></p> <p>iNEMO inertial module: always-on 3D accelerometer and 3D gyroscope</p> <p>The LSM6DSO is a system-in-package featuring a 3D digital accelerometer and a 3D digital gyroscope boosting performance at 0.55 mA in high-performance mode and enabling always-on low-power features for an optimal motion experience for the consumer. The LSM6DSO supports main OS requirements, offering real, virtual and batch sensors with 9 kbytes for dynamic data batching. ST's family of MEMS sensor modules leverages the robust and mature manufacturing processes already used for the production of micromachined accelerometers and gyroscopes. The various sensing elements are manufactured using specialized micromachining processes, while the IC interfaces are developed using CMOS technology that allows the design of a dedicated circuit which is trimmed to better match the characteristics of the sensing element.</p> <p>The LSM6DSO has a full-scale acceleration range of \u00b12/\u00b14/\u00b18/\u00b116 g and an angular rate range of \u00b1125/\u00b1250/\u00b1500/\u00b11000/\u00b12000 dps.</p> <p>This driver currently only implements parts of the device functionality.</p>"},{"location":"reference/module/modm-driver-lsm6dso/#dependencies","title":"Dependencies","text":"<p> modm:driver:lsm6dso modm_driver_lsm6dso modm: driver: lsm6dso modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lsm6dso-&gt;modm_driver_lis3_transport modm_math_units modm: math: units modm_driver_lsm6dso-&gt;modm_math_units modm_math_utils modm: math: utils modm_driver_lsm6dso-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-ltc2984/","title":"LTC298x Thermometer","text":"<p>lbuild module: <code>modm:driver:ltc2984</code></p> <p>LTC2983/LTC2984: Integrated temperature measurement system (20 channel)</p> <p>The integrated EEPROM of the LTC2984 is not supported by now. LTC2984 and LTC2983 are 100%% compatible except the LTC2983 has no integrated EEPROM.</p> <p>Datasheet</p>"},{"location":"reference/module/modm-driver-ltc2984/#dependencies","title":"Dependencies","text":"<p> modm:driver:ltc2984 modm_driver_ltc2984 modm: driver: ltc2984 modm_architecture_fiber modm: architecture: fiber modm_driver_ltc2984-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_ltc2984-&gt;modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_ltc2984-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ltc2984-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-max31855/","title":"MAX31855 Thermocouple-to-Digital Converter","text":"<p>lbuild module: <code>modm:driver:max31855</code></p> <p>Datasheet</p>"},{"location":"reference/module/modm-driver-max31855/#dependencies","title":"Dependencies","text":"<p> modm:driver:max31855 modm_driver_max31855 modm: driver: max31855 modm_architecture_fiber modm: architecture: fiber modm_driver_max31855-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_max31855-&gt;modm_architecture_gpio modm_architecture_spi_device modm: architecture: spi.device modm_driver_max31855-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-max31865/","title":"MAX31865 RTD-to-Digital Converter","text":"<p>lbuild module: <code>modm:driver:max31865</code></p> <p>Datasheet</p>"},{"location":"reference/module/modm-driver-max31865/#dependencies","title":"Dependencies","text":"<p> modm:driver:max31865 modm_driver_max31865 modm: driver: max31865 modm_architecture_fiber modm: architecture: fiber modm_driver_max31865-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_max31865-&gt;modm_architecture_gpio modm_architecture_spi_device modm: architecture: spi.device modm_driver_max31865-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-max6966/","title":"MAX6966 8-bit PWM Driver","text":"<p>lbuild module: <code>modm:driver:max6966</code></p> <p>10-channel, daisy-chainable, constant-current sink, 8bit PWM LED driver.</p>"},{"location":"reference/module/modm-driver-max6966/#dependencies","title":"Dependencies","text":"<p> modm:driver:max6966 modm_driver_max6966 modm: driver: max6966 modm_architecture_fiber modm: architecture: fiber modm_driver_max6966-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_max6966-&gt;modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_max6966-&gt;modm_architecture_spi </p>"},{"location":"reference/module/modm-driver-max7219/","title":"MAX7219 Display","text":"<p>lbuild module: <code>modm:driver:max7219</code></p>"},{"location":"reference/module/modm-driver-max7219/#dependencies","title":"Dependencies","text":"<p> modm:driver:max7219 modm_driver_max7219 modm: driver: max7219 modm_architecture_spi modm: architecture: spi modm_driver_max7219-&gt;modm_architecture_spi modm_ui_display modm: ui: display modm_driver_max7219-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-mcp23x17/","title":"MCP23x17 16-Bit I/O Expander","text":"<p>lbuild module: <code>modm:driver:mcp23x17</code></p> <p>Port GPB is the high byte, GPA the low byte. The lower three address bits can be configured: <code>0100abc</code>.</p> <p>Notice that you can specify multiple pins at the same time for functions with argument type <code>Pins</code>, either by ORing the according pins, or converting a 16bit value using the <code>Pins(uint16_t)</code> converting constructor.</p> <p>Other functions with argument type <code>Pin</code> can only take one pin. If you want to operate on all 16bit, use the <code>get(Inputs|Outputs|Directions|Polarities)()</code> getters.</p>"},{"location":"reference/module/modm-driver-mcp23x17/#dependencies","title":"Dependencies","text":"<p> modm:driver:mcp23x17 modm_driver_mcp23x17 modm: driver: mcp23x17 modm_architecture_fiber modm: architecture: fiber modm_driver_mcp23x17-&gt;modm_architecture_fiber modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_mcp23x17-&gt;modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_mcp23x17-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_mcp23x17-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_mcp23x17-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-mcp2515/","title":"MPC2515 External CAN Controller","text":"<p>lbuild module: <code>modm:driver:mcp2515</code></p>"},{"location":"reference/module/modm-driver-mcp2515/#options","title":"Options","text":""},{"location":"reference/module/modm-driver-mcp2515/#clock","title":"clock","text":"<p>Used clock for the MCP2515. The device configuration is selected according to the clock speed.</p> <p>Default: <code>16MHz</code> Inputs: <code>[16MHz, 20MHz]</code> </p>"},{"location":"reference/module/modm-driver-mcp2515/#dependencies","title":"Dependencies","text":"<p> modm:driver:mcp2515 modm_driver_mcp2515 modm: driver: mcp2515 modm_architecture_accessor modm: architecture: accessor modm_driver_mcp2515-&gt;modm_architecture_accessor modm_architecture_assert modm: architecture: assert modm_driver_mcp2515-&gt;modm_architecture_assert modm_architecture_can modm: architecture: can modm_driver_mcp2515-&gt;modm_architecture_can modm_architecture_clock modm: architecture: clock modm_driver_mcp2515-&gt;modm_architecture_clock modm_architecture_fiber modm: architecture: fiber modm_driver_mcp2515-&gt;modm_architecture_fiber modm_debug modm: debug modm_driver_mcp2515-&gt;modm_debug </p>"},{"location":"reference/module/modm-driver-mcp3008/","title":"MCP3004/MCP3008 ADC","text":"<p>lbuild module: <code>modm:driver:mcp3008</code></p> <p>MCP3004/3008 are 10-bit 200 ksps SAR ADCs with SPI interface and 4/8 channels.</p>"},{"location":"reference/module/modm-driver-mcp3008/#dependencies","title":"Dependencies","text":"<p> modm:driver:mcp3008 modm_driver_mcp3008 modm: driver: mcp3008 modm_architecture_fiber modm: architecture: fiber modm_driver_mcp3008-&gt;modm_architecture_fiber modm_architecture_spi_device modm: architecture: spi.device modm_driver_mcp3008-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-mcp7941x/","title":"MCP79410/MCP79411/MCP79412","text":"<p>lbuild module: <code>modm:driver:mcp7941x</code></p> <p>Battery-Backed I2C Real-Time Clock/Calendar with SRAM, EEPROM and Protected EEPROM</p> <p>MCP7941x datasheet</p>"},{"location":"reference/module/modm-driver-mcp7941x/#dependencies","title":"Dependencies","text":"<p> modm:driver:mcp7941x modm_driver_mcp7941x modm: driver: mcp7941x modm_architecture_fiber modm: architecture: fiber modm_driver_mcp7941x-&gt;modm_architecture_fiber modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_mcp7941x-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_mcp7941x-&gt;modm_architecture_register </p>"},{"location":"reference/module/modm-driver-mcp990x/","title":"Minimal driver for MCP9902/\u00be temperature sensor.","text":"<p>lbuild module: <code>modm:driver:mcp990x</code></p> <p>Only I2c is supported. SMBUS alert functions and power saving modes are not implemented.</p>"},{"location":"reference/module/modm-driver-mcp990x/#dependencies","title":"Dependencies","text":"<p> modm:driver:mcp990x modm_driver_mcp990x modm: driver: mcp990x modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_mcp990x-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_mcp990x-&gt;modm_architecture_register </p>"},{"location":"reference/module/modm-driver-memory_bus/","title":"Parallel Busses","text":"<p>lbuild module: <code>modm:driver:memory_bus</code></p>"},{"location":"reference/module/modm-driver-memory_bus/#dependencies","title":"Dependencies","text":"<p> modm:driver:memory_bus modm_driver_memory_bus modm: driver: memory_bus modm_architecture_fiber modm: architecture: fiber modm_driver_memory_bus-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_memory_bus-&gt;modm_architecture_gpio </p>"},{"location":"reference/module/modm-driver-mmc5603/","title":"MMC5603 3-Axis Digital Magnetometer","text":"<p>lbuild module: <code>modm:driver:mmc5603</code></p> <p>The MMC5603NJ is a monolithic complete 3-axis AMR magnetic sensor with on-chip signal processing and integrated I2C bus.</p> <p>It can measure magnetic fields within the full scale range of \u00b130 Gauss (G), with up to 0.0625mG per LSB resolution at 20bits operation mode and 2mG total RMS noise level, enabling heading accuracy of \u00b11\u00b0 in electronic compass applications.</p> <p>An integrated SET/RESET function provides for the elimination of error due to Null Field output change with temperature. In addition it clears the sensors of any residual magnetic polarization resulting from exposure to strong external magnets. The SET/RESET function can be performed for each measurement or periodically as the specific application requires.</p> <p>The MMC5603NJ is in wafer level package with an ultra-small size of 0.8x0.8x0.4mm and with an operating temperature range from -40\u00b0C to +85\u00b0C.</p>"},{"location":"reference/module/modm-driver-mmc5603/#dependencies","title":"Dependencies","text":"<p> modm:driver:mmc5603 modm_driver_mmc5603 modm: driver: mmc5603 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_mmc5603-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_mmc5603-&gt;modm_architecture_register modm_math_utils modm: math: utils modm_driver_mmc5603-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-ms5611/","title":"MS5611 Barometric Pressure Sensor","text":"<p>lbuild module: <code>modm:driver:ms5611</code></p> <p>This barometric pressure sensor is optimized for altimeters and variometers with an altitude resolution of 10 cm.</p>"},{"location":"reference/module/modm-driver-ms5611/#dependencies","title":"Dependencies","text":"<p> modm:driver:ms5611 modm_driver_ms5611 modm: driver: ms5611 modm_architecture_fiber modm: architecture: fiber modm_driver_ms5611-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_ms5611-&gt;modm_architecture_gpio modm_architecture_spi_device modm: architecture: spi.device modm_driver_ms5611-&gt;modm_architecture_spi_device modm_math_utils modm: math: utils modm_driver_ms5611-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-ms5837/","title":"MS5837 Pressure Sensor","text":"<p>lbuild module: <code>modm:driver:ms5837</code></p> <p>This sensor is optimized for water depth measurement systems with a resolution of 0.2cm.</p>"},{"location":"reference/module/modm-driver-ms5837/#dependencies","title":"Dependencies","text":"<p> modm:driver:ms5837 modm_driver_ms5837 modm: driver: ms5837 modm_architecture_fiber modm: architecture: fiber modm_driver_ms5837-&gt;modm_architecture_fiber modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ms5837-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_ms5837-&gt;modm_architecture_register modm_math_utils modm: math: utils modm_driver_ms5837-&gt;modm_math_utils modm_processing_timer modm: processing: timer modm_driver_ms5837-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-driver-nokia5110/","title":"Nokia 5110 Displays","text":"<p>lbuild module: <code>modm:driver:nokia5110</code></p>"},{"location":"reference/module/modm-driver-nokia5110/#dependencies","title":"Dependencies","text":"<p> modm:driver:nokia5110 modm_driver_nokia5110 modm: driver: nokia5110 modm_architecture_spi modm: architecture: spi modm_driver_nokia5110-&gt;modm_architecture_spi modm_ui_display modm: ui: display modm_driver_nokia5110-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-nrf24/","title":"NRF24 Drivers","text":"<p>lbuild module: <code>modm:driver:nrf24</code></p>"},{"location":"reference/module/modm-driver-nrf24/#dependencies","title":"Dependencies","text":"<p> modm:driver:nrf24 modm_driver_nrf24 modm: driver: nrf24 modm_architecture_clock modm: architecture: clock modm_driver_nrf24-&gt;modm_architecture_clock modm_architecture_fiber modm: architecture: fiber modm_driver_nrf24-&gt;modm_architecture_fiber modm_architecture_register modm: architecture: register modm_driver_nrf24-&gt;modm_architecture_register modm_architecture_spi modm: architecture: spi modm_driver_nrf24-&gt;modm_architecture_spi modm_debug modm: debug modm_driver_nrf24-&gt;modm_debug modm_math_utils modm: math: utils modm_driver_nrf24-&gt;modm_math_utils modm_processing_timer modm: processing: timer modm_driver_nrf24-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-driver-parallel_tft_display/","title":"Parallel Bus TFT Display","text":"<p>lbuild module: <code>modm:driver:parallel_tft_display</code></p>"},{"location":"reference/module/modm-driver-parallel_tft_display/#dependencies","title":"Dependencies","text":"<p> modm:driver:parallel_tft_display modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_ui_display modm: ui: display modm_driver_parallel_tft_display-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-pat9125el/","title":"PAT9125EL Motion Sensor","text":"<p>lbuild module: <code>modm:driver:pat9125el</code></p>"},{"location":"reference/module/modm-driver-pat9125el/#dependencies","title":"Dependencies","text":"<p> modm:driver:pat9125el modm_driver_pat9125el modm: driver: pat9125el modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pat9125el-&gt;modm_architecture_i2c_device modm_debug modm: debug modm_driver_pat9125el-&gt;modm_debug modm_math_geometry modm: math: geometry modm_driver_pat9125el-&gt;modm_math_geometry </p>"},{"location":"reference/module/modm-driver-pca8574/","title":"PCA8574 8-Bit I/O Expander","text":"<p>lbuild module: <code>modm:driver:pca8574</code></p>"},{"location":"reference/module/modm-driver-pca8574/#dependencies","title":"Dependencies","text":"<p> modm:driver:pca8574 modm_driver_pca8574 modm: driver: pca8574 modm_architecture_fiber modm: architecture: fiber modm_driver_pca8574-&gt;modm_architecture_fiber modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_pca8574-&gt;modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca8574-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_pca8574-&gt;modm_architecture_register </p>"},{"location":"reference/module/modm-driver-pca9535/","title":"PCA9535 16-Bit I/O Expander","text":"<p>lbuild module: <code>modm:driver:pca9535</code></p> <p>Also software-compatible with PCA9555. The lower three address bits can be configured: <code>0100abc</code>.</p> <p>Notice that you can specify multiple pins at the same time for functions with argument type <code>Pins</code>, either by ORing the according pins, or converting a 16-bit value using the <code>Pins(uint16_t)</code> converting constructor.</p> <p>Other functions with argument type <code>Pin</code> can only take one pin. If you want to operate on all 16-bit, use the <code>get(Inputs|Outputs|Directions|Polarities)()</code> getters.</p> <pre><code>using Pin = expander.Pin;\nusing Pins = expander.Pins;\n\nexpander.setOutput(Pins(0xff); // set all lower 8 pins to output\nexpander.set(Pin::P0_0);       // set only pin 00 high\nexpander.reset(Pin::P0_1 | Pin::P0_2); // reset 2 pins\nexpander.toggle(Pin::P0_3 | Pin::P0_4 | Pin::P0_5);    // toggle 3 pins\n\nexpander.readInput();  // transfer input states from the external chip\nbool high = expander.read(Pin::P1_0);    // check a single pin\n\nPins input = expander.getInputs();   // get all 16 input states\nbool isAnyPinHigh = input.any(Pin::P1_1 | Pin::P1_2 | Pin::P1_3); // check if any of 3 pins is high\n</code></pre>"},{"location":"reference/module/modm-driver-pca9535/#dependencies","title":"Dependencies","text":"<p> modm:driver:pca9535 modm_driver_pca9535 modm: driver: pca9535 modm_architecture_fiber modm: architecture: fiber modm_driver_pca9535-&gt;modm_architecture_fiber modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_pca9535-&gt;modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9535-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_pca9535-&gt;modm_architecture_register modm_math_utils modm: math: utils modm_driver_pca9535-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-pca9548a/","title":"PCA9548A/TCA9548A I2C Switch","text":"<p>lbuild module: <code>modm:driver:pca9548a</code></p> <p>This bidirectional 8-channel switch with reset can be used to multiplex I2C busses.</p>"},{"location":"reference/module/modm-driver-pca9548a/#dependencies","title":"Dependencies","text":"<p> modm:driver:pca9548a modm_driver_pca9548a modm: driver: pca9548a modm_architecture_fiber modm: architecture: fiber modm_driver_pca9548a-&gt;modm_architecture_fiber modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9548a-&gt;modm_architecture_i2c_device modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_driver_pca9548a-&gt;modm_architecture_i2c_multiplexer </p>"},{"location":"reference/module/modm-driver-pca9685/","title":"PCA9685 12-bit PWM Driver","text":"<p>lbuild module: <code>modm:driver:pca9685</code></p> <p>PCA9685 16-channel, 12-bit PWM LED controller via I2C-Bus.</p>"},{"location":"reference/module/modm-driver-pca9685/#dependencies","title":"Dependencies","text":"<p> modm:driver:pca9685 modm_driver_pca9685 modm: driver: pca9685 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9685-&gt;modm_architecture_i2c_device </p>"},{"location":"reference/module/modm-driver-qmc5883l/","title":"QMC5883L 3-Axis Digital Magnetometer","text":"<p>lbuild module: <code>modm:driver:qmc5883l</code></p> <p>The QMC5883L is a multi-chip three-axis magnetic sensor. This surface-mount, small sized chip has integrated magnetic sensors with signal condition ASIC, targeted for high precision applications such as compassing, navigation and gaming in drone, robot, mobile and personal hand-held devices.</p> <p>The QMC5883L is based on state-of-the-art, high resolution, magneto-resistive technology licensed from Honeywell AMR technology.  Along with custom-designed 16-bit ADC ASIC, it offers the advantages of low noise, high accuracy, low power consumption, offset cancellation and temperature compensation. QMC5883L enables 1\u00b0 to 2\u00b0 compass heading accuracy. The I\u00b2C serial bus allows for easy interface.</p>"},{"location":"reference/module/modm-driver-qmc5883l/#dependencies","title":"Dependencies","text":"<p> modm:driver:qmc5883l modm_driver_qmc5883l modm: driver: qmc5883l modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_qmc5883l-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_qmc5883l-&gt;modm_architecture_register modm_math_utils modm: math: utils modm_driver_qmc5883l-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-sh1106/","title":"SH1106 Display","text":"<p>lbuild module: <code>modm:driver:sh1106</code></p>"},{"location":"reference/module/modm-driver-sh1106/#dependencies","title":"Dependencies","text":"<p> modm:driver:sh1106 modm_driver_sh1106 modm: driver: sh1106 modm_driver_ssd1306 modm: driver: ssd1306 modm_driver_sh1106-&gt;modm_driver_ssd1306 </p>"},{"location":"reference/module/modm-driver-siemens_s65/","title":"Siemens S65 Display","text":"<p>lbuild module: <code>modm:driver:siemens_s65</code></p>"},{"location":"reference/module/modm-driver-siemens_s65/#dependencies","title":"Dependencies","text":"<p> modm:driver:siemens_s65 modm_driver_siemens_s65 modm: driver: siemens_s65 modm_architecture_fiber modm: architecture: fiber modm_driver_siemens_s65-&gt;modm_architecture_fiber modm_architecture_spi modm: architecture: spi modm_driver_siemens_s65-&gt;modm_architecture_spi modm_ui_display modm: ui: display modm_driver_siemens_s65-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-siemens_s75/","title":"Siemens S75/CX75/C81/M75 Display","text":"<p>lbuild module: <code>modm:driver:siemens_s75</code></p> <p>The controller in displays manufactured by Alps is a SOLOMON SYSTECH SSD1286 which can drive color displays of up to 132 x 176 pixels in 18 bit color.</p> <p>The portrait mode is a bit more 'native' for this display because <code>modm::GraphicDisplay</code> requests that the vertical resolution is divisible by 8.</p> <p>In portrait mode the connector is at the top. In landscapeLeft  mode the connector is at the left border. In landscapeRight mode the connector is at the right border.</p> <p>Pinout at LCD:</p> <pre><code> 1  IN  CD         Command / Data                      Low = Command (Register) High = Data.\n 2  IN  RESET      Resets the display.  Active low.    Low = Reset,             High = No reset.\n 3  IN  CS         Chip select.         Active low.    Low = Chip is selected,  High = Chip is not selected.\n 4  OUT VD         Sync Output.         Unused.\n 5      GND        Supply\n 6  IN  D0         Bit 0 of parallel data\n 7      3V3 (2V9)  Supply\n 8      GND        Supply\n 9      VLED +     Supply Backlight\n10      VLED -     Supply Backlight\n11      GND        Supply\n12  IN  RD         Read Strobe.         Must be tied high.\n13  IN  WR         Write Strobe.        High-to-Low strobe write data to display memory.\n14  IN  D1         Bit 1 of parallel data.\n15  IN  D2         Bit 2 of parallel data.\n16  IN  D3         Bit 3 of parallel data.\n17  IN  D4         Bit 4 of parallel data.\n18  IN  D5         Bit 5 of parallel data.\n19  IN  D6         Bit 6 of parallel data.\n20  IN  D7         Bit 7 of parallel data.\n</code></pre> <p>Pin 1 is unmarked. Pin 5 can be recognized by a thicker trace which is GND.</p> <p>The backlight (VLED +, VLED -) consists of four white LEDs in series. The forward voltage is about 12 volts.</p>"},{"location":"reference/module/modm-driver-siemens_s75/#dependencies","title":"Dependencies","text":"<p> modm:driver:siemens_s75 modm_driver_siemens_s75 modm: driver: siemens_s75 modm_architecture_fiber modm: architecture: fiber modm_driver_siemens_s75-&gt;modm_architecture_fiber modm_driver_memory_bus modm: driver: memory_bus modm_driver_siemens_s75-&gt;modm_driver_memory_bus modm_ui_display modm: ui: display modm_driver_siemens_s75-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-sk6812/","title":"SK6812 RGBW Driver","text":"<p>lbuild module: <code>modm:driver:sk6812</code></p> <p>Drives any number of chained SK6812 RGBW LEDs using a 3-bit SPI encoding (0 -&gt; 100, 1 -&gt; 110) running at 3 MHz. Thus, writing one LED takes 32\u00b5s and 12 bytes of memory.</p> <p>There are several caveats:</p> <ol> <li>This only provides a blocking write API, due to technical limitations.</li> <li>Atomicity is not enforced, this should be done externally if required.</li> <li>The memory footprint is 4x as large, due to the bit stuffing for SPI.</li> <li>There is no enforced reset period of at least 50\u00b5s after the write is finished,    it is up to the user to not trigger another write too early.</li> </ol> <p>This driver directly accesses the STM32 HAL to keep the transmit register full, due to a lack of DMA capability in modm, thus this driver is STM32-only for now.</p> <p>SystemClock Limitations</p> <p>This driver requires a 3 MHz \u00b110% SPI clock in order to get the protocol timing right. Depending on your device clock tree and the SPI prescalers, this might require lowering the frequency of the entire device! If this is unacceptable, consider using APA102.</p> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-driver-sk6812/#dependencies","title":"Dependencies","text":"<p> modm:driver:sk6812 modm_driver_sk6812 modm: driver: sk6812 modm_architecture_spi modm: architecture: spi modm_driver_sk6812-&gt;modm_architecture_spi modm_architecture_unaligned modm: architecture: unaligned modm_driver_sk6812-&gt;modm_architecture_unaligned modm_math_units modm: math: units modm_driver_sk6812-&gt;modm_math_units modm_ui_color modm: ui: color modm_driver_sk6812-&gt;modm_ui_color </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-driver-sk9822/","title":"SK9822 RGB LED Driver","text":"<p>lbuild module: <code>modm:driver:sk9822</code></p> <p>Drives any number of chained SK9822 RGB LEDs using SPI signals SCK and MOSI up to a few dozen MHz. Due to the synchronous clock, there are no special restrictions on protocol timing, making this driver safe to use with interrupts enabled and/or with an RTOS.</p> <p>The internal data buffer size is 4B for start of frame, 4B for every LED and 1B for every 16 LEDs as end of frame.</p> <p>References:</p> <ul> <li>\"SK9822 \u2013 a clone of the APA102?\"</li> </ul>"},{"location":"reference/module/modm-driver-sk9822/#dependencies","title":"Dependencies","text":"<p> modm:driver:sk9822 modm_driver_sk9822 modm: driver: sk9822 modm_driver_apa102 modm: driver: apa102 modm_driver_sk9822-&gt;modm_driver_apa102 </p>"},{"location":"reference/module/modm-driver-ssd1306/","title":"SSD1306 Display","text":"<p>lbuild module: <code>modm:driver:ssd1306</code></p>"},{"location":"reference/module/modm-driver-ssd1306/#dependencies","title":"Dependencies","text":"<p> modm:driver:ssd1306 modm_driver_ssd1306 modm: driver: ssd1306 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ssd1306-&gt;modm_architecture_i2c_device modm_processing_timer modm: processing: timer modm_driver_ssd1306-&gt;modm_processing_timer modm_ui_display modm: ui: display modm_driver_ssd1306-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-st7586s/","title":"ST7586S 4-level grayscale LCD controller","text":"<p>lbuild module: <code>modm:driver:st7586s</code></p>"},{"location":"reference/module/modm-driver-st7586s/#dependencies","title":"Dependencies","text":"<p> modm:driver:st7586s modm_driver_st7586s modm: driver: st7586s modm_architecture_fiber modm: architecture: fiber modm_driver_st7586s-&gt;modm_architecture_fiber modm_ui_display modm: ui: display modm_driver_st7586s-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-st7789/","title":"ST7789 full-color LCD controller","text":"<p>lbuild module: <code>modm:driver:st7789</code></p>"},{"location":"reference/module/modm-driver-st7789/#dependencies","title":"Dependencies","text":"<p> modm:driver:st7789 modm_driver_st7789 modm: driver: st7789 modm_architecture_fiber modm: architecture: fiber modm_driver_st7789-&gt;modm_architecture_fiber modm_ui_display modm: ui: display modm_driver_st7789-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-driver-stts22h/","title":"STTS22H temperature sensor","text":"<p>lbuild module: <code>modm:driver:stts22h</code></p>"},{"location":"reference/module/modm-driver-stts22h/#dependencies","title":"Dependencies","text":"<p> modm:driver:stts22h modm_driver_stts22h modm: driver: stts22h modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_stts22h-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_stts22h-&gt;modm_architecture_register </p>"},{"location":"reference/module/modm-driver-stusb4500/","title":"STUSB4500 USB PD controller","text":"<p>lbuild module: <code>modm:driver:stusb4500</code></p>"},{"location":"reference/module/modm-driver-stusb4500/#standalone-usb-pd-controller-for-power-sinking-devices","title":"Standalone USB PD controller for power sinking devices","text":"<p>The STUSB4500 is a USB power delivery controller for USB power sink devices. See https://www.st.com/en/interfaces-and-transceivers/stusb4500.html</p> <p>The STUSB4500 is connected via I2C to the microcontroller.</p> <p>This driver only implements basic functionality for now.</p>"},{"location":"reference/module/modm-driver-stusb4500/#dependencies","title":"Dependencies","text":"<p> modm:driver:stusb4500 modm_driver_stusb4500 modm: driver: stusb4500 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_stusb4500-&gt;modm_architecture_i2c_device </p>"},{"location":"reference/module/modm-driver-sx1276/","title":"Semtech SX1276 Driver","text":"<p>lbuild module: <code>modm:driver:sx1276</code></p>"},{"location":"reference/module/modm-driver-sx1276/#dependencies","title":"Dependencies","text":"<p> modm:driver:sx1276 modm_driver_sx1276 modm: driver: sx1276 modm_architecture_register modm: architecture: register modm_driver_sx1276-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_sx1276-&gt;modm_architecture_spi_device modm_debug modm: debug modm_driver_sx1276-&gt;modm_debug </p>"},{"location":"reference/module/modm-driver-sx128x/","title":"Semtech SX1280/SX1281 Driver","text":"<p>lbuild module: <code>modm:driver:sx128x</code></p> <p>Long Range, Low Power, 2.4 GHz Transceiver with Ranging Capability</p> <p>The SX128x driver UART transport layer is untested</p>"},{"location":"reference/module/modm-driver-sx128x/#dependencies","title":"Dependencies","text":"<p> modm:driver:sx128x modm_driver_sx128x modm: driver: sx128x modm_architecture_fiber modm: architecture: fiber modm_driver_sx128x-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_sx128x-&gt;modm_architecture_gpio modm_architecture_spi_device modm: architecture: spi.device modm_driver_sx128x-&gt;modm_architecture_spi_device modm_architecture_uart_device modm: architecture: uart.device modm_driver_sx128x-&gt;modm_architecture_uart_device modm_math_utils modm: math: utils modm_driver_sx128x-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-tcs3414/","title":"TCS3414 Digital Color Sensor","text":"<p>lbuild module: <code>modm:driver:tcs3414</code></p>"},{"location":"reference/module/modm-driver-tcs3414/#dependencies","title":"Dependencies","text":"<p> modm:driver:tcs3414 modm_driver_tcs3414 modm: driver: tcs3414 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tcs3414-&gt;modm_architecture_i2c_device modm_ui_color modm: ui: color modm_driver_tcs3414-&gt;modm_ui_color </p>"},{"location":"reference/module/modm-driver-tcs3472/","title":"TCS3472X Digital Color Sensor","text":"<p>lbuild module: <code>modm:driver:tcs3472</code></p>"},{"location":"reference/module/modm-driver-tcs3472/#dependencies","title":"Dependencies","text":"<p> modm:driver:tcs3472 modm_driver_tcs3472 modm: driver: tcs3472 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tcs3472-&gt;modm_architecture_i2c_device modm_math_utils modm: math: utils modm_driver_tcs3472-&gt;modm_math_utils modm_ui_color modm: ui: color modm_driver_tcs3472-&gt;modm_ui_color </p>"},{"location":"reference/module/modm-driver-terminal/","title":"Terminal Output","text":"<p>lbuild module: <code>modm:driver:terminal</code></p>"},{"location":"reference/module/modm-driver-terminal/#dependencies","title":"Dependencies","text":"<p> modm:driver:terminal modm_driver_terminal modm: driver: terminal modm_io modm: io modm_driver_terminal-&gt;modm_io </p>"},{"location":"reference/module/modm-driver-tlc594x/","title":"TLC594* 12-bit PWM Driver","text":"<p>lbuild module: <code>modm:driver:tlc594x</code></p> <p>TLC594* multi-channel, daisy-chainable, constant-current sink, 12bit PWM LED driver.</p>"},{"location":"reference/module/modm-driver-tlc594x/#dependencies","title":"Dependencies","text":"<p> modm:driver:tlc594x modm_driver_tlc594x modm: driver: tlc594x modm_architecture_fiber modm: architecture: fiber modm_driver_tlc594x-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_tlc594x-&gt;modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_tlc594x-&gt;modm_architecture_spi </p>"},{"location":"reference/module/modm-driver-tmp102/","title":"TMP102 Thermometer","text":"<p>lbuild module: <code>modm:driver:tmp102</code></p> <p>The TMP102 is a digital temperature sensor with an I2C interface and measures temperature over a range of -40 to +125 deg Celsius with a resolution of 1/16 (0.0625) deg C and an accuracy of up to 0.5 deg C.</p> <p>The sensor has a default refresh rate of 4Hz but can be set from 0.25Hz up to 33Hz using <code>setUpdateRate(rate)</code>. The sensor will then read itself when calling the <code>update()</code> method frequently.</p> <p>However, you may manually start a conversion with <code>startConversion()</code>, wait for 30ms and then <code>readTemperature()</code> to achieve other (less frequent) update rates.</p>"},{"location":"reference/module/modm-driver-tmp102/#dependencies","title":"Dependencies","text":"<p> modm:driver:tmp102 modm_driver_tmp102 modm: driver: tmp102 modm_architecture_fiber modm: architecture: fiber modm_driver_tmp102-&gt;modm_architecture_fiber modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tmp102-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_tmp102-&gt;modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_tmp102-&gt;modm_driver_lm75 modm_math_utils modm: math: utils modm_driver_tmp102-&gt;modm_math_utils modm_processing_timer modm: processing: timer modm_driver_tmp102-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-driver-tmp12x/","title":"TMP121/123/125 Thermometer","text":"<p>lbuild module: <code>modm:driver:tmp12x</code></p> <p>TMP121/123/125 temperature sensor driver</p> <p>This driver supports the TMP125 device but not its optional shutdown function.</p>"},{"location":"reference/module/modm-driver-tmp12x/#dependencies","title":"Dependencies","text":"<p> modm:driver:tmp12x modm_driver_tmp12x modm: driver: tmp12x modm_architecture_fiber modm: architecture: fiber modm_driver_tmp12x-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_driver_tmp12x-&gt;modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_tmp12x-&gt;modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_tmp12x-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-tmp175/","title":"TMP175 Thermometer","text":"<p>lbuild module: <code>modm:driver:tmp175</code></p> <p>TMP175 digital temperature sensor driver.</p> <p>The TMP175 is a digital temperature sensor with a two-wire interface and measures temperature over a range of -40 to +125 deg Celsius with a resolution of 1/16 (0.0625) deg C and an accuracy of up to 1.5 deg C.</p> <p>The sensor has a default refresh rate of 4Hz but can be raised up to 30Hz by repeatedly manually starting a conversion (with startConversion()), which lasts between 30ms and 240ms depending on resolution.</p>"},{"location":"reference/module/modm-driver-tmp175/#dependencies","title":"Dependencies","text":"<p> modm:driver:tmp175 modm_driver_tmp175 modm: driver: tmp175 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tmp175-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_tmp175-&gt;modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_tmp175-&gt;modm_driver_lm75 modm_processing_timer modm: processing: timer modm_driver_tmp175-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-driver-touch2046/","title":"TSC2046/x2046 Resistive Touch Controller","text":"<p>lbuild module: <code>modm:driver:touch2046</code></p> <p>The TSC2046 by Texas Instruments is a popular touchscreen controller on cheap displays.</p> <p>https://www.ti.com/lit/ds/symlink/tsc2046.pdf</p> <p>There are many compatible devices from other manufacturers available, such as the XPT2046 by XPTEK or \"2046\" labeled chips from unknown manufacturers. All of these are compatible with the TSC2046.</p>"},{"location":"reference/module/modm-driver-touch2046/#dependencies","title":"Dependencies","text":"<p> modm:driver:touch2046 modm_driver_touch2046 modm: driver: touch2046 modm_architecture_fiber modm: architecture: fiber modm_driver_touch2046-&gt;modm_architecture_fiber modm_architecture_spi_device modm: architecture: spi.device modm_driver_touch2046-&gt;modm_architecture_spi_device </p>"},{"location":"reference/module/modm-driver-vl53l0/","title":"VL53L0X Proximity Sensor","text":"<p>lbuild module: <code>modm:driver:vl53l0</code></p>"},{"location":"reference/module/modm-driver-vl53l0/#dependencies","title":"Dependencies","text":"<p> modm:driver:vl53l0 modm_driver_vl53l0 modm: driver: vl53l0 modm_architecture_accessor modm: architecture: accessor modm_driver_vl53l0-&gt;modm_architecture_accessor modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_vl53l0-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_vl53l0-&gt;modm_architecture_register modm_debug modm: debug modm_driver_vl53l0-&gt;modm_debug </p>"},{"location":"reference/module/modm-driver-vl6180/","title":"VL6180X Proximity Sensor","text":"<p>lbuild module: <code>modm:driver:vl6180</code></p>"},{"location":"reference/module/modm-driver-vl6180/#dependencies","title":"Dependencies","text":"<p> modm:driver:vl6180 modm_driver_vl6180 modm: driver: vl6180 modm_architecture_accessor modm: architecture: accessor modm_driver_vl6180-&gt;modm_architecture_accessor modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_vl6180-&gt;modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_vl6180-&gt;modm_architecture_register modm_architecture_unaligned modm: architecture: unaligned modm_driver_vl6180-&gt;modm_architecture_unaligned modm_math_utils modm: math: utils modm_driver_vl6180-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-driver-ws2812/","title":"WS2812 Driver","text":"<p>lbuild module: <code>modm:driver:ws2812</code></p> <p>Drives any number of chained WS2812 LEDs using a 3-bit SPI encoding (0 -&gt; 100, 1 -&gt; 110) running at 3 MHz. Thus, writing one LED takes 24\u00b5s and 9 bytes of memory.</p> <p>There are several caveats:</p> <ol> <li>This only provides a blocking write API, due to technical limitations.</li> <li>Atomicity is not enforced, this should be done externally if required.</li> <li>The memory footprint is 3x as large, due to the bit stuffing for SPI.</li> <li>There is no enforced reset period of at least 50\u00b5s after the write is finished,    it is up to the user to not trigger another write too early.</li> </ol> <p>This driver directly accesses the STM32 HAL to keep the transmit register full, due to a lack of DMA capability in modm, thus this driver is STM32-only for now.</p> <p>SystemClock Limitations</p> <p>This driver requires a 3 MHz \u00b110% SPI clock in order to get the protocol timing right. Depending on your device clock tree and the SPI prescalers, this might require lowering the frequency of the entire device! If this is unacceptable, consider using APA102.</p> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-driver-ws2812/#dependencies","title":"Dependencies","text":"<p> modm:driver:ws2812 modm_driver_ws2812 modm: driver: ws2812 modm_architecture_spi modm: architecture: spi modm_driver_ws2812-&gt;modm_architecture_spi modm_architecture_unaligned modm: architecture: unaligned modm_driver_ws2812-&gt;modm_architecture_unaligned modm_math_units modm: math: units modm_driver_ws2812-&gt;modm_math_units modm_ui_color modm: ui: color modm_driver_ws2812-&gt;modm_ui_color </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-driver/","title":"External Device Drivers","text":"<p>lbuild module: <code>modm:driver</code></p>"},{"location":"reference/module/modm-etl/","title":"Embedded Template Library (ETL)","text":"<p>lbuild module: <code>modm:etl</code></p> <p>ETL is a MIT licensed template library which augments the STL with embedded friendly containers and algorithms.</p> <ul> <li>https://www.etlcpp.com/</li> <li>https://github.com/ETLCPP/etl</li> </ul>"},{"location":"reference/module/modm-etl/#configuration","title":"Configuration","text":"<p>This module pre-configures ETL by adding these macros:</p> <ul> <li><code>ETL_TARGET_OS_FREERTOS</code>: if built together with the <code>modm:freertos</code> module.</li> </ul> <p>To add your own configuration you can create a <code>&lt;etl_profile.h&gt;</code> file which will automatically be included by ETL.</p>"},{"location":"reference/module/modm-etl/#debugging-etl","title":"Debugging ETL","text":"<p>This module reroutes ETLs assertions to <code>modm_assert</code> but only for the default configuration. Defining any of <code>ETL_NO_CHECKS</code>, <code>ETL_THROW_EXCEPTIONS</code> or <code>ETL_LOG_ERRORS</code> will use original ETL mechanism.</p> <p>Make sure you have implemented the <code>modm_abandon</code> handler! See the <code>modm:architecture:assert</code> module for details.</p> <p>An ETL assertion failure in release mode is fairly cryptic:</p> <pre><code>Assertion 'etl' failed!\nAbandoning...\n</code></pre> <p>If you run this again in debug mode, you'll note a much more detailed assertion description:</p> <pre><code>Assertion 'etl' failed!\n  modm/ext/etl/etl/ipool.h:369 -&gt; \"pool_no_allocation\"\nAbandoning...\n</code></pre>"},{"location":"reference/module/modm-etl/#dependencies","title":"Dependencies","text":"<p> modm:etl modm_etl modm: etl modm_architecture_assert modm: architecture: assert modm_etl-&gt;modm_architecture_assert </p>"},{"location":"reference/module/modm-fatfs-petit/","title":"Petit FatFs: Tiny FAT Filesystem","text":"<p>lbuild module: <code>modm:fatfs.petit</code></p> <p>Petit FatFs is a sub-set of FatFs module for tiny 8-bit microcontrollers. It can be incorporated into the tiny microcontrollers with limited memory even if the RAM size is less than sector size.</p> <p>See http://elm-chan.org/fsw/ff/00index_p.html.</p>"},{"location":"reference/module/modm-fatfs-petit/#configuration","title":"Configuration","text":"<p>To configure Petit FatFs for your project, create a <code>&lt;pffconf_local.h&gt;</code> file, which is included at the beginning of the config, thus overwriting the default settings. Please see the <code>modm/ext/fatfs-petit/pffconf.h</code> file for the available configuration options and their default values.</p> <p>Example <code>&lt;pffconf_local.h&gt;</code> configuration:</p> <pre><code>// Enable directories: pf_opendir(), pf_readdir()\n#define PF_USE_DIR 1\n\n// Enabling writing: pf_write()\n#define PF_USE_WRITE 1\n\n// Use FAT12 file system\n#define PF_FS_FAT12 1\n#define PF_FS_FAT16 0\n#define PF_FS_FAT32 0\n</code></pre>"},{"location":"reference/module/modm-fatfs/","title":"FatFs: FAT Filesystem","text":"<p>lbuild module: <code>modm:fatfs</code></p> <p>FatFs is a generic FAT/exFAT filesystem module for small embedded systems.</p> <p>See http://elm-chan.org/fsw/ff/00index_e.html.</p>"},{"location":"reference/module/modm-fatfs/#configuration","title":"Configuration","text":"<p>This module generates a <code>ffconf.h</code> config file for modm integration with these settings:</p> <ul> <li><code>FF_FS_NORTC = 1</code>: modm does not provide an accurate RTC timekeeping method,                      you must implement that yourself.</li> <li><code>ff_memalloc</code>/<code>ff_memfree</code>: Forwarded to <code>malloc</code> and <code>free</code> as implemented by                               the <code>modm:platform:heap</code> module</li> </ul> <p>To configure FatFs for your project, create a <code>&lt;ffconf_local.h&gt;</code> file, which is included at the beginning of the config, thus overwriting the default settings. Please see the <code>modm/ext/fatfs/ffconf.h</code> file for the available configuration options and their default values.</p> <p>Example <code>&lt;ffconf_local.h&gt;</code> configuration:</p> <pre><code>// Enable directory filtering: f_findfirst(), f_findnext()\n#define FF_USE_FIND 1\n\n// Enable Volume Formatting: f_mkfs()\n#define FF_USE_MKFS 1\n\n// Enable Volume Label: f_setlabel(), f_getlabel()\n#define FF_USE_LABEL 1\n\n// Enable tiny sector buffers\n#define FF_FS_TINY 1\n</code></pre>"},{"location":"reference/module/modm-freertos-tcp-lan8720a/","title":"a:FreeRTOS-Plus-TCP Ethernet via LAN8720A","text":"<p>lbuild module: <code>modm:freertos:tcp:lan8720a</code></p> <p>This module implements TCP over Ethernet via the LAN8720A transceiver.</p> <p>This module is only available for stm32{f4,f7}.</p>"},{"location":"reference/module/modm-freertos-tcp-lan8720a/#dependencies","title":"Dependencies","text":"<p> modm:freertos:tcp:lan8720a modm_freertos_tcp_lan8720a modm: freertos: tcp: lan8720a modm_driver_lan8720a modm: driver: lan8720a modm_freertos_tcp_lan8720a-&gt;modm_driver_lan8720a modm_platform_eth modm: platform: eth modm_freertos_tcp_lan8720a-&gt;modm_platform_eth </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-freertos-tcp/","title":"FreeRTOS+TCP","text":"<p>lbuild module: <code>modm:freertos:tcp</code></p> <p>Amazon FreeRTOS+TCP is a scalable, open source and thread safe TCP/IP stack for FreeRTOS. FreeRTOS+TCP's features and RAM footprint are fully scalable, making it equally applicable to smaller lower throughput microcontrollers as larger higher throughput microprocessors.</p> <p>This module provides the latest FreeRTOS+TCP LTS release integrated with modm:</p> <ul> <li><code>FreeRTOS_printf()</code> and <code>FreeRTOS_debug_printf()</code> forwarded to <code>modm:debug</code>.</li> </ul>"},{"location":"reference/module/modm-freertos-tcp/#configuration","title":"Configuration","text":"<p>This module generates a <code>FreeRTOSIPConfig.h</code> config file for modm integration with these overwritable settings:</p> <ul> <li><code>ipconfigIP_TASK_STACK_SIZE_WORDS</code> = <code>(configMINIMAL_STACK_SIZE * 4)</code></li> <li><code>ipconfigIP_TASK_PRIORITY</code> = <code>(configMAX_PRIORITIES - 2)</code></li> <li><code>FreeRTOS_printf(x)</code> = <code>MODM_LOG_INFO.printf(x)</code></li> <li><code>FreeRTOS_debug_printf(x)</code> = <code>MODM_LOG_DEBUG.printf(x)</code></li> </ul> <p>All other config settings are unchanged by modm and are defaulted by FreeRTOS itself, please refer to the FreeRTOS+TCP Config documentation to understand what each of these do.</p> <p>To change a configuration setting, define a <code>&lt;FreeRTOSIPConfigLocal.h&gt;</code> file, which is included before the optional settings, so you can overwrite them easily.</p> <p>An example <code>&lt;FreeRTOSIPConfigLocal.h&gt;</code> file:</p> <pre><code>// Change IP task stack size\n#define ipconfigIP_TASK_STACK_SIZE_WORDS  1024\n// Enable printing\n#define ipconfigHAS_PRINTF  1\n#define ipconfigHAS_DEBUG_PRINTF  1\n</code></pre> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-freertos/","title":"FreeRTOS","text":"<p>lbuild module: <code>modm:freertos</code></p> <p>Amazon FreeRTOS is an open source, real-time operating system (RTOS) for microcontrollers in small, low-power devices.</p> <p>This module provides the latest FreeRTOS LTS release integrated with modm:</p> <ul> <li>Chooses the right Cortex-M port for the target.</li> <li>Variable tick rate integrated with <code>modm::Clock</code> via <code>modm:platform:clock</code>.</li> <li>Dynamic memory provided by the <code>modm:platform:heap</code> module with thread-safe   locking of Newlib's <code>malloc/free</code>.</li> <li>Assertions integrated into the <code>modm:architecture:assert</code> interface.</li> <li>Interrupt handling integrated with CMSIS NVIC functions.</li> </ul> <p>Note that we recommend using the FreeRTOS API directly and only if you write threaded code that also runs on other platforms (x86 simulators for example) should you consider using the API defined in <code>modm:processing:rtos</code> module.</p>"},{"location":"reference/module/modm-freertos/#configuration","title":"Configuration","text":"<p>This module generates a <code>FreeRTOSConfig.h</code> config file for modm integration with these settings:</p> <ul> <li><code>configASSERT(x)</code> implemented with <code>modm_assert(x, \"freertos\")</code>.</li> <li><code>configCPU_CLOCK_HZ</code> implemented with CMSIS <code>SystemCoreClock</code>.</li> <li><code>configTICK_RATE_HZ</code> set to <code>modm:freertos:frequency</code> or 1kHz on Cortex-M0.</li> <li><code>configSUPPORT_DYNAMIC_ALLOCATION = 1</code> only if used with <code>modm:platform:heap</code>.</li> <li><code>configSUPPORT_STATIC_ALLOCATION = 1</code> always.</li> <li><code>configUSE_TICK_HOOK = 1</code> used by <code>modm:platform:clock</code> to provide <code>modm::Clock</code>.</li> </ul> <p>In addition we define these overwritable default settings:</p> <ul> <li> <p><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> = <code>(__NVIC_PRIO_BITS &lt;&lt; (8u - __NVIC_PRIO_BITS))</code></p> </li> <li> <p><code>configMINIMAL_STACK_SIZE</code> = 128</p> </li> <li><code>configMAX_PRIORITIES</code> = 5</li> <li><code>configUSE_PREEMPTION</code> = 1</li> <li><code>configUSE_IDLE_HOOK</code> = 0</li> <li> <p><code>configUSE_16_BIT_TICKS</code> = 0</p> </li> <li> <p><code>configUSE_MUTEXES</code> = 1</p> </li> <li><code>configUSE_RECURSIVE_MUTEXES</code> = 1</li> <li><code>configUSE_COUNTING_SEMAPHORES</code> = 1</li> <li><code>configQUEUE_REGISTRY_SIZE</code> = 10</li> <li><code>configNUM_THREAD_LOCAL_STORAGE_POINTERS</code> = 5</li> <li> <p><code>configCHECK_FOR_STACK_OVERFLOW</code> = 1</p> </li> <li> <p><code>configUSE_TIMERS</code> = 1</p> </li> <li><code>configTIMER_TASK_PRIORITY</code> = 3</li> <li><code>configTIMER_QUEUE_LENGTH</code> = 10</li> <li><code>configTIMER_TASK_STACK_DEPTH</code> = <code>configMINIMAL_STACK_SIZE</code></li> </ul> <p>All other config settings are unchanged by modm and are defaulted by FreeRTOS itself, please refer to the FreeRTOS Config documentation to understand what each of these do.</p> <p>To change a configuration setting, define a <code>&lt;FreeRTOSConfigLocal.h&gt;</code> file, which is included before the optional settings, so you can overwrite them easily.</p> <p>An example <code>&lt;FreeRTOSConfigLocal.h&gt;</code> file:</p> <pre><code>// Use a bigger minimal stack size\n#define configMINIMAL_STACK_SIZE  256\n// Longer timer queue\n#define configTIMER_QUEUE_LENGTH  20\n</code></pre> <p>This module is only available for rp, sam, stm32.</p>"},{"location":"reference/module/modm-freertos/#options","title":"Options","text":""},{"location":"reference/module/modm-freertos/#frequency","title":"frequency","text":"<p>Context switch frequency in Hz</p> <p>Default: <code>1000</code> Inputs: <code>[4 ... 1000]</code> </p>"},{"location":"reference/module/modm-freertos/#dependencies","title":"Dependencies","text":"<p> modm:freertos modm_freertos modm: freertos modm_architecture_assert modm: architecture: assert modm_freertos-&gt;modm_architecture_assert modm_cmsis_device modm: cmsis: device modm_freertos-&gt;modm_cmsis_device modm_platform_clock modm: platform: clock modm_freertos-&gt;modm_platform_clock </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-ide-vscode/","title":"Visual Studio Code (VSCode)","text":"<p>lbuild module: <code>modm:ide:vscode</code></p> <p>Visual Studio Code (VSCode) is a popular IDE with an integrated debugger UI.</p> <p>This module provides configuration files to integrate building, debugging, uploading and code completion into the IDE:</p> <ul> <li><code>.vscode/tasks.json</code>: If the <code>modm:build:scons</code> and <code>modm:build:make</code> module   are included, this file wraps the building and uploading commands by profile.   You can invoke them by Ctl+Shift+B (macOS: Cmd+Shift+B).</li> <li><code>.vscode/c_cpp_properties.json</code>: Configures IntelliSense for better code   completion and for using the correct system headers. You need the   C/C++ extension installed.</li> <li><code>.vscode/launch.json</code>: Configures the Cortex-Debug extension to start the   debugger with a single click from the IDE.</li> </ul> <p>Note that not all build system features are provided in the IDE, only the most common. You can call all build system tools from the command line. In addition, the <code>modm:build:cmake</code> module is supported natively by the CMake Tools extension and is therefore not wrapped.</p> <p>We recommend adding this module from the command line so that you don't accidentally overwrite your modified files later: <code>lbuild build -m ::vscode</code>.</p> <p>Note that some configuration options may be specific to your environment (such as the compiler path) and may not work in other environments.</p>"},{"location":"reference/module/modm-ide-vscode/#dependencies","title":"Dependencies","text":"<p> modm:ide:vscode modm_ide_vscode modm: ide: vscode modm_build modm: build modm_ide_vscode-&gt;modm_build </p>"},{"location":"reference/module/modm-ide/","title":"IDE Support","text":"<p>lbuild module: <code>modm:ide</code></p>"},{"location":"reference/module/modm-io/","title":"Input/Output Streams","text":"<p>lbuild module: <code>modm:io</code></p> <p>The <code>modm::IOStream</code> class contains efficient formatting that supports both C++ <code>std::basic_ostream</code>-like formatting via <code>operator &lt;&lt;</code> as well as implementing <code>printf</code> via the <code>modm:printf</code> module.</p> <pre><code>modm::IOStream stream(device);\nstream &lt;&lt; \"format number 8: \" &lt;&lt; uint8_t(8) &lt;&lt; \" or as signed -100: \" &lt;&lt; int8_t(-100);\nstream &lt;&lt; modm::endl;\n\nstream.printf(\"format number 8: %u or as signed -100: %d\", 8, -100);\n</code></pre> <p>AVR supported features</p> <p>All expensive features including <code>printf</code> are disabled by default to reduce firmware size! Please check the options.</p> <p><code>modm::endl</code> does NOT implicitly flush!</p> <p>Flushing is extremely expensive on embedded systems, therefore <code>modm::endl</code> does not implicitly flush the stream. Please call <code>modm::flush</code> explicitly.</p>"},{"location":"reference/module/modm-io/#redirecting-iostreams","title":"Redirecting IOStreams","text":"<p>The <code>modm::IODeviceWrapper</code> transforms any peripheral device that provides static <code>write()</code> and <code>read()</code> functions into an <code>IODevice</code>:</p> <pre><code>// configure a UART\nusing Uart = Uart0;\n\n// wrap it into an IODevice\nmodm::IODeviceWrapper&lt;Uart, modm::IOBuffer::BlockIfFull&gt; device;\n\n// use this device to print a message\ndevice.write(\"Hello\");\n\n// or create a IOStream and use the stream to print something\nmodm::IOStream stream(device);\nstream &lt;&lt; \" World!\";\n</code></pre>"},{"location":"reference/module/modm-io/#iodevice-buffer-behavior","title":"IODevice Buffer Behavior","text":"<p>The <code>modm::IODeviceWrapper</code> can be configured to discard or block in case the device is full. Discarding data is always non-blocking, however, blocking on write involves waiting in a loop until the device has space. This can cause a deadlock when called inside an interrupt!</p> <p>If compiled with the <code>modm:processing:fiber</code> module, the blocking behavior allows the fiber to yield while waiting for the device. To prevent interlaced output from different fibers, the <code>write(char)</code> function is protected by a mutex that releases when a newline character <code>\\n</code> is written. The <code>flush()</code> function is also mutex protected to allow one fiber to reliably flush the stream without having other fibers push data into the device.</p>"},{"location":"reference/module/modm-io/#options","title":"Options","text":""},{"location":"reference/module/modm-io/#with_float","title":"with_float","text":"<p>Support for floating point formatting</p> <p>On AVRs floating point values can be printed, however, the formatting cannot be specified and all values are printed as scientific-notation exponential floating point</p> <p>Default: <code>no</code> avr Default: <code>yes</code> hosted, rp, sam, stm32 Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-io/#with_long_long","title":"with_long_long","text":"<p>Support for 64-bit integer formatting</p> <p>Default: <code>no</code> avr Default: <code>yes</code> hosted, rp, sam, stm32 Inputs: <code>[yes, no]</code> Input Dependency: <code>yes -&gt; modm:printf</code> </p>"},{"location":"reference/module/modm-io/#with_printf","title":"with_printf","text":"<p>Support for printf-style formatting</p> <p>Default: <code>no</code> avr Default: <code>yes</code> hosted, rp, sam, stm32 Inputs: <code>[yes, no]</code> Input Dependency: <code>yes -&gt; modm:printf</code> </p>"},{"location":"reference/module/modm-io/#dependencies","title":"Dependencies","text":"<p> modm:io modm_io modm: io modm_architecture_accessor modm: architecture: accessor modm_io-&gt;modm_architecture_accessor modm_architecture_fiber modm: architecture: fiber modm_io-&gt;modm_architecture_fiber modm_math_utils modm: math: utils modm_io-&gt;modm_math_utils modm_printf modm: printf modm_io-&gt;modm_printf </p>"},{"location":"reference/module/modm-lvgl/","title":"LVGL graphics library","text":"<p>lbuild module: <code>modm:lvgl</code></p> <p>LVGL is a free and open-source graphics library providing everything you need to create embedded GUI with easy-to-use graphical elements, beautiful visual effects and low memory footprint.</p> <ul> <li>https://lvgl.io/</li> <li>https://github.com/lvgl/lvgl</li> </ul>"},{"location":"reference/module/modm-lvgl/#configuration","title":"Configuration","text":"<p>LVGL defines defaults for all it's configuration settings, which you can find in the configuration template.</p> <p>This module generates a <code>lv_conf.h</code> file to define the options necessary for integration with modm which are:</p> <ul> <li>Heap is provided by the <code>modm:platform:heap</code> module.</li> <li>Tick is implemented via the <code>modm:platform:clock</code> module.</li> <li><code>LV_LOG_PRINTF = 0</code>: logging is redirected to <code>MODM_LOG_*</code> if the                        <code>modm:debug</code> module is included and <code>LV_USE_LOG = 1</code>.</li> </ul> <p>To add your own configuration you can create a <code>&lt;lv_conf_local.h&gt;</code> file which will automatically be included at the beginning of our <code>lv_conf.h</code>.</p> <p>Example <code>&lt;lv_conf_local.h&gt;</code> configuration:</p> <pre><code>// Maximal resolutions\n#define LV_HOR_RES_MAX  240\n#define LV_VER_RES_MAX  320\n#define LV_DPI          200\n\n/* Color depth:\n * - 1:  1 byte per pixel\n * - 8:  RGB332\n * - 16: RGB565\n * - 32: ARGB8888\n */\n#define LV_COLOR_DEPTH  16\n\n// Enable logging at INFO level\n#define LV_USE_LOG    1\n#define LV_LOG_LEVEL  LV_LOG_LEVEL_INFO\n\n// Disable anti-aliasing\n#define LV_ANTIALIAS  0\n</code></pre>"},{"location":"reference/module/modm-lvgl/#initialization","title":"Initialization","text":"<p>modm will call <code>lv_init()</code> as a constructor with priority 1000 and then set the required callbacks for the modm port to work. Static constructors are called afterwards therefore can already use the LVGL functions.</p>"},{"location":"reference/module/modm-lvgl/#dependencies","title":"Dependencies","text":"<p> modm:lvgl modm_lvgl modm: lvgl modm_architecture_clock modm: architecture: clock modm_lvgl-&gt;modm_architecture_clock modm_platform_heap modm: platform: heap modm_lvgl-&gt;modm_platform_heap </p>"},{"location":"reference/module/modm-math-algorithm/","title":"Algorithms","text":"<p>lbuild module: <code>modm:math:algorithm</code></p> <p>A collection of useful and lightweight algorithms.</p>"},{"location":"reference/module/modm-math-algorithm/#convenience-iterators","title":"Convenience Iterators","text":"<p>Inspired by Python's built-in <code>range</code> and <code>enumerate</code> functions, you can use <code>modm::range</code> and <code>modm::enumerate</code> in for loops:</p> <pre><code>// Iterates over 0 .. 9\nfor (auto i : modm::range(10)) {\n    MODM_LOG_INFO &lt;&lt; i &lt;&lt; modm::endl;\n}\n// Iterates over 10 .. 19\nfor (auto i : modm::range(10, 20)) {\n    MODM_LOG_INFO &lt;&lt; i &lt;&lt; modm::endl;\n}\n// Iterates over 20, 22, 24, 26, 28\nfor (auto i : modm::range(20, 30, 2)) {\n    MODM_LOG_INFO &lt;&lt; i &lt;&lt; modm::endl;\n}\n\n// Iterates over 0 .. N-1, where N = size of iterable\nfor (auto [i, item] : modm::enumerate(iterable)) {\n    MODM_LOG_INFO &lt;&lt; i &lt;&lt; item &lt;&lt; modm::endl;\n}\n</code></pre>"},{"location":"reference/module/modm-math-algorithm/#prescaler-calculators","title":"Prescaler Calculators","text":"<p>Peripheral output frequencies are usually generated by dividing an input clock with a prescaler in hardware. Finding the closest prescaler value for a desired output frequency can be unintuitive, therefore, these classes provide a simple interface for a constexpr calculator.</p> <p>All calculators return a <code>Result</code> struct containing desired, input, and output frequencies, the relative error of the output vs desired frequency, and the prescaler and its index. The prescaler index is typically the value to write to the register directly:</p> <pre><code>// 16-bit linear prescaler [1, 2^16] mapped as [0, 0xffff].\nconstexpr auto result = Prescaler::from_linear(10_MHz, 1_kHz, 1, 1ul &lt;&lt; 16);\nstatic_assert(result.input_frequency == 10_MHz);\nstatic_assert(result.desired_frequency == 1_kHz);\n// Calculator finds an exact match without error\nstatic_assert(result.frequency == 1_kHz);\nstatic_assert(result.error == 0);\n// with prescaler 1e4 = 1e7 / 1e3.\nstatic_assert(result.prescaler == 10'000);\nstatic_assert(result.index == 9'999);\nPERIPHERAL-&gt;PRESCALER = result.index;\n</code></pre> <p>The index is particularly useful for non-contiguous prescalers, the most common being power-of-two values:</p> <pre><code>// Power-of-two prescaler with 8 values between [16, 4096].\nconstexpr auto result = Prescaler::from_power(32_kHz, 100_Hz, 1ul &lt;&lt; 4, 1ul &lt;&lt; 12);\n// Calculator cannot find an exact match! Closest has -25% error!\nstatic_assert(result.frequency == 125_Hz);\nstatic_assert(result.error == -0.25);\n// Ideal Prescaler is 320, clostest is 256\nstatic_assert(result.prescaler == 256);\n// Index is 256 = 1ul &lt;&lt; (4 + 4)\nstatic_assert(result.index == 4);\n</code></pre> <p>Non-contiguous prescalers can also be created with a modifier function:</p> <pre><code>// Only even prescalers from [2, 1024]\nconstexpr auto result = Prescaler::from_function(\n        110_MHz, 3.5_MHz, 1, 512, [](uint32_t i){ return i*2; });\n// Ideal prescaler is 31.4, closest is 32 with ~2% error.\nstatic_assert(result.frequency == 3.4375_MHz);\nstatic_assert(result.error == 0.02);\nstatic_assert(result.prescaler == 32);\nstatic_assert(result.index == 15); // 32/2 - 1\n</code></pre> <p>For all other cases, prescalers can be passed as an initializer list or as any forward range. Note that the prescaler values must be sorted, otherwise the calculator will compute the wrong prescaler values!</p> <pre><code>constexpr auto result = Prescaler::from_list(1_MHz, 1_kHz, {2,4,16,256,1024});\nconstexpr auto result = Prescaler::from_range(2_kHz, 1_kHz, std::array{1,2,3});\n</code></pre> <p>A special case is made of two chained prescalers that are both linear powers-of-two. These are often called \"fractional prescalers\" and act as a single binary-scaled linear prescaler and can thus be modeled as such:</p> <pre><code>// A fractional 12.4-bit prescaler can be modeled as a single 16-bit prescaler.\nconstexpr auto result = Prescaler::from_linear(SystemClock::Usart1, 115200, 16, 1ul &lt;&lt; 16);\n// The resulting prescaler can be written directly to the register.\nUSART1-&gt;BRR = result.prescaler;\n</code></pre>"},{"location":"reference/module/modm-math-algorithm/#prescalers-with-counters","title":"Prescalers with Counters","text":"<p>However, often chained prescalers cannot be converted to a linear prescaler, for example, a timer with a set of power-of-two prescalers and a 16 or 32-bit counter. These must be computed with a different class:</p> <pre><code>// A prescaler with power-of-two values [4, 256] going into a 12-bit down counter.\nconstexpr auto result = PrescalerCounter::from_power(32_kHz, 1_Hz, 1ul &lt;&lt; 12, 4, 256);\n// Calculator finds an exact match without error\nstatic_assert(result.frequency == 1_Hz);\nstatic_assert(result.error == 0);\n// with prescaler 8 and counter 4'000.\nstatic_assert(result.prescaler == 8);\nstatic_assert(result.counter == 4'000);\nstatic_assert(result.index == 1);\n</code></pre> <p>The calculator only picks the first prescaler with the lowest error, however, in this example, there can be multiple exact solutions:</p> <p>32000 = 8 \u00d7 4000 = 16 \u00d7 2000 = ... = 128 \u00d7 250 = 256 \u00d7 125</p> <p>If the prescaler and counter is used to generate a waveform like PWM, then it is beneficial to pick the combination with the largest counter value. However, if the use case is to preserve power, then a slow running counter requires the highest prescaler. Therefore the order of prescalers can be reversed:</p> <pre><code>constexpr auto result = PrescalerCounter::from_power(32_kHz, 1_Hz, 1ul &lt;&lt; 12, 256, 4);\nstatic_assert(result.prescaler == 256);\nstatic_assert(result.counter == 125);\n// Index is not the same!\nstatic_assert(result.index == 0);\n</code></pre> <p>The same applies to the <code>PrescalerCounter::from_linear()</code> and <code>PrescalerCounter::from_function()</code> calculators, while the order for lists and forward ranges can be entirely arbitrary:</p> <pre><code>constexpr auto result = PrescalerCounter::from_list(32_kHz, 1_Hz, 1ul &lt;&lt; 12, {128,16,256,4});\nstatic_assert(result.prescaler == 128);\nstatic_assert(result.counter == 250);\n// Index is relative to the list order now!\nstatic_assert(result.index == 0);\n</code></pre> <p>Time Durations</p> <p>While the calculator is designed for frequencies, time durations can also be computed by transforming the input as <code>frequency = 1.0 / duration</code> and then transforming the output back as <code>duration = 1.0 / frequency</code>.</p> <p>Floating-Point Frequencies</p> <p>You can define the type used for frequency representation by using the <code>GenericPrescaler&lt;double&gt;</code> and <code>GenericPrescalerCounter&lt;double&gt;</code> classes.</p>"},{"location":"reference/module/modm-math-algorithm/#tolerance-of-prescaler-error","title":"Tolerance of Prescaler Error","text":"<p>Each <code>Result</code> has a signed(!), relative error attached, which can be used to assert on the quality of the calculation. Note that using <code>static_assert</code> on the error directly will only print the error values:</p> <p><pre><code>static_assert(std::abs(result.error) &lt; 5_pct);\n</code></pre> <pre><code>error: static assertion failed\n | static_assert(std::abs(result.error) &lt; tolerance);\n |               ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\nnote: the comparison reduces to '(0.10 &lt; 0.05)'\n</code></pre></p> <p>However, by using a helper method, the requested and closest available frequencies can be displayed to the developer:</p> <p><pre><code>// Accidentally used kBaud instead of Baud, which cannot be generated\nconstexpr auto result = Prescaler::from_linear(SystemClock::Usart2, 115200_kBd, 16, 1ul &lt;&lt; 16);\nmodm::assertBaudrateInTolerance&lt;result.frequency, result.desired_frequency, tolerance&gt;();\n</code></pre> <pre><code>In instantiation of 'static void modm::PeripheralDriver::assertBaudrateInTolerance()\n[with long long unsigned int available = 3000000; long long unsigned int requested = 115200000; float tolerance = 0.01f]':\nerror: static assertion failed: The closest available baudrate exceeds the tolerance of the requested baudrate!\n | static_assert(modm::isValueInTolerance(requested, available, tolerance),\n |               ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnote: 'modm::isValueInTolerance&lt;long long unsigned int&gt;(115200000, 3000000, 0.01f)' evaluates to false\n</code></pre></p>"},{"location":"reference/module/modm-math-algorithm/#dependencies","title":"Dependencies","text":"<p> modm:math:algorithm modm_math_algorithm modm: math: algorithm modm_math_units modm: math: units modm_math_algorithm-&gt;modm_math_units </p>"},{"location":"reference/module/modm-math-calendar/","title":"Calendar Operations","text":"<p>lbuild module: <code>modm:math:calendar</code></p> <p>This module is only available for hosted, rp, sam, stm32.</p>"},{"location":"reference/module/modm-math-calendar/#dependencies","title":"Dependencies","text":"<p> modm:math:calendar modm_math_calendar modm: math: calendar modm_stdc++ modm: stdc++ modm_math_calendar-&gt;modm_stdc++ </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-math-filter/","title":"Filters","text":"<p>lbuild module: <code>modm:math:filter</code></p>"},{"location":"reference/module/modm-math-filter/#dependencies","title":"Dependencies","text":"<p> modm:math:filter modm_math_filter modm: math: filter modm_architecture modm: architecture modm_math_filter-&gt;modm_architecture modm_math_utils modm: math: utils modm_math_filter-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-math-geometry/","title":"Geometric Operations","text":"<p>lbuild module: <code>modm:math:geometry</code></p>"},{"location":"reference/module/modm-math-geometry/#dependencies","title":"Dependencies","text":"<p> modm:math:geometry modm_math_geometry modm: math: geometry modm_architecture modm: architecture modm_math_geometry-&gt;modm_architecture modm_container modm: container modm_math_geometry-&gt;modm_container modm_io modm: io modm_math_geometry-&gt;modm_io modm_math_matrix modm: math: matrix modm_math_geometry-&gt;modm_math_matrix modm_math_utils modm: math: utils modm_math_geometry-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-math-interpolation/","title":"Interpolation Methods","text":"<p>lbuild module: <code>modm:math:interpolation</code></p> <p>Simple interpolation methods between a list of points.</p>"},{"location":"reference/module/modm-math-interpolation/#linear-interpolation","title":"Linear Interpolation","text":"<p>Example:</p> <pre><code>// Definition of the supporting points. The first type is the\n// input type, the second the output type\nusing Point = modm::Pair&lt;int8_t, int16_t&gt;;\n\n// Create a array of supporting points describing the curve.\nconst Point supportingPoints[6] =\n{\n    { 30, -200 },\n    { 50, 0 },\n    { 90, 50 },\n    { 150, 2050 },\n    { 200, 3000 },\n    { 220, 20000 }\n};\n\nmodm::interpolation::Linear&lt;Point&gt; value(supportingPoints, 6);\n// ...\n\nint8_t  a = 40;\nint16_t b = value.interpolate(a);\n</code></pre> <p>Example with supporting points read from flash:</p> <pre><code>// Definition of a supporting point\nusing Point = modm::Pair&lt;int8_t, int16_t&gt;;\n\n// Array of supporting points in flash\nFLASH_STORAGE(Point supportingPoints[6]) =\n{\n    { 30, -200 },\n    { 50, 0 },\n    { 90, 50 },\n    { 150, 2050 },\n    { 200, 3000 },\n    { 220, 20000 }\n};\n\n// Create an interpolator object which reads the\n// supporting points from flash.\nmodm::interpolation::Linear&lt;Point, modm::accessor::Flash&gt;\n        value(modm::accessor::asFlash(supportingPoints), 6);\n// ...\n\nint8_t  a = 20;\nint16_t b = value.interpolate(a);\n</code></pre>"},{"location":"reference/module/modm-math-interpolation/#lagrange-interpolation","title":"Lagrange Interpolation","text":"<p>Example:</p> <pre><code>using Point = modm::Pair&lt;float, float&gt;;\n\n// interpolate x^2 over the range of 1 &lt;= x &lt;= 3\nPoint points[3] =\n{\n    { 1, 1 },\n    { 2, 4 },\n    { 3, 9 }\n};\n\nmodm::interpolation::Lagrange&lt;Point&gt; value(points, 3);\n// ...\n\nfloat output = value.interpolate(1.5f);\n// output =&gt; 2.25;\n</code></pre> <p>Warning</p> <p>Only floating points types are allowed as second type of <code>modm::Pair</code>, otherwise the calculation will deliver wrong results!</p> <p>See Wikipedia.</p>"},{"location":"reference/module/modm-math-interpolation/#dependencies","title":"Dependencies","text":"<p> modm:math:interpolation modm_math_interpolation modm: math: interpolation modm_architecture_accessor modm: architecture: accessor modm_math_interpolation-&gt;modm_architecture_accessor modm_container modm: container modm_math_interpolation-&gt;modm_container modm_math_utils modm: math: utils modm_math_interpolation-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-math-matrix/","title":"Matrix Math","text":"<p>lbuild module: <code>modm:math:matrix</code></p>"},{"location":"reference/module/modm-math-matrix/#dependencies","title":"Dependencies","text":"<p> modm:math:matrix modm_math_matrix modm: math: matrix modm_io modm: io modm_math_matrix-&gt;modm_io modm_math_geometry modm: math: geometry modm_math_matrix-&gt;modm_math_geometry modm_utils modm: utils modm_math_matrix-&gt;modm_utils </p>"},{"location":"reference/module/modm-math-saturation/","title":"Saturation Arithmetics","text":"<p>lbuild module: <code>modm:math:saturation</code></p>"},{"location":"reference/module/modm-math-saturation/#dependencies","title":"Dependencies","text":"<p> modm:math:saturation modm_math_saturation modm: math: saturation modm_math_utils modm: math: utils modm_math_saturation-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-math-units/","title":"SI Units","text":"<p>lbuild module: <code>modm:math:units</code></p> <p>modm uses a couple of common SI units for configuration of peripherals:</p> <ul> <li><code>frequency_t</code> in Hertz: <code>Hz</code>, <code>kHz</code> and <code>MHz</code>.</li> <li><code>baudrate_t</code> in Baud: <code>Bd</code>, <code>kBd</code>, <code>MBd</code>.</li> <li><code>bitrate_t</code> in bit/s, <code>bps</code>.</li> </ul> <p>These are integral units, so 1 Hz/Bd/bps cannot be split further, and are cast directly to <code>uint32_t</code> type, so they can be used as a non-type template argument.</p> <p>Conversion can be done via constexpr functions from any numerical type:</p> <ul> <li><code>modm::Hz(T value)</code>, <code>modm::kHz(T value)</code>, <code>modm::MHz(T value)</code>.</li> <li><code>modm::Bd(T value)</code>, <code>modm::kBd(T value)</code>, <code>modm::MBd(T value)</code>.</li> <li><code>modm::bps(T value)</code>, <code>modm::kbps(T value)</code>, <code>modm::Mbps(T value)</code>.</li> </ul> <p>In addition, user-defined literals are provided in the <code>modm::literals</code> namespace:</p> <pre><code>using namespace modm::literals;\n\nfrequency_t frequency = modm::Mhz(10.5);\n            frequency = 10.5_MHz;\nbaudrate_t baudrate = 115.2_kBd;\n           baudrate = modm::kBd(115.2);\nbitrate_t bitrate = modm::kbps(125);\n          bitrate = 125_kbps;\n\nfrequency = 4295_MHz; // OVERFLOW at 2^32 units!\n</code></pre>"},{"location":"reference/module/modm-math-units/#percentages","title":"Percentages","text":"<p>Percentages are stored as normalized floating point numbers and can be converted using these convenience constructors:</p> <pre><code>using namespace modm::literals;\n\npercent_t tolerance = modm::pct(10);\n          tolerance = 10_pct;\n          tolerance = 0.1f;\n</code></pre>"},{"location":"reference/module/modm-math-units/#time","title":"Time","text":"<p>Simplified types allow passing <code>std::chrono::duration</code> values as template parameters:</p> <pre><code>seconds_t duration = 10s;\nmilliseconds_t duration = 10ms;\nmicroseconds_t duration = 10us;\n\nauto count = duration.count();\n\ntemplate&lt; milliseconds_t period &gt;\nvoid setPeriod()\n{\n    auto seconds = 1000.0 / period.count();\n}\n</code></pre>"},{"location":"reference/module/modm-math-units/#dependencies","title":"Dependencies","text":"<p> modm:math:units modm_math_units modm: math: units modm_architecture modm: architecture modm_math_units-&gt;modm_architecture </p>"},{"location":"reference/module/modm-math-utils/","title":"Utilities","text":"<p>lbuild module: <code>modm:math:utils</code></p>"},{"location":"reference/module/modm-math-utils/#dependencies","title":"Dependencies","text":"<p> modm:math:utils modm_math_utils modm: math: utils modm_architecture modm: architecture modm_math_utils-&gt;modm_architecture </p>"},{"location":"reference/module/modm-math/","title":"Math","text":"<p>lbuild module: <code>modm:math</code></p>"},{"location":"reference/module/modm-math/#dependencies","title":"Dependencies","text":"<p> modm:math modm_math modm: math modm_math_units modm: math: units modm_math-&gt;modm_math_units </p>"},{"location":"reference/module/modm-nanopb/","title":"Nanopb - Protocol Buffers for Embedded Systems","text":"<p>lbuild module: <code>modm:nanopb</code></p> <p>Nanopb is a small code-size Protocol Buffers (protobuf) implementation in ansi C. It is especially suitable for use in microcontrollers, but fits any memory restricted system.</p> <p>See https://github.com/nanopb/nanopb.</p>"},{"location":"reference/module/modm-nanopb/#build-system-integration","title":"Build System Integration","text":"<p>You can optionally point the build system to multiple protofiles using a comma-separated list of paths in the <code>modm:nanopb:source</code> option. You can specify the output location using the <code>modm:nanopb:path</code> option. See the <code>modm:build</code> submodules for further details.</p> <p>Currently only with SCons support</p> <p>Only the <code>modm:build:scons</code> module currently supports this feature.</p>"},{"location":"reference/module/modm-nanopb/#options","title":"Options","text":""},{"location":"reference/module/modm-nanopb/#path","title":"path","text":"<p>Path to the generated messages folder</p> <p>Default: <code>generated/nanopb</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-nanopb/#sources","title":"sources","text":"<p>Comma-separated list of paths to protofiles.</p> <p>Default: <code>{}</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-nlohmann-json/","title":"Header-only JSON library","text":"<p>lbuild module: <code>modm:nlohmann-json</code></p> <p>The nlohmann JSON C++ library</p> <ul> <li>https://json.nlohmann.me/</li> <li>https://github.com/nlohmann/json</li> </ul>"},{"location":"reference/module/modm-nlohmann-json/#dependencies","title":"Dependencies","text":"<p> modm:nlohmann-json modm_nlohmann_json modm: nlohmann-json modm_platform_heap modm: platform: heap modm_nlohmann_json-&gt;modm_platform_heap </p>"},{"location":"reference/module/modm-platform-1-wire-bitbang/","title":"Software 1-Wire","text":"<p>lbuild module: <code>modm:platform:1-wire.bitbang</code></p>"},{"location":"reference/module/modm-platform-1-wire-bitbang/#dependencies","title":"Dependencies","text":"<p> modm:platform:1-wire.bitbang modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_architecture_1_wire modm: architecture: 1-wire modm_platform_1_wire_bitbang-&gt;modm_architecture_1_wire modm_architecture_delay modm: architecture: delay modm_platform_1_wire_bitbang-&gt;modm_architecture_delay modm_platform_gpio modm: platform: gpio modm_platform_1_wire_bitbang-&gt;modm_platform_gpio </p>"},{"location":"reference/module/modm-platform-adc-avr-mega-tiny/","title":"Analog-to-Digital Converter (ADC)","text":"<p>lbuild module: <code>modm:platform:adc</code></p> <p>This module is only available for avr{mega,tiny}.</p>"},{"location":"reference/module/modm-platform-adc-avr-mega-tiny/#dependencies","title":"Dependencies","text":"<p> modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc-&gt;modm_architecture_adc modm_architecture_interrupt modm: architecture: interrupt modm_platform_adc-&gt;modm_architecture_interrupt modm_math_algorithm modm: math: algorithm modm_platform_adc-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_adc-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-adc-rp2040/","title":"Analog-to-Digital Converter (ADC)","text":"<p>lbuild module: <code>modm:platform:adc</code></p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-platform-adc-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc-&gt;modm_architecture_adc modm_cmsis_device modm: cmsis: device modm_platform_adc-&gt;modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_adc-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-adc-sam-e7x-s7x-v7x-g5x/","title":"Analog-to-Digital Converter (ADC)","text":"<p>lbuild module: <code>modm:platform:adc</code></p> <p>This module is only available for sam{e7x/s7x/v7x,g5x}.</p>"},{"location":"reference/module/modm-platform-adc-sam-e7x-s7x-v7x-g5x/#dependencies","title":"Dependencies","text":"<p> modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc-&gt;modm_architecture_adc modm_architecture_register modm: architecture: register modm_platform_adc-&gt;modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_adc-&gt;modm_math_algorithm modm_platform_clockgen modm: platform: clockgen modm_platform_adc-&gt;modm_platform_clockgen modm_platform_gpio modm: platform: gpio modm_platform_adc-&gt;modm_platform_gpio modm_utils modm: utils modm_platform_adc-&gt;modm_utils </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-adc-stm32-c0-f0-g0/","title":"Analog-to-Digital Converter (ADC)","text":"<p>lbuild module: <code>modm:platform:adc</code></p> <p>This module is only available for stm32{c0,f0,g0}.</p>"},{"location":"reference/module/modm-platform-adc-stm32-c0-f0-g0/#dependencies","title":"Dependencies","text":"<p> modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc-&gt;modm_architecture_adc modm_architecture_delay modm: architecture: delay modm_platform_adc-&gt;modm_architecture_delay modm_architecture_register modm: architecture: register modm_platform_adc-&gt;modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_adc-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_adc-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-adc-stm32-f1-f2-f3-f4-f7-l1/","title":"Analog-to-Digital Converter (ADC)","text":"<p>lbuild module: <code>modm:platform:adc</code></p> <p>This module is only available for stm32{f1,f2,f3,f4,f7,l1}.</p>"},{"location":"reference/module/modm-platform-adc-stm32-f1-f2-f3-f4-f7-l1/#dependencies","title":"Dependencies","text":"<p> modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc-&gt;modm_architecture_adc modm_architecture_register modm: architecture: register modm_platform_adc-&gt;modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_adc-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_adc-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-adc-stm32-f3-g4-h7-l4-l5/","title":"Analog-to-Digital Converter (ADC)","text":"<p>lbuild module: <code>modm:platform:adc</code></p> <p>This module is only available for stm32{f3,g4,h7,l4,l5}.</p>"},{"location":"reference/module/modm-platform-adc-stm32-f3-g4-h7-l4-l5/#dependencies","title":"Dependencies","text":"<p> modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc-&gt;modm_architecture_adc modm_architecture_delay modm: architecture: delay modm_platform_adc-&gt;modm_architecture_delay modm_architecture_register modm: architecture: register modm_platform_adc-&gt;modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_adc-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_adc-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-bdma/","title":"Basic Direct Memory Access Controller (BDMA)","text":"<p>lbuild module: <code>modm:platform:bdma</code></p> <p>This module is only available for stm32h7.</p>"},{"location":"reference/module/modm-platform-bdma/#dependencies","title":"Dependencies","text":"<p> modm:platform:bdma modm_platform_bdma modm: platform: bdma modm_cmsis_device modm: cmsis: device modm_platform_bdma-&gt;modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_bdma-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-can-common-fdcan/","title":"FDCAN common","text":"<p>lbuild module: <code>modm:platform:can.common.fdcan</code></p> <p>This module is only available for same7x/s7x/v7x, stm32{c0,g0,g4,h7,l5,u5}.</p>"},{"location":"reference/module/modm-platform-can-common-fdcan/#dependencies","title":"Dependencies","text":"<p> modm:platform:can.common.fdcan modm_platform_can_common_fdcan modm: platform: can.common.fdcan modm_architecture_assert modm: architecture: assert modm_platform_can_common_fdcan-&gt;modm_architecture_assert modm_architecture_can modm: architecture: can modm_platform_can_common_fdcan-&gt;modm_architecture_can modm_architecture_clock modm: architecture: clock modm_platform_can_common_fdcan-&gt;modm_architecture_clock </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-can-common/","title":"CAN Common","text":"<p>lbuild module: <code>modm:platform:can.common</code></p>"},{"location":"reference/module/modm-platform-can-common/#dependencies","title":"Dependencies","text":"<p> modm:platform:can.common modm_platform_can_common modm: platform: can.common modm_architecture_clock modm: architecture: clock modm_platform_can_common-&gt;modm_architecture_clock </p>"},{"location":"reference/module/modm-platform-can-same7x-s7x-v7x/","title":"Controller Area Network with Flexible Data-Rate (MCAN)","text":"<p>lbuild module: <code>modm:platform:can</code></p> <p>This module is only available for same7x/s7x/v7x.</p>"},{"location":"reference/module/modm-platform-can-same7x-s7x-v7x/#dependencies","title":"Dependencies","text":"<p> modm:platform:can modm_platform_can modm: platform: can modm_architecture_assert modm: architecture: assert modm_platform_can-&gt;modm_architecture_assert modm_architecture_can modm: architecture: can modm_platform_can-&gt;modm_architecture_can modm_architecture_clock modm: architecture: clock modm_platform_can-&gt;modm_architecture_clock modm_cmsis_device modm: cmsis: device modm_platform_can-&gt;modm_cmsis_device modm_platform_can_common modm: platform: can.common modm_platform_can-&gt;modm_platform_can_common modm_platform_can_common_fdcan modm: platform: can.common.fdcan modm_platform_can-&gt;modm_platform_can_common_fdcan modm_platform_gpio modm: platform: gpio modm_platform_can-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-can-stm32-c0-g0-g4-h7-l5-u5/","title":"Controller Area Network with Flexible Data-Rate (FDCAN)","text":"<p>lbuild module: <code>modm:platform:can</code></p> <p>This module is only available for stm32{c0,g0,g4,h7,l5,u5}.</p>"},{"location":"reference/module/modm-platform-can-stm32-c0-g0-g4-h7-l5-u5/#dependencies","title":"Dependencies","text":"<p> modm:platform:can modm_platform_can modm: platform: can modm_architecture_assert modm: architecture: assert modm_platform_can-&gt;modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_platform_can-&gt;modm_architecture_atomic modm_architecture_can modm: architecture: can modm_platform_can-&gt;modm_architecture_can modm_architecture_clock modm: architecture: clock modm_platform_can-&gt;modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_platform_can-&gt;modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_can-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_can-&gt;modm_cmsis_device modm_debug modm: debug modm_platform_can-&gt;modm_debug modm_platform_can_common modm: platform: can.common modm_platform_can-&gt;modm_platform_can_common modm_platform_can_common_fdcan modm: platform: can.common.fdcan modm_platform_can-&gt;modm_platform_can_common_fdcan modm_platform_gpio modm: platform: gpio modm_platform_can-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_can-&gt;modm_platform_rcc modm_utils modm: utils modm_platform_can-&gt;modm_utils </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/","title":"Controller Area Network (CAN)","text":"<p>lbuild module: <code>modm:platform:can</code></p> <p>This module is only available for stm32{f0,f1,f2,f3,f4,f7,l4}.</p>"},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/#bufferrx","title":"buffer.rx","text":"<p>This option is only available for stm32{f0,f1,f3}.</p> <p>Default: <code>32</code> Inputs: <code>[1 .. 32 .. 64Ki-2]</code> </p>"},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/#buffertx","title":"buffer.tx","text":"<p>This option is only available for stm32{f0,f1,f3}.</p> <p>Default: <code>32</code> Inputs: <code>[1 .. 32 .. 64Ki-2]</code> </p>"},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/#dependencies","title":"Dependencies","text":"<p> modm:platform:can modm_platform_can modm: platform: can modm_architecture_assert modm: architecture: assert modm_platform_can-&gt;modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_platform_can-&gt;modm_architecture_atomic modm_architecture_can modm: architecture: can modm_platform_can-&gt;modm_architecture_can modm_architecture_clock modm: architecture: clock modm_platform_can-&gt;modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_platform_can-&gt;modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_can-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_can-&gt;modm_cmsis_device modm_debug modm: debug modm_platform_can-&gt;modm_debug modm_platform_can_common modm: platform: can.common modm_platform_can-&gt;modm_platform_can_common modm_platform_gpio modm: platform: gpio modm_platform_can-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_can-&gt;modm_platform_rcc modm_utils modm: utils modm_platform_can-&gt;modm_utils </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-canusb/","title":"CANUSB Driver","text":"<p>lbuild module: <code>modm:platform:canusb</code></p> <p>This module is only available for hosted{darwin,linux}.</p>"},{"location":"reference/module/modm-platform-canusb/#dependencies","title":"Dependencies","text":"<p> modm:platform:canusb modm_platform_canusb modm: platform: canusb modm_architecture_can modm: architecture: can modm_platform_canusb-&gt;modm_architecture_can modm_debug modm: debug modm_platform_canusb-&gt;modm_debug modm_driver_lawicel modm: driver: lawicel modm_platform_canusb-&gt;modm_driver_lawicel modm_processing_timer modm: processing: timer modm_platform_canusb-&gt;modm_processing_timer </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-clock-avr/","title":"System Clock via Timer/Counter 0","text":"<p>lbuild module: <code>modm:platform:clock</code></p> <p>The TC0 timer is used to provide a time point at milli- and microsecond resolution to implement the <code>modm::Clock::now()</code> and <code>modm::PreciseClock::now()</code> interfaces defined in the <code>modm:architecture:clock</code> module.</p> <p>For this, the timer is configured to trigger a 1ms interrupt to increment the millisecond counter. To compute the microsecond counter, the 8-bit timer counter is used to interpolate between milliseconds via a 16x16=16-bit multiplication and shift to avoid a division. This is very fast, however, the resolution of the <code>modm::PreciseClock</code> is limited to at best ~4us (1000us/8-bit) and at worst ~32us ((2MHz/64)/1000us).</p> <p>This module is only available for avr.</p>"},{"location":"reference/module/modm-platform-clock-avr/#dependencies","title":"Dependencies","text":"<p> modm:platform:clock modm_platform_clock modm: platform: clock modm_architecture_atomic modm: architecture: atomic modm_platform_clock-&gt;modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_clock-&gt;modm_architecture_clock </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-clock-rp--sam--stm32/","title":"System Clock via Cortex-M SysTick","text":"<p>lbuild module: <code>modm:platform:clock</code></p> <p>The SysTick timer is used to provide a time point at milli- and microsecond resolution to implement the <code>modm::Clock::now()</code> and <code>modm::PreciseClock::now()</code> interfaces defined in the <code>modm:architecture:clock</code> module.</p> <p>For this, the timer is configured to run at \u215bth HCLK frequency and the 24-bit counter is loaded for an interrupt every 250ms (on ARMv7-M) or every 1ms (ARMv6-M). The interrupt increments the 32-bit counters by 250ms and 250'000us (or 1ms and 1000us) respectively.</p> <p>Since this comes nowhere near the 1us resolution we want, the <code>SysTick-&gt;VAL</code> counter is used to interpolate the time between interrupts with this algorithm:</p> <pre><code>uint32_t milli_time{0};\nuint32_t micro_time{0};\nvoid SysTick_Handler()\n{\n    milli_time += 250;\n    micro_time += 250'000;\n}\n\nmodm::{Precise}Clock::now()\n{\n    float cycles_per_ms = (SystemClock::Frequency / 8) / 1e3;\n    float cycles_per_us = (SystemClock::Frequency / 8) / 1e6;\n    uint32_t val = SysTick-&gt;LOAD - SysTick-&gt;VAL; // SysTick-&gt;VAL counts down\n    milliseconds = milli_time + val / cycles_per_ms;\n    microseconds = micro_time + val / cycles_per_us;\n}\n</code></pre> <p>The actual algorithm avoids the floating point division and is instead approximated with a 32x32=64-bit multiplication and a bit shift without loosing accuracy. This computation is very, very fast on ARMv7-M.</p> <p>However, since ARMv6-M only has a 32x32=32-bit multiplication, the interrupt runs at 1ms, thus eliminating the multiplication for the millisecond clock, and allowing to fit into a 32-bit multiplication for the microsecond clock.</p> <p>This module is only available for rp, sam, stm32.</p>"},{"location":"reference/module/modm-platform-clock-rp--sam--stm32/#queries","title":"Queries","text":""},{"location":"reference/module/modm-platform-clock-rp--sam--stm32/#reference_clock","title":"reference_clock","text":"<p>The SysTick can be clocked from two sources controlled by the CLKSOURCE bit: 1=processor clock, or 0=reference clock. Since the reference clock is implementation defined, this query returns the prescaler of the reference clock or 1 if it does not exist.</p> <p>:returns: Divider of the processor clock.</p>"},{"location":"reference/module/modm-platform-clock-rp--sam--stm32/#dependencies","title":"Dependencies","text":"<p> modm:platform:clock modm_platform_clock modm: platform: clock modm_architecture_atomic modm: architecture: atomic modm_platform_clock-&gt;modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_clock-&gt;modm_architecture_clock modm_cmsis_device modm: cmsis: device modm_platform_clock-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_clock-&gt;modm_math_algorithm </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-clockgen-rp2040/","title":"Clock Generator and Source","text":"<p>lbuild module: <code>modm:platform:clockgen</code></p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-platform-clockgen-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:platform:clockgen modm_platform_clockgen modm: platform: clockgen modm_cmsis_device modm: cmsis: device modm_platform_clockgen-&gt;modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_clockgen-&gt;modm_platform_clock modm_utils modm: utils modm_platform_clockgen-&gt;modm_utils </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-clockgen-sam-e7x-s7x-v7x-g5x/","title":"Clock Generator (CKGR)","text":"<p>lbuild module: <code>modm:platform:clockgen</code></p> <p>This module is only available for sam{e7x/s7x/v7x,g5x}.</p>"},{"location":"reference/module/modm-platform-clockgen-sam-e7x-s7x-v7x-g5x/#dependencies","title":"Dependencies","text":"<p> modm:platform:clockgen modm_platform_clockgen modm: platform: clockgen modm_cmsis_device modm: cmsis: device modm_platform_clockgen-&gt;modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_clockgen-&gt;modm_platform_clock </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-comp/","title":"Comparator (COMP)","text":"<p>lbuild module: <code>modm:platform:comp</code></p> <p>This module is only available for stm32{f3,g0,g4,l4}.</p>"},{"location":"reference/module/modm-platform-comp/#dependencies","title":"Dependencies","text":"<p> modm:platform:comp modm_platform_comp modm: platform: comp modm_cmsis_device modm: cmsis: device modm_platform_comp-&gt;modm_cmsis_device </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-core-avr/","title":"AVR Core","text":"<p>lbuild module: <code>modm:platform:core</code></p> <p>Implements the interfaces defined in the <code>modm:architecture</code> modules. Adds the <code>-mmcu={target}</code> compile flag and the <code>F_CPU={core frequency}</code> define.</p>"},{"location":"reference/module/modm-platform-core-avr/#fuses","title":"Fuses","text":"<p>You can define the fuse values in your source code via the <code>FUSES</code> struct ELF section mechanism, they are automatically used by avrdude. For fuse values see the AVR Fuse Calculator.</p> <pre><code>#include &lt;avr/io.h&gt;\nFUSES =\n{\n    LFUSE_DEFAULT, // .low\n    HFUSE_DEFAULT, // .high\n    EFUSE_DEFAULT, // .extended\n};\n</code></pre>"},{"location":"reference/module/modm-platform-core-avr/#blocking-delay","title":"Blocking Delay","text":"<p>The delay functions as defined by <code>modm:architecture:delay</code> and called with a constant value are implemented directly via GCC's <code>__builtin_avr_delay_cycles(ns / (1e9 / F_CPU))</code>. Constant delays are therefore fairly accurate.</p> <p>For delays with a dynamic time, the following limitations apply for nanoseconds:</p> <ul> <li>The input is limited to 26-bit nanoseconds, so ~67 milliseconds.</li> <li>The minimum delay is between 8-16 cycles, so even at the fastest clock rate of   32MHz a delay below ~500ns is not possible. At 8MHz delays less than 2us are   not possible.</li> <li>For longer delays, the 4-cycle <code>_delay_loop_2(loops)</code> is used and the number   of loops should be calculated by dividing the input value by <code>ns_per_loop =   4e9/F_CPU</code>. However, division is prohibitively slow and thus very coarsly   approximated by shifting the input: <code>ns &gt;&gt; ceil(log_2(ns_per_loop))</code>. This is   only accurate for <code>4e9/2^8</code> = 15.6MHz, 7.8MHz, 3.9MHz, etc. For all other   clock speeds the error is bound by a factor of 2, so the delay is at most   twice as long as expected.</li> </ul> <p>For micro- and milliseconds delays with dynamic time:</p> <ul> <li>Microseconds delay is implemented fairly accurately in 1us steps.</li> <li>Millisecond delay is implemented fairly accurately in 1ms steps on 32-bits of   input time.</li> </ul> <p>This module is only available for avr.</p>"},{"location":"reference/module/modm-platform-core-avr/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-core-avr/#f_cpu","title":"f_cpu","text":"<p>CPU clock frequency</p> <p>Default: <code>None</code> Inputs: <code>[1 ... 32M]</code> </p>"},{"location":"reference/module/modm-platform-core-avr/#dependencies","title":"Dependencies","text":"<p> modm:platform:core modm_platform_core modm: platform: core modm_architecture_interrupt modm: architecture: interrupt modm_platform_core-&gt;modm_architecture_interrupt modm_stdc++ modm: stdc++ modm_platform_core-&gt;modm_stdc++ </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-core-hosted/","title":"Hosted Core","text":"<p>lbuild module: <code>modm:platform:core</code></p> <p>This module is only available for hosted.</p>"},{"location":"reference/module/modm-platform-core-hosted/#dependencies","title":"Dependencies","text":"<p> modm:platform:core modm_platform_core modm: platform: core modm_architecture_memory modm: architecture: memory modm_platform_core-&gt;modm_architecture_memory modm_debug modm: debug modm_platform_core-&gt;modm_debug </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-core-rp2040/","title":"RP2040 core module","text":"<p>lbuild module: <code>modm:platform:core</code></p> <p>This module specializes the generic <code>modm:platform:cortex-m</code> module with RP2040-specific startup code and linkerscripts.</p> <p>Second-stage Bootloader</p> <p>The external Flash memory requires additional setup, which is provided by the second-stage bootloader called boot2. You can select a pre-defined configuration via the <code>modm:platform:core:boot2</code> option.</p>"},{"location":"reference/module/modm-platform-core-rp2040/#startup","title":"Startup","text":"<p>The <code>__modm_initialize_platform()</code> callback resets all hardware to a known initial state.</p>"},{"location":"reference/module/modm-platform-core-rp2040/#linkerscript","title":"Linkerscript","text":"<p>The RP2040 currently only has one linkerscript template for internal SRAM and external Flash. You can place static objects in sections via the <code>modm_section</code> attribute:</p> <pre><code>// .data sections get copied from flash to RAM during startup\nmodm_section(\".data_core0\")\nuint64_t data = 0x1234567812345678ull;\n\n// .bss sections are not stored in flash but get zeroed during startup\nmodm_section(\".bss_core0\")\nuint8_t buffer[1024];\n\n// .noinit sections are left uninitialized\nmodm_section(\".noinit\")\nuint8_t display_buffer[480][320];\n</code></pre>"},{"location":"reference/module/modm-platform-core-rp2040/#dual-core-static-ram-sram","title":"Dual-Core Static RAM (SRAM)","text":"<p>The RP2040 memory map consists out of the main RAM (SRAM0-3 with striped bank access) and the dedicated memories for each core (SRAM4-5). Note that the stack size for both cores is the same and can be changed with the <code>modm:platform:cortex-m:main_stack_size</code> option, however, the main stack for CPU1 is only added if modm is build with the <code>modm:platform:multicore</code> module to free up the unused memory.</p> <pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __core0_end\n            \u2502  .noinit_core0         \u2502\n            \u2502  .bss_core0            \u2502\n            \u2502  .data_core0           \u2502\n   CORE0    \u2502  +MAIN_STACK_SIZE      \u2502\u25c4 __main_stack_top\n0x2004 1000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __core1_end, __core0_start\n            \u2502  .noinit_core1         \u2502\n            \u2502  .bss_core1            \u2502\n            \u2502  .data_core1           \u2502\n   CORE1    \u2502 (+MAIN_STACK_SIZE)     \u2502\u25c4 __main1_stack_top (only with :platform:multicore)\n0x2004 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __ram_end, __core1_start\n            \u2502  +HEAP_RAM             \u2502\n            \u2502  .noinit_ram           \u2502\n            \u2502  .noinit               \u2502\n            \u2502  .faststack            \u2502\n            \u2502  .bss_ram              \u2502\n            \u2502  .bss                  \u2502\n            \u2502  .data_ram             \u2502\n            \u2502  .data                 \u2502\n            \u2502  .fastdata             \u2502\n            \u2502  .fastcode             \u2502\n    RAM     \u2502 (.vector_ram)          \u2502\u25c4 only if remapped into RAM\n0x2000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __ram_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __flash_end\n            \u2502        (unused)        \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __rom_end\n            \u2502  .table.heap           \u2502\n            \u2502  .table.copy.extern    \u2502\n   tables   \u2502  .table.zero.extern    \u2502\n            \u2502  .table.copy.intern    \u2502\n            \u2502  .table.zero.intern    \u2502\n            \u2502                        \u2502\n            \u2502  .data_core1           \u2502\n            \u2502  .data_core0           \u2502\n    copy    \u2502  .data_ram             \u2502\n    only    \u2502  .data                 \u2502\n            \u2502  .fastcode             \u2502\n            \u2502  .fastdata             \u2502\n            \u2502                        \u2502\n            \u2502  .note.gnu.build-id    \u2502\n            \u2502  .assertion            \u2502\n            \u2502  .hardware_init        \u2502\n            \u2502 (.eh_frame)            \u2502\n    read    \u2502 (.ARM.exidx)           \u2502  only with C++ exceptions enabled\n    only    \u2502 (.ARM.extab)           \u2502\n            \u2502  .init_array           \u2502\n            \u2502  .init                 \u2502\n            \u2502  .rodata               \u2502\n            \u2502  .text                 \u2502\n            \u2502  .vector_rom           \u2502\n   FLASH    \u2502  .boot2                \u2502\u25c4 see :platform:core:boot2 option\n0x1000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __rom_start, __flash_start\n</code></pre> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-platform-core-rp2040/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-core-rp2040/#boot2","title":"boot2","text":"<p>Second-stage bootloader variant</p> <p>Default: <code>generic_03h</code> Inputs: <code>[at25sf128a, generic_03h, is25lp080, w25q080, w25x10cl]</code> </p>"},{"location":"reference/module/modm-platform-core-rp2040/#boot2_size","title":"boot2_size","text":"<p>Specify the size of external QSPI FLASH chip</p> <p>Default: <code>2Mi (2097152)</code> Inputs: <code>[0 .. 2Mi .. 16Mi]</code> </p>"},{"location":"reference/module/modm-platform-core-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:platform:core modm_platform_core modm: platform: core modm_platform_cortex_m modm: platform: cortex-m modm_platform_core-&gt;modm_platform_cortex_m </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-core-sam/","title":"SAM core module","text":"<p>lbuild module: <code>modm:platform:core</code></p> <p>This module specializes the generic <code>modm:platform:cortex-m</code> module with SAM-specific startup code and linkerscripts.</p>"},{"location":"reference/module/modm-platform-core-sam/#startup","title":"Startup","text":"<p>The <code>__modm_initialize_platform()</code> callback is implemented here to change the default QOS values to have the best performance and correct USB behaviour.</p>"},{"location":"reference/module/modm-platform-core-sam/#linkerscript","title":"Linkerscript","text":"<p>Currently only one basic linkerscript is supported.</p> <pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __ram_end\n            \u2502  +HEAP_RAM             \u2502\n            \u2502  .noinit_ram           \u2502\n            \u2502  .noinit               \u2502\n            \u2502  .faststack            \u2502\n            \u2502  .bss_ram              \u2502\n            \u2502  .bss                  \u2502\n            \u2502  .data_ram             \u2502\n            \u2502  .data                 \u2502\n            \u2502  .fastdata             \u2502\n            \u2502  .fastcode             \u2502\n    RAM     \u2502  +MAIN_STACK_SIZE      \u2502\u25c4 __main_stack_top\n0x2000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __ram_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __flash_end\n            \u2502        (unused)        \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __rom_end\n            \u2502  .table.heap           \u2502\n            \u2502  .table.copy.extern    \u2502\n   tables   \u2502  .table.zero.extern    \u2502\n            \u2502  .table.copy.intern    \u2502\n            \u2502  .table.zero.intern    \u2502\n            \u2502                        \u2502\n            \u2502  .data_ram             \u2502\n    copy    \u2502  .data                 \u2502\n    only    \u2502  .fastcode             \u2502\n            \u2502  .fastdata             \u2502\n            \u2502                        \u2502\n            \u2502  .note.gnu.build-id    \u2502\n            \u2502  .assertion            \u2502\n            \u2502  .hardware_init        \u2502\n            \u2502 (.eh_frame)            \u2502\n    read    \u2502 (.ARM.exidx)           \u2502  only with C++ exceptions enabled\n    only    \u2502 (.ARM.extab)           \u2502\n            \u2502  .init_array           \u2502\n            \u2502  .init                 \u2502\n            \u2502  .rodata               \u2502\n            \u2502  .text                 \u2502\n   FLASH    \u2502  .vector_rom           \u2502\n0x0800 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __rom_start, __flash_start\n</code></pre> <p>This module is only available for sam.</p>"},{"location":"reference/module/modm-platform-core-sam/#dependencies","title":"Dependencies","text":"<p> modm:platform:core modm_platform_core modm: platform: core modm_platform_cortex_m modm: platform: cortex-m modm_platform_core-&gt;modm_platform_cortex_m </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-core-stm32/","title":"STM32 core module","text":"<p>lbuild module: <code>modm:platform:core</code></p> <p>This module specializes the generic <code>modm:platform:cortex-m</code> module with STM32-specific startup code and linkerscripts.</p>"},{"location":"reference/module/modm-platform-core-stm32/#startup","title":"Startup","text":"<p>The <code>__modm_initialize_platform()</code> callback enables the clock to <code>SYSCFG</code> or <code>AFIO</code> and the clock to all internal SRAMs.</p>"},{"location":"reference/module/modm-platform-core-stm32/#linkerscript","title":"Linkerscript","text":"<p>For each target a specific linkerscript is generated out of a template, which move some sections into special RAMs depending on their purpose. You can place static objects in sections via the <code>modm_section</code> attribute:</p> <pre><code>// .data sections get copied from flash to RAM during startup\nmodm_section(\".data_sram1\")\nuint64_t data = 0x1234567812345678ull;\n\n// .bss sections are not stored in flash but get zeroed during startup\nmodm_section(\".bss_sram2\")\nuint8_t buffer[1024];\n\n// .noinit sections are left uninitialized\nmodm_section(\".noinit_sram3\")\nuint8_t display_buffer[480][320];\n</code></pre> <p>Note that the absolute addresses shown here are only for reference and usually differ on a specific device.</p>"},{"location":"reference/module/modm-platform-core-stm32/#static-ram-sram","title":"Static RAM (SRAM)","text":"<p>The most common memory map consists out of the internal Flash and one or more continuous SRAMs, which are grouped together in one large a <code>CONT_SRAM1</code> memory. This allows SRAM1 to overflow into SRAM2 and SRAM3 by pushing all sections in front of it further up and collapsing the heap sections. In that case there is no guarantee that the SRAM specific sections (<code>.data_sramN</code> etc) will remain within their original SRAM section, but you can place large objects into higher SRAMs explicitly to free up the space in the lower sections.</p> <pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __sram3_end\n            \u2502 (+HEAP_SRAM3)          \u2502\n            \u2502 (.noinit_sram3)        \u2502\n            \u2502 (.bss_sram3)           \u2502  only if SRAM3 exists\n   SRAM3    \u2502 (.data_sram3)          \u2502\n0x2003 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __sram2_end, __sram3_start\n            \u2502 (+HEAP_SRAM2)          \u2502\n            \u2502 (.noinit_sram2)        \u2502\n            \u2502 (.bss_sram2)           \u2502  only if SRAM2 exists\n   SRAM2    \u2502 (.data_sram2)          \u2502\n0x2002 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __sram1_end, __sram2_start\n            \u2502  +HEAP_SRAM1           \u2502\n            \u2502  .noinit_sram1         \u2502\n            \u2502  .noinit               \u2502\n            \u2502  .faststack            \u2502\n            \u2502  .bss_sram1            \u2502\n            \u2502  .bss                  \u2502\n            \u2502  .data_sram1           \u2502\n            \u2502  .data                 \u2502\n            \u2502  .fastdata             \u2502\n            \u2502  .fastcode             \u2502\n            \u2502 (.vector_ram)          \u2502\u25c4 only if remapped into RAM\n   SRAM1    \u2502  +MAIN_STACK_SIZE      \u2502\u25c4 __main_stack_top\n0x2000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __sram1_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __flash_end\n            \u2502        (unused)        \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __rom_end\n            \u2502  .table.heap           \u2502\n            \u2502  .table.copy.extern    \u2502\n   tables   \u2502  .table.zero.extern    \u2502\n            \u2502  .table.copy.intern    \u2502\n            \u2502  .table.zero.intern    \u2502\n            \u2502                        \u2502\n            \u2502 (.data_sram3)          \u2502\u25c4 only if SRAM3 exists\n            \u2502 (.data_sram2)          \u2502\u25c4 only if SRAM2 exists\n    copy    \u2502  .data_sram1           \u2502\n    only    \u2502  .data                 \u2502\n            \u2502  .fastcode             \u2502\n            \u2502  .fastdata             \u2502\n            \u2502                        \u2502\n            \u2502  .note.gnu.build-id    \u2502\n            \u2502  .assertion            \u2502\n            \u2502  .hardware_init        \u2502\n            \u2502 (.eh_frame)            \u2502\n    read    \u2502 (.ARM.exidx)           \u2502  only with C++ exceptions enabled\n    only    \u2502 (.ARM.extab)           \u2502\n            \u2502  .init_array           \u2502\n            \u2502  .init                 \u2502\n            \u2502  .rodata               \u2502\n            \u2502  .text                 \u2502\n   FLASH    \u2502  .vector_rom           \u2502\n0x0800 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __rom_start, __flash_start\n</code></pre>"},{"location":"reference/module/modm-platform-core-stm32/#data-core-coupled-ram-dccm","title":"Data Core-Coupled RAM (DCCM)","text":"<p>Some STM32F4 have a battery-backed backup SRAM and a single-cycle CCM that is only accessible to the core via the D-Code bus, thus the CCM is not DMA-able. Therefore the main stack is placed into SRAM, even though it is slower than CCM.</p> <pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __backup_end\n            \u2502  +HEAP_BACKUP          \u2502\n            \u2502  .noinit_backup        \u2502\n            \u2502  .bss_backup           \u2502\n   BACKUP   \u2502  .data_backup          \u2502\n0x4002 4000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __backup_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __sram3_end\n            \u2502 (+HEAP_SRAM3)          \u2502\n            \u2502 (.noinit_sram3)        \u2502\n            \u2502 (.bss_sram3)           \u2502  only if SRAM3 exists\n   SRAM3    \u2502 (.data_sram3)          \u2502\n0x2003 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __sram2_end, __sram3_start\n            \u2502 (+HEAP_SRAM2)          \u2502\n            \u2502 (.noinit_sram2)        \u2502\n            \u2502 (.bss_sram2)           \u2502  only if SRAM2 exists\n   SRAM2    \u2502 (.data_sram2)          \u2502\n0x2002 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __sram1_end, __sram2_start\n            \u2502  +HEAP_SRAM1           \u2502\n            \u2502  .noinit_sram1         \u2502\n            \u2502  .noinit               \u2502\n            \u2502  .faststack            \u2502\n            \u2502  .bss_sram1            \u2502\n            \u2502  .bss                  \u2502\n            \u2502  .data_sram1           \u2502\n            \u2502  .data                 \u2502\n            \u2502  .fastcode             \u2502\n            \u2502 (.vector_ram)          \u2502\u25c4 only if remapped into RAM\n   SRAM1    \u2502  +MAIN_STACK_SIZE      \u2502\u25c4 __main_stack_top\n0x2000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __sram1_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __ccm_end\n   D-Code   \u2502  +HEAP_CCM             \u2502\n    only    \u2502  .noinit_ccm           \u2502\n   access   \u2502  .bss_ccm              \u2502\n            \u2502  .data_ccm             \u2502\n    CCM     \u2502  .fastdata             \u2502\n0x1000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __ccm_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __flash_end\n            \u2502        (unused)        \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __rom_end\n            \u2502  .table.heap           \u2502\n            \u2502  .table.copy.extern    \u2502\n   tables   \u2502  .table.zero.extern    \u2502\n            \u2502  .table.copy.intern    \u2502\n            \u2502  .table.zero.intern    \u2502\n            \u2502                        \u2502\n            \u2502 (.data_sram3)          \u2502\u25c4 only if SRAM3 exists\n            \u2502 (.data_sram2)          \u2502\u25c4 only if SRAM2 exists\n            \u2502  .data_sram1           \u2502\n    copy    \u2502  .data_ccm             \u2502\n    only    \u2502  .data_backup          \u2502\n            \u2502  .data                 \u2502\n            \u2502  .fastdata             \u2502\n            \u2502  .fastcode             \u2502\n            \u2502                        \u2502\n            \u2502  .note.gnu.build-id    \u2502\n            \u2502  .assertion            \u2502\n            \u2502  .hardware_init        \u2502\n            \u2502 (.eh_frame)            \u2502\n    read    \u2502 (.ARM.exidx)           \u2502  only with C++ exceptions enabled\n    only    \u2502 (.ARM.extab)           \u2502\n            \u2502  .init_array           \u2502\n            \u2502  .init                 \u2502\n            \u2502  .rodata               \u2502\n            \u2502  .text                 \u2502\n   FLASH    \u2502  .vector_rom           \u2502\n0x0800 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __rom_start, __flash_start\n</code></pre>"},{"location":"reference/module/modm-platform-core-stm32/#instruction-core-coupled-ram-iccm","title":"Instruction Core-Coupled RAM (ICCM)","text":"<p>Some STM32F3, STM32L4 and STM32G4 devices have a single-cycle CCM that is accessible to the core via the I-Code and D-Code interface. Note that the CCM is not DMA-able.</p> <pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __sram3_end\n            \u2502 (+HEAP_SRAM3)          \u2502\n            \u2502 (.noinit_sram3)        \u2502\n            \u2502 (.bss_sram3)           \u2502  only if SRAM3 exists\n   SRAM3    \u2502 (.data_sram3)          \u2502\n0x2003 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __sram2_end, __sram3_start\n            \u2502 (+HEAP_SRAM2)          \u2502\n            \u2502 (.noinit_sram2)        \u2502\n            \u2502 (.bss_sram2)           \u2502  only if SRAM2 exists\n   SRAM2    \u2502 (.data_sram2)          \u2502\n0x2002 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __sram1_end, __sram2_start\n            \u2502  +HEAP_SRAM1           \u2502\n            \u2502  .noinit_sram1         \u2502\n            \u2502  .noinit               \u2502\n            \u2502  .faststack            \u2502\n            \u2502  .bss_sram1            \u2502\n            \u2502  .bss                  \u2502\n            \u2502  .data_sram1           \u2502\n            \u2502  .data                 \u2502\n   SRAM1    \u2502  +MAIN_STACK_SIZE      \u2502\u25c4 __main_stack_top\n0x2000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __sram1_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __ccm_end\n            \u2502  +HEAP_CCM             \u2502\n   D-Code   \u2502  .noinit_ccm           \u2502\n   I-Code   \u2502  .bss_ccm              \u2502\n    only    \u2502  .data_ccm             \u2502\n   access   \u2502  .fastdata             \u2502\n            \u2502  .fastcode             \u2502\n    CCM     \u2502  .vector_ram           \u2502\n0x1000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __ccm_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __flash_end\n            \u2502        (unused)        \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __rom_end\n            \u2502  .table.heap           \u2502\n            \u2502  .table.copy.extern    \u2502\n   tables   \u2502  .table.zero.extern    \u2502\n            \u2502  .table.copy.intern    \u2502\n            \u2502  .table.zero.intern    \u2502\n            \u2502                        \u2502\n            \u2502 (.data_sram3)          \u2502\u25c4 only if SRAM3 exists\n            \u2502 (.data_sram2)          \u2502\u25c4 only if SRAM2 exists\n            \u2502  .data_sram1           \u2502\n    copy    \u2502  .data_ccm             \u2502\n    only    \u2502  .data_backup          \u2502\n            \u2502  .data                 \u2502\n            \u2502  .fastdata             \u2502\n            \u2502  .fastcode             \u2502\n            \u2502                        \u2502\n            \u2502  .note.gnu.build-id    \u2502\n            \u2502  .assertion            \u2502\n            \u2502  .hardware_init        \u2502\n            \u2502 (.eh_frame)            \u2502\n    read    \u2502 (.ARM.exidx)           \u2502  only with C++ exceptions enabled\n    only    \u2502 (.ARM.extab)           \u2502\n            \u2502  .init_array           \u2502\n            \u2502  .init                 \u2502\n            \u2502  .rodata               \u2502\n            \u2502  .text                 \u2502\n   FLASH    \u2502  .vector_rom           \u2502\n0x0800 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __rom_start, __flash_start\n</code></pre>"},{"location":"reference/module/modm-platform-core-stm32/#tightly-coupled-ram-tcm","title":"Tightly-Coupled RAM (TCM)","text":"<p>The STM32F7 devices include an Instruction TCM (ITCM) and a data TCM (DTCM). Note that the DTCM section will overflow into the SRAM\u00bd sections.</p> <pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __backup_end\n            \u2502  +HEAP_BACKUP          \u2502\n            \u2502  .noinit_backup        \u2502\n            \u2502  .bss_backup           \u2502\n   BACKUP   \u2502  .data_backup          \u2502\n0x4002 4000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __backup_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __sram2_end\n            \u2502  +HEAP_SRAM2           \u2502\n            \u2502  .noinit_sram2         \u2502\n            \u2502  .bss_sram2            \u2502\n   SRAM2    \u2502  .data_sram2           \u2502\n0x2002 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __sram1_end, __sram2_start\n            \u2502  +HEAP_SRAM1           \u2502\n            \u2502  .noinit_sram1         \u2502\n            \u2502  .bss_sram1            \u2502\n   SRAM1    \u2502  .data_sram1           \u2502\n0x2001 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __dtcm_end, __sram1_start\n            \u2502  +HEAP_DTCM            \u2502\n            \u2502  .noinit_dtcm          \u2502\n            \u2502  .noinit               \u2502\n            \u2502  .faststack            \u2502\n   D-Code   \u2502  .bss_dtcm             \u2502\n    only    \u2502  .bss                  \u2502\n   access   \u2502  .data_dtcm            \u2502\n            \u2502  .data                 \u2502\n            \u2502  .fastdata             \u2502\n    DTCM    \u2502  +MAIN_STACK_SIZE      \u2502\u25c4 __main_stack_top\n0x2000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __dtcm_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __flash_end\n            \u2502        (unused)        \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __rom_end\n            \u2502  .table.heap           \u2502\n            \u2502  .table.copy.extern    \u2502\n   tables   \u2502  .table.zero.extern    \u2502\n            \u2502  .table.copy.intern    \u2502\n            \u2502  .table.zero.intern    \u2502\n            \u2502                        \u2502\n            \u2502  .data_sram2           \u2502\n            \u2502  .data_sram1           \u2502\n            \u2502  .data_dtcm            \u2502\n    copy    \u2502  .data_itcm            \u2502\n    only    \u2502  .data_backup          \u2502\n            \u2502  .data                 \u2502\n            \u2502  .fastdata             \u2502\n            \u2502  .fastcode             \u2502\n            \u2502                        \u2502\n            \u2502  .note.gnu.build-id    \u2502\n            \u2502  .assertion            \u2502\n            \u2502  .hardware_init        \u2502\n            \u2502 (.eh_frame)            \u2502\n    read    \u2502 (.ARM.exidx)           \u2502  only with C++ exceptions enabled\n    only    \u2502 (.ARM.extab)           \u2502\n            \u2502  .init_array           \u2502\n            \u2502  .init                 \u2502\n            \u2502  .rodata               \u2502\n            \u2502  .text                 \u2502\n   FLASH    \u2502  .vector_rom           \u2502\n0x0800 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __rom_start, __flash_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __itcm_end\n            \u2502  +HEAP_ITCM            \u2502\n            \u2502  .noinit_itcm          \u2502\n            \u2502  .bss_itcm             \u2502\n            \u2502  .data_itcm            \u2502\n            \u2502  .fastcode             \u2502\n    ITCM    \u2502  .vector_ram           \u2502\n0x0000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __itcm_start\n</code></pre> <p>The STM32H7 memory map is more complex with multiple SRAM regions in seperate power domains D1, D2 and D3. Note that the main <code>.data</code> and <code>.bss</code> sections are placed into the D1_SRAM section because the TCMs can't be accessed by peripheral DMA transfers, but only the MDMA.</p> <pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __backup_end\n            \u2502  +HEAP_BACKUP          \u2502\n            \u2502  .noinit_backup        \u2502\n            \u2502  .bss_backup           \u2502\n   BACKUP   \u2502  .data_backup          \u2502\n0x3880 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __backup_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __d3_sram_end\n            \u2502  +HEAP_D3_SRAM         \u2502\n            \u2502  .noinit_d3_sram       \u2502\n            \u2502  .bss_d3_sram          \u2502\n  D3_SRAM   \u2502  .data_d3_sram         \u2502\n0x3800 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __d3_sram_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __d2_sram3_end\n            \u2502 (+HEAP_D2_SRAM3)       \u2502\n            \u2502 (.noinit_d2_sram3)     \u2502\n            \u2502 (.bss_d2_sram3)        \u2502  only if D2_SRAM3 exists\n  D2_SRAM3  \u2502 (.data_d2_sram3)       \u2502\n0x3004 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __d2_sram2_end, __d2_sram3_start\n            \u2502  +HEAP_D2_SRAM2        \u2502\n            \u2502  .noinit_d2_sram2      \u2502\n            \u2502  .bss_d2_sram2         \u2502\n  D2_SRAM2  \u2502  .data_d2_sram2        \u2502\n0x3002 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __d2_sram1_end, __d2_sram2_start\n            \u2502  +HEAP_D2_SRAM1        \u2502\n            \u2502  .noinit_d2_sram1      \u2502\n            \u2502  .bss_d2_sram1         \u2502\n  D2_SRAM1  \u2502  .data_d2_sram1        \u2502\n0x3000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __d2_sram1_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __d1_sram3_end\n            \u2502 (+HEAP_D1_SRAM3)       \u2502\n            \u2502 (.noinit_d1_sram3)     \u2502\n            \u2502 (.bss_d1_sram3)        \u2502  only if D1_SRAM3 exists\n  D1_SRAM3  \u2502 (.data_d1_sram3)       \u2502\n0x240A 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __d1_sram2_end, __d1_sram3_start\n            \u2502 (+HEAP_D1_SRAM2)       \u2502\n            \u2502 (.noinit_d1_sram2)     \u2502\n            \u2502 (.bss_d1_sram2)        \u2502  only if D1_SRAM2 exists\n  D1_SRAM2  \u2502 (.data_d1_sram2)       \u2502\n0x2404 0000 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __d1_sram1_end, __d1_sram2_start\n            \u2502  +HEAP_D1_SRAM1        \u2502\n            \u2502  .noinit_d1_sram1      \u2502\n            \u2502  .noinit               \u2502\n            \u2502  .faststack            \u2502\n            \u2502  .bss_d1_sram1         \u2502\n            \u2502  .bss                  \u2502\n            \u2502  .data_d1_sram1        \u2502\n  D1_SRAM1  \u2502  .data                 \u2502\n0x2400 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __d1_sram1_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __dtcm_end\n            \u2502  +HEAP_DTCM            \u2502\n   D-Code   \u2502  .noinit_dtcm          \u2502\n    only    \u2502  .bss_dtcm             \u2502\n   access   \u2502  .data_dtcm            \u2502\n            \u2502  .fastdata             \u2502\n    DTCM    \u2502  +MAIN_STACK_SIZE      \u2502\u25c4 __main_stack_top\n0x2000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __dtcm_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __flash_end\n            \u2502        (unused)        \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __rom_end\n            \u2502  .table.heap           \u2502\n            \u2502  .table.copy.extern    \u2502\n   tables   \u2502  .table.zero.extern    \u2502\n            \u2502  .table.copy.intern    \u2502\n            \u2502  .table.zero.intern    \u2502\n            \u2502                        \u2502\n            \u2502  .data_d3_sram         \u2502\n            \u2502 (.data_d2_sram3)       \u2502\u25c4 only if D2_SRAM3 exists\n            \u2502  .data_d2_sram2        \u2502\n            \u2502  .data_d2_sram1        \u2502\n            \u2502 (.data_d1_sram3)       \u2502\u25c4 only if D1_SRAM3 exists\n            \u2502 (.data_d1_sram2)       \u2502\u25c4 only if D1_SRAM2 exists\n    copy    \u2502  .data_d1_sram1        \u2502\n    only    \u2502  .data_dtcm            \u2502\n            \u2502  .data_itcm            \u2502\n            \u2502  .data_backup          \u2502\n            \u2502  .data                 \u2502\n            \u2502  .fastdata             \u2502\n            \u2502  .fastcode             \u2502\n            \u2502                        \u2502\n            \u2502  .note.gnu.build-id    \u2502\n            \u2502  .assertion            \u2502\n            \u2502  .hardware_init        \u2502\n            \u2502 (.eh_frame)            \u2502\n    read    \u2502 (.ARM.exidx)           \u2502  only with C++ exceptions enabled\n    only    \u2502 (.ARM.extab)           \u2502\n            \u2502  .init_array           \u2502\n            \u2502  .init                 \u2502\n            \u2502  .rodata               \u2502\n            \u2502  .text                 \u2502\n   FLASH    \u2502  .vector_rom           \u2502\n0x0800 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __rom_start, __flash_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __itcm_end\n            \u2502  +HEAP_ITCM            \u2502\n            \u2502  .noinit_ccm           \u2502\n            \u2502  .bss_itcm             \u2502\n            \u2502  .data_itcm            \u2502\n            \u2502  .fastcode             \u2502\n    ITCM    \u2502  .vector_ram           \u2502\n0x0000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __itcm_start\n</code></pre>"},{"location":"reference/module/modm-platform-core-stm32/#static-ram-sram-with-vector-table-remap-on-f0-devices","title":"Static RAM (SRAM) with vector table remap on F0 devices","text":"<p>This memory map is identical to the SRAM default one, except that <code>.vector_ram</code> is placed at the beginning of SRAM1. It is used on STM32F0 devices in case the platform-specific vector table relocation option <code>modm:platform:core:vector_table_location</code> is set to <code>ram</code>.</p> <pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __sram1_end\n            \u2502  +HEAP_SRAM1           \u2502\n            \u2502  .noinit_sram1         \u2502\n            \u2502  .noinit               \u2502\n            \u2502  .faststack            \u2502\n            \u2502  .bss_sram1            \u2502\n            \u2502  .bss                  \u2502\n            \u2502  .data_sram1           \u2502\n            \u2502  .data                 \u2502\n            \u2502  .fastdata             \u2502\n            \u2502  .fastcode             \u2502\n            \u2502  +MAIN_STACK_SIZE      \u2502\u25c4 __main_stack_top\n   SRAM1    \u2502  .vector_ram           \u2502\n0x2000 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __sram1_start\n\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25c4 __flash_end\n            \u2502        (unused)        \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4 __rom_end\n            \u2502  .table.heap           \u2502\n            \u2502  .table.copy.extern    \u2502\n   tables   \u2502  .table.zero.extern    \u2502\n            \u2502  .table.copy.intern    \u2502\n            \u2502  .table.zero.intern    \u2502\n            \u2502                        \u2502\n    copy    \u2502  .data_sram1           \u2502\n    only    \u2502  .data                 \u2502\n            \u2502  .fastcode             \u2502\n            \u2502  .fastdata             \u2502\n            \u2502                        \u2502\n            \u2502  .note.gnu.build-id    \u2502\n            \u2502  .assertion            \u2502\n            \u2502  .hardware_init        \u2502\n            \u2502 (.eh_frame)            \u2502\n    read    \u2502 (.ARM.exidx)           \u2502  only with C++ exceptions enabled\n    only    \u2502 (.ARM.extab)           \u2502\n            \u2502  .init_array           \u2502\n            \u2502  .init                 \u2502\n            \u2502  .rodata               \u2502\n            \u2502  .text                 \u2502\n   FLASH    \u2502  .vector_rom           \u2502\n0x0800 0000 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u25c4 __rom_start, __flash_start\n</code></pre> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-platform-core-stm32/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-core-stm32/#main_stack_location","title":"main_stack_location","text":"<p>SRAM (default) or DTCM (faster, but not DMA-capable)</p> <p>This option is only available for stm32h7.</p> <p>Default: <code>sram</code> Inputs: <code>[dtcm, sram]</code> </p>"},{"location":"reference/module/modm-platform-core-stm32/#vector_table_location","title":"vector_table_location","text":"<p>Vector table location in ROM or RAM on F0 devices</p> <p>STM32 devices with a Cortex-M0 core provide a platform-specific method to place the interrupt vector table in SRAM although the core does not support vector table relocation. It is only available on STM32F0 since all other devices can remap the vector table in the Cortex-M core.</p> <p>When this method is activated the vector table is copied to the start of SRAM1 by the startup script. The <code>SYSCFG-&gt;CFGR1</code> register is set to remap the beginning of SRAM to the vector table location at <code>0x0000 0000</code>.</p> <p>You can modify the RAM vector table using the CMSIS NVIC functions:</p> <ul> <li><code>void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)</code></li> <li><code>uint32_t NVIC_GetVector(IRQn_Type IRQn)</code></li> </ul> <p>This remapping method allows to easily boot an application from a custom bootloader even if the Cortex-M0 core does not support relocation.</p> <p>For applications that do not modify the vector table at runtime, relocation to RAM is not necessary and can save a few hundred bytes of static memory.</p> <p>On Interrupt Latency</p> <p>Placing main stack and vector table into the same memory can significantly slow down interrupt latency, since both I-Code and D-Code memory interface need to fetch from the same access port.</p> <p>This option is only available for stm32f0.</p> <p>Default: <code>rom</code> Inputs: <code>[ram, rom]</code> </p>"},{"location":"reference/module/modm-platform-core-stm32/#dependencies","title":"Dependencies","text":"<p> modm:platform:core modm_platform_core modm: platform: core modm_platform_cortex_m modm: platform: cortex-m modm_platform_core-&gt;modm_platform_cortex_m </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-cortex-m/","title":"ARM Cortex-M Core","text":"<p>lbuild module: <code>modm:platform:cortex-m</code></p> <p>This module generates the startup code, vector table, linkerscript as well as initialize the heap, deal with assertions, provide blocking delay functions, atomic and unaligned access and the GNU build ID.</p> <p>Since this is only initializes the generic ARM Cortex-M parts, it delegates device-specific initialization to the <code>modm:platform:core</code> module. Please depend on that module directly instead of this one.</p>"},{"location":"reference/module/modm-platform-cortex-m/#startup","title":"Startup","text":"<p>After reset, the ARM Cortex-M hardware jumps to the <code>Reset_Handler()</code>, which is implemented as follows:</p> <ol> <li>The main stack pointer (MSP) is initialized by software.</li> <li>Call <code>__modm_initialize_platform()</code> to initialize the device hardware.</li> <li>Call <code>modm_initialize_platform()</code> to initialize the custom device hardware.</li> <li>Copy data to internal RAM.</li> <li>Zero sections in internal RAM.</li> <li>Initialize ARM Cortex-M core: enable FPU, caches and relocate vector table.</li> <li>Execute shared hardware initialization functions.</li> <li>Copy data to external RAM.</li> <li>Zero sections in external RAM.</li> <li>Initialize heap via <code>__modm_initialize_memory()</code> (implemented by the     <code>modm:platform:heap</code> module).</li> <li>Call static constructors.</li> <li>Call <code>main()</code> application entry point.</li> <li>If <code>main()</code> returns, assert on <code>main.exit</code> (only in debug profile).</li> <li>Reboot if assertion returns.</li> </ol>"},{"location":"reference/module/modm-platform-cortex-m/#device-initialization","title":"Device Initialization","text":"<p>The <code>__modm_initialize_platform()</code> function is called directly after reset, and its purpose is to initialize the device specific hardware, such as enable internal memories or disable the hardware watchdog timer. You can provide additional application-specific initialization by overwriting the weakly linked <code>modm_initialize_platform()</code> function:</p> <pre><code>extern \"C\" void modm_initialize_platform()\n{\n    // Configure power settings before accessing SRAM\n}\n</code></pre> <p>It's important to understand that because the <code>.data</code> section has not yet been copied and the <code>.bss</code> section has not yet been zeroed, there exists no valid C environment yet in this function context! This means you cannot use any global variables, not even \"local\" static  ones defined in your function, and depending on your hardware you may not even access read-only data (<code>const</code> variables, global OR local). In addition, if your linkerscript places the main stack pointer into a memory that is disabled on reset, you cannot even access the stack until you've enabled its backing memory. The <code>Reset_Handler</code> therefore calls this function in Assembly without accessing the stack.</p> <p>It is strongly recommended to only read/write registers in this function, and perhaps even write this function in Assembly if deemed necessary.</p>"},{"location":"reference/module/modm-platform-cortex-m/#cache-initialization","title":"Cache Initialization","text":"<p>For Cortex-M7 devices, the I-Cache is enabled by default. The D-Cache with a write-back write-allocate policy is only enabled if the <code>modm:platform:dma</code> module is NOT selected. modm currently does not support allocating DMA buffers in non-cachable regions or granular cache invalidation. See the CMSIS-Core Cache API for more information on cache management.</p>"},{"location":"reference/module/modm-platform-cortex-m/#additional-initialization","title":"Additional Initialization","text":"<p>A few modules need to initialize additional hardware during booting. For example: your device has external memories connected that you want to use for the heap. You can create a function that configures the peripherals for these external memories and place a pointer to this function into a special linker section and the startup script will then call this function before heap initialization.</p> <p>Since the hardware init functions are called after internal data initialization, you have a valid C environment and thus can access the device normally, but since the calls happen before external data and heap initialization you cannot use the heap in these functions!</p> <p>You can give a relative global order to your init functions. Ordered init functions are called first, then unordered init functions are called in any order. Please note that order numbers 0 - 999 are reserved for use by modm or other libraries!</p> <p>Unique init function names</p> <p>Init function names need to be globally unique for linking. Unfortunately there is no simple way of stringifying C++ functions, so you have to provide a name manually for now.</p> <pre><code>void init_external_sdram()\n{\n    // configure the hardware here\n}\n// Startup script calls this function in any order, *after* prioritized functions!\nMODM_HARDWARE_INIT(init_external_sdram);\n// If you need to pass a C++ function, you need to declare\nMODM_HARDWARE_INIT_NAME(init_function_name, namespace::init_function);\n\n// If you need to initialize in a certain order use numbers &gt;= 1000\nMODM_HARDWARE_INIT_ORDER(init_before_sdram1, 1000);\n// called after init_before_sdram1, since it has a higher order number\nMODM_HARDWARE_INIT_NAME_ORDER(init_before_sdram2, namespace::function, 1001);\n</code></pre>"},{"location":"reference/module/modm-platform-cortex-m/#interrupt-vector-table","title":"Interrupt Vector Table","text":"<p>The Cortex-M vector table (VTOR) is target-specific and generated using data from modm-devices. The main stack pointer is allocated according to the linkerscript and the <code>Reset_Handler</code> is defined by the startup script.</p> <p>All handlers are weakly aliased to <code>Undefined_Handler</code>, which is called if an IRQ is enabled, but no handler is defined for it. This default handler determines the currectly active IRQ, sets its priority to the lowest level, and disables the IRQ from firing again and then asserts on <code>nvic.undef</code> with the (signed) IRQ number as context.</p> <p>The lowering of the priority is necessary, since the assertion handlers (see <code>modm:architecture:assert</code>) are called from within this active IRQ and its priority should not prevent logging functionality (which might require a UART interrupt to flush data out) from working correctly.</p>"},{"location":"reference/module/modm-platform-cortex-m/#linkerscript","title":"Linkerscript","text":"<p>This module provides building blocks for GNU ld linkerscripts in the form of Jinja macros that the <code>modm:platform:core</code> module assembles into a linkerscript, depending on the memory architecture of the target chosen.</p> <p>The following macros are available:</p> <ul> <li> <p><code>copyright()</code>: Copyright notice.</p> </li> <li> <p><code>prefix()</code>: Contains <code>MEMORY</code> sections, output format and entry symbol and   stack size definitions.</p> </li> <li> <p><code>section_vector_rom(memory)</code>: places the read-only vector table into ROM   <code>memory</code>.</p> </li> <li> <p><code>section_vector_ram(memory, table_copy)</code>: places the volatile vector table   into RAM <code>memory</code> and add it to the copy table. You must satisfy alignment   requirements externally.</p> </li> <li> <p><code>section_load(memory, table_copy, sections)</code>: place each <code>.{section}</code> in   <code>sections</code> into <code>memory</code> and add them the copy table.</p> </li> <li> <p><code>section_stack(memory, start=None, suffix=\"\")</code>: place the main stack into   <code>memory</code> after moving the location counter to <code>start</code>. <code>suffix</code> can be used   to add multiple <code>.stack{suffix}</code> sections.</p> </li> <li> <p><code>section_heap(memory, name, placement=None, sections=[])</code>: Add the noload   <code>sections</code> to <code>memory</code> and fill up remaining space in <code>memory</code> with heap   section <code>.{name}</code>. Argument <code>placement</code> can be used to place the section into   a larger continuous section of which <code>memory</code> is just a subsection. The   <code>__{name}_end</code> will be the maximum of the location counter and the <code>memory</code>   section end address, so that previous sections will push this section back.</p> </li> <li> <p><code>all_heap_sections(table_copy, table_zero, table_heap, props={})</code>: places the   heap sections as described by <code>cont_ram_regions</code> of the <code>linkerscript</code> query.   This also adds bss and noinit sections into each region. The <code>props</code> key can   be used to override the default <code>0x001f</code> memory properties.</p> </li> <li> <p><code>section_rom(memory)</code>: place all read-only sections (<code>.text</code>, <code>.rodata</code> etc)   into <code>memory</code>.</p> </li> <li> <p><code>section_ram(memory, rom, table_copy, table_zero,   sections_data=[], sections_bss=[], sections_noinit=[])</code>: place all volatile   sections (<code>.data</code>, <code>.bss</code> etc) into <code>memory</code> and load from <code>rom</code>. Additional   sections can be added.</p> </li> <li> <p><code>section_tables(memory, copy, zero, heap)</code>: place the zero, copy and heap   table into <code>memory</code>.</p> </li> <li> <p><code>section_rom_start(memory)</code>: place at ROM start.</p> </li> <li> <p><code>section_rom_end(memory)</code>: place at ROM end.</p> </li> <li> <p><code>section_debug()</code>: place debug sections at the very end.</p> </li> </ul> <p>Please consult the <code>modm:platform:core</code> documentation for the target-specific arrangement of these section macros and for potential limitations that the target's memory architecture poses.</p>"},{"location":"reference/module/modm-platform-cortex-m/#section-fastdata","title":"Section <code>.fastdata</code>","text":"<p>The <code>.fastdata</code> section is placed into a device specific data cache or into the fastest RAM. Please note that the <code>.fastdata</code> section may be placed into RAM that is only accessable to the Cortex-M core (via the Data-Bus), which can cause issues with DMA access. However, the <code>.fastdata</code> section is not required to be DMA-able and in such a case the developer needs to place the data into the generic <code>.data</code> section or choose a device with a DMA-able fast RAM.</p>"},{"location":"reference/module/modm-platform-cortex-m/#section-fastcode","title":"Section <code>.fastcode</code>","text":"<p>The <code>.fastcode</code> section is placed into a device specific instruction cache (via I-Code bus) or into the fastest executable RAM (via S-Bus).</p> <p>From the Cortex-M3 Technical Reference Manual:</p> <p>14.5 System Interface:</p> <p>The system interface is a 32-bit AHB-Lite bus. Instruction and vector fetches, and data and debug accesses to the System memory space, 0x20000000 - 0xDFFFFFFF, 0xE0100000 - 0xFFFFFFFF, are performed over this bus.</p> <p>14.5.6 Pipelined instruction fetches:</p> <p>To provide a clean timing interface on the System bus, instruction and vector fetch requests to this bus are registered. This results in an additional cycle of latency because instructions fetched from the System bus take two cycles. This also means that back-to-back instruction fetches from the System bus are not possible.</p> <p>Note:   Instruction fetch requests to the ICode bus are not registered.   Performance critical code must run from the ICode interface.</p>"},{"location":"reference/module/modm-platform-cortex-m/#adding-sections","title":"Adding Sections","text":"<p>The default linkerscripts only describe the internal memory, however, they can be extended for external memories using the <code>linkerscript.*</code> collectors of this module. For example, to add an external 16MB SDRAM to your device and place a static data section there that is copied from flash and use the remainder for heap access, these steps need to be performed:</p> <p>Add the external SDRAM to the linkerscript's <code>MEMORY</code> statements in the <code>project.xml</code> configuration:</p> <pre><code>&lt;library&gt;\n  &lt;collectors&gt;\n    &lt;collect name=\"modm:platform:cortex-m:linkerscript.memory\"&gt;\n       SDRAM (rwx) : ORIGIN = 0xC0000000, LENGTH = 16M\n    &lt;/collect&gt;\n  &lt;collectors&gt;\n&lt;/library&gt;\n</code></pre> <p>You can also declare this as Python code in a lbuild <code>module.lb</code> file (useful for board support packages modules, see <code>modm:board</code>):</p> <pre><code>env.collect(\":platform:cortex-m:linkerscript.memory\",\n            \"SDRAM (rwx) : ORIGIN = 0xC0000000, LENGTH = 16M\")\n</code></pre> <p>Add a partition of the new memory to the linkerscripts <code>SECTION</code> statements. Since collectors order is only preserved locally, make sure to add the sections that depend on this order in one value. Here the previous value of the SDRAM location counter is required to \"fill up\" the remaining memory with the external heap section:</p> <pre><code>linkerscript_sections = \"\"\"\n.data_sdram :\n{\n    __data_sdram_load = LOADADDR(.data_sdram);\n    __data_sdram_start = .;\n\n    *(.data_sdram)\n\n    . = ALIGN(4);\n    __data_sdram_end = .;\n} &gt;SDRAM AT &gt;FLASH\n\n.heap_sdram (NOLOAD) :\n{\n    __heap_sdram_start = .;\n    . = ORIGIN(SDRAM) + LENGTH(SDRAM);\n    __heap_sdram_end = .;\n} &gt;SDRAM\n\"\"\"\nenv.collect(\":platform:cortex-m:linkerscript.sections\", linkerscript_sections)\n</code></pre> <p>Next, add the sections that need to be copied from ROM to RAM, here the contents of the <code>.data_sdram</code> section is stored in the internal <code>FLASH</code> memory and needs to be copied into SDRAM during the startup:</p> <pre><code>linkerscript_copy = \"\"\"\nLONG(__data_sdram_load)\nLONG(__data_sdram_start)\nLONG(__data_sdram_end)\n\"\"\"\nenv.collect(\":platform:cortex-m:linkerscript.table_extern.copy\", linkerscript_copy)\n</code></pre> <p>And finally, to register the remaining memory in SDRAM with the allocator, add the memory range to the heap table. Remember to use the correct memory traits for this memory, see <code>modm:architecture:memory</code> for the trait definitions:</p> <pre><code>linkerscript_heap = \"\"\"\nLONG(0x801f)\nLONG(__heap_sdram_start)\nLONG(__heap_sdram_end)\n\"\"\"\nenv.collect(\":platform:cortex-m:linkerscript.table_extern.heap\", linkerscript_heap)\n</code></pre> <p>Linkerscript collectors are plain text</p> <p>The collectors here only strip the leading/trailing whitespace and newlines and paste the result as is into the linkerscripts. No input validation is performed, so if you receive linker errors with your additions, please check the GNU LD documentation first.</p>"},{"location":"reference/module/modm-platform-cortex-m/#blocking-delay","title":"Blocking Delay","text":"<p>The delay functions as defined by <code>modm:architecture:delay</code> are implemented via software loop (ARMv6-M devices) or hardware cycle counter (via <code>DWT-&gt;CYCCNT</code> on ARMv7-M device) and have the following limitations expressed in cycles, which depends on the configured CPU frequency:</p> <ul> <li>nanosecond delay is implemented as a tight loop with a minimum delay of &lt;20   cycles, a resolution of 1-4 cycles and a maximum delay of 32-bit cycles.</li> <li>microsecond delay has a maximum delay of 32-bit cycles.</li> </ul>"},{"location":"reference/module/modm-platform-cortex-m/#compiler-options","title":"Compiler Options","text":"<p>This module adds these architecture specific compiler options:</p> <ul> <li><code>-mcpu=cortex-m{type}</code>: the target to compile for.</li> <li><code>-mthumb</code>: only Thumb2 instruction set is supported.</li> <li><code>-mfloat-abi={soft, softfp, hard}</code>: the FPU ABI: <code>hard</code> is fastest.</li> <li><code>-mfpu=fpv{4, 5}-{sp}-d16</code>: single or double precision FPU.</li> <li><code>-Wdouble-promotion</code>: if SP-FPU, warn if FPs are promoted to doubles. Note   that unless you use the <code>.f</code> suffix or explicitly cast floating point   operations to <code>float</code>, floating point constants are of <code>double</code> type, whose   storage can result in an increased binary size. While you can add the   <code>-fsingle-precision-constant</code> compiler flag to implicitly cast all doubles to   floats, this also impacts compile time computations and may reduce accuracy.   Therefore it is not enabled by default and you should carefully watch for any   unwanted numeric side effects if you use this compiler option.   See Semantics of Floating Point Math in GCC.</li> </ul> <p>In addition, these linker options are added:</p> <ul> <li><code>-nostartfiles</code>: modm implements its own startup script.</li> <li><code>-wrap,_{calloc, malloc, realloc, free}_r</code>: reimplemented Newlib with our own allocator.</li> </ul> <p>This module is only available for rp, sam, stm32.</p>"},{"location":"reference/module/modm-platform-cortex-m/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-cortex-m/#enable_dcache","title":"enable_dcache","text":"<p>Enable Data-Cache</p> <p>This option is only available for same7x/s7x/v7x, stm32{f7,h7}.</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-platform-cortex-m/#enable_icache","title":"enable_icache","text":"<p>Enable Instruction-Cache</p> <p>This option is only available for same7x/s7x/v7x, stm32{f7,h7}.</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-platform-cortex-m/#float-abi","title":"float-abi","text":"<p>Floating point ABI</p> <p>This option is only available for sam{d5x/e5x,e7x/s7x/v7x,g5x}, stm32{f3,f4,f7,g4,h7,l4,l5,u5}.</p> <p>Default: <code>hard</code> Inputs: <code>[hard, soft, softfp]</code> </p>"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptflash_offset","title":"linkerscript.flash_offset","text":"<p>Offset of FLASH Section Origin</p> <p>Add an offset to the default start address of the flash memory. This might be required for bootloaders located there.</p> <p>Vector Table Relocation</p> <p>Not all offsets are compatible with the vector table relocation.</p> <p>Default: <code>0</code> Inputs: <code>[0 ... 0x10000]</code> samd1x/d2x/dax, stm32{c0,f0,f1,f3,f4,f7,g0,l0,l1,l4} Inputs: <code>[0 ... 0x100000]</code> sam{d5x/e5x,e7x/s7x/v7x}, stm32{f4,f7,h7,l4,u5} Inputs: <code>[0 ... 0x1000000]</code> rp2040 Inputs: <code>[0 ... 0x180000]</code> stm32f4 Inputs: <code>[0 ... 0x2000]</code> stm32l0 Inputs: <code>[0 ... 0x20000]</code> samd1x/d2x/dax, stm32{c0,f0,f1,f2,f3,f4,g0,g4,h7,l0,l4,u5} Inputs: <code>[0 ... 0x200000]</code> same7x/s7x/v7x, stm32{f4,f7,h7,l4,u5} Inputs: <code>[0 ... 0x30000]</code> stm32l0 Inputs: <code>[0 ... 0x4000]</code> stm32{c0,f0,f1,f3,g0,l0} Inputs: <code>[0 ... 0x40000]</code> sam{d1x/d2x/dax,d5x/e5x}, stm32{c0,f0,f1,f2,f3,f4,f7,g0,g4,l1,l4,l5,u5} Inputs: <code>[0 ... 0x400000]</code> stm32u5 Inputs: <code>[0 ... 0x60000]</code> stm32{f3,l1} Inputs: <code>[0 ... 0x8000]</code> samd1x/d2x/dax, stm32{c0,f0,f3,g0,g4,l0,l1} Inputs: <code>[0 ... 0x80000]</code> sam{d5x/e5x,e7x/s7x/v7x,g5x}, stm32{f2,f3,f4,f7,g0,g4,h7,l1,l4,l5,u5} </p>"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptflash_reserved","title":"linkerscript.flash_reserved","text":"<p>Add a reserved section at the end of the flash.</p> <p>Default: <code>0</code> Inputs: <code>[0 ... 0x10000]</code> samd1x/d2x/dax, stm32{c0,f0,f1,f3,f4,f7,g0,l0,l1,l4} Inputs: <code>[0 ... 0x100000]</code> sam{d5x/e5x,e7x/s7x/v7x}, stm32{f4,f7,h7,l4,u5} Inputs: <code>[0 ... 0x1000000]</code> rp2040 Inputs: <code>[0 ... 0x180000]</code> stm32f4 Inputs: <code>[0 ... 0x2000]</code> stm32l0 Inputs: <code>[0 ... 0x20000]</code> samd1x/d2x/dax, stm32{c0,f0,f1,f2,f3,f4,g0,g4,h7,l0,l4,u5} Inputs: <code>[0 ... 0x200000]</code> same7x/s7x/v7x, stm32{f4,f7,h7,l4,u5} Inputs: <code>[0 ... 0x30000]</code> stm32l0 Inputs: <code>[0 ... 0x4000]</code> stm32{c0,f0,f1,f3,g0,l0} Inputs: <code>[0 ... 0x40000]</code> sam{d1x/d2x/dax,d5x/e5x}, stm32{c0,f0,f1,f2,f3,f4,f7,g0,g4,l1,l4,l5,u5} Inputs: <code>[0 ... 0x400000]</code> stm32u5 Inputs: <code>[0 ... 0x60000]</code> stm32{f3,l1} Inputs: <code>[0 ... 0x8000]</code> samd1x/d2x/dax, stm32{c0,f0,f3,g0,g4,l0,l1} Inputs: <code>[0 ... 0x80000]</code> sam{d5x/e5x,e7x/s7x/v7x,g5x}, stm32{f2,f3,f4,f7,g0,g4,h7,l1,l4,l5,u5} </p>"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptoverride","title":"linkerscript.override","text":"<p>Path to project provided linkerscript</p> <p>Default: <code>[]</code> Inputs: <code>[Path]</code> </p>"},{"location":"reference/module/modm-platform-cortex-m/#main_stack_size","title":"main_stack_size","text":"<p>Minimum size of the application main stack</p> <p>The ARM Cortex-M uses a descending stack mechanism which is placed so that it grows towards the beginning of RAM. In case of a stack overflow the hardware then attempts to stack into invalid memory which triggers a HardFault. A stack overflow will therefore never overwrite any static or heap memory and this protection works without the MPU and therefore also on ARM Cortex-M0 devices.</p> <p>If the vector table is relocated into RAM, the start address needs to be aligned to the next highest power-of-two word depending on the total number of device interrupts. On devices where the table is relocated into the same memory as the main stack, an alignment buffer up to 1kB is added to the main stack.</p> <pre><code>|              ...                |\n|---------------------------------|\n|    Interrupt Vectors (in RAM)   |\n|        (if re-mapped)           | &lt;-- vector table origin\n|---------------------------------| &lt;-- main stack top\n|           Main Stack            |\n|       (grows downwards)         |\n|               |                 |\n|               v                 |\n|---------------------------------|\n|  Alignment buffer for vectors   |\n|   (overwritten by main stack!)  |\n'---------------------------------' &lt;-- RAM origin\n</code></pre> <p>Default: <code>3Ki (3072)</code> Inputs: <code>[256 .. 3Ki .. 64Ki]</code> </p>"},{"location":"reference/module/modm-platform-cortex-m/#vector_table_location","title":"vector_table_location","text":"<p>Vector table location in ROM or RAM</p> <p>The vector table is always stored in ROM and copied to RAM by the startup script if required. You can modify the RAM vector table using the CMSIS NVIC functions:</p> <ul> <li><code>void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)</code></li> <li><code>uint32_t NVIC_GetVector(IRQn_Type IRQn)</code></li> </ul> <p>For applications that do not modify the vector table at runtime, relocation to RAM is not necessary and can save a few hundred bytes of static memory.</p> <p>By default, the fastest option is chosen depending on the target memory architecture. This does not always mean the table is copied into RAM, and therefore may not be modifiable with this option!</p> <p>From the ARM Cortex-M4 Technical Reference Manual on exception handling:</p> <ul> <li>Processor state is automatically stored to the stack on an exception, and   automatically restored from the stack at the end of the Interrupt Service   Routine.</li> <li>The vector is fetched in parallel to the state saving, enabling efficient   interrupt entry.</li> </ul> <p>On Interrupt Latency</p> <p>Placing main stack and vector table into the same memory can significantly slow down interrupt latency, since both I-Code and D-Code memory interface need to fetch from the same access port.</p> <p>This option is only available for rp, sam, stm32{c0,f1,f2,f3,f4,f7,g0,g4,h7,l0,l1,l4,l5,u5}.</p> <p>Default: <code>ram</code> stm32{f3,f7,g4,h7,l4} Default: <code>rom</code> rp, sam, stm32{c0,f1,f2,f3,f4,g0,l0,l1,l4,l5,u5} Inputs: <code>[ram, rom]</code> </p>"},{"location":"reference/module/modm-platform-cortex-m/#collectors","title":"Collectors","text":""},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptmemory","title":"linkerscript.memory","text":"<p>Additions to the linkerscript's 'MEMORY'</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptsections","title":"linkerscript.sections","text":"<p>Additions to the linkerscript's 'SECTIONS'</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-platform-cortex-m/#linkerscripttable_externcopy","title":"linkerscript.table_extern.copy","text":"<p>Additions to the linkerscript's '.table.copy.extern' section</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-platform-cortex-m/#linkerscripttable_externheap","title":"linkerscript.table_extern.heap","text":"<p>Additions to the linkerscript's '.table.heap' section</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-platform-cortex-m/#linkerscripttable_externzero","title":"linkerscript.table_extern.zero","text":"<p>Additions to the linkerscript's '.table.zero.extern' section</p> <p>Inputs: <code>[String]</code></p>"},{"location":"reference/module/modm-platform-cortex-m/#queries","title":"Queries","text":""},{"location":"reference/module/modm-platform-cortex-m/#linkerscript_1","title":"linkerscript","text":"<p>Computes linkerscript properties (* post-build only):</p> <ul> <li><code>vector_table_location</code>: ram or rom</li> </ul> <p>Stripped and newline-joined collector values of:</p> <ul> <li><code>linkerscript_memory</code></li> <li><code>linkerscript_sections</code></li> <li><code>linkerscript_extern_zero</code></li> <li><code>linkerscript_extern_copy</code></li> <li><code>linkerscript_extern_heap</code></li> </ul> <p>Additional memory properties:</p> <ul> <li><code>memories</code>: unfiltered memory regions</li> <li><code>ram_regions</code>: memory region name with <code>ram</code> in their names</li> <li><code>regions</code>: memory region names</li> <li><code>cont_ram_regions</code>: all continuous internal SRAM sections</li> <li><code>cont_ram</code>: largest continuous internal SRAM section</li> </ul> <p>:returns: dictionary of linkerscript properties</p>"},{"location":"reference/module/modm-platform-cortex-m/#vector_table","title":"vector_table","text":"<p>Computes vector table properties:</p> <ul> <li><code>vector_table</code>: [position] = Full vector name (ie. with <code>_Handler</code> or <code>_IRQHandler</code> suffix)</li> <li><code>vector_table_location</code>: rom or ram</li> <li><code>vector_table_size</code>: in Bytes</li> <li><code>highest_irq</code>: highest IRQ number + 1</li> <li><code>core</code>: cortex-m{0,3,4,7}{,+,f,fd}</li> <li><code>exception_frame_size</code>: in Bytes.</li> </ul> <p>The system vectors start at -16, so you must add 16 to <code>highest_irq</code> to get the total number of vectors in the table!</p> <p>:returns: a dictionary of vector table properties</p>"},{"location":"reference/module/modm-platform-cortex-m/#dependencies","title":"Dependencies","text":"<p> modm:platform:cortex-m modm_platform_cortex_m modm: platform: cortex-m modm_architecture_interrupt modm: architecture: interrupt modm_platform_cortex_m-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_cortex_m-&gt;modm_cmsis_device modm_stdc++ modm: stdc++ modm_platform_cortex_m-&gt;modm_stdc++ </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-dac-same7x-s7x-v7x/","title":"D/A converter (DACC)","text":"<p>lbuild module: <code>modm:platform:dac</code></p> <p>This module is only available for same7x/s7x/v7x.</p>"},{"location":"reference/module/modm-platform-dac-same7x-s7x-v7x/#dependencies","title":"Dependencies","text":"<p> modm:platform:dac modm_platform_dac modm: platform: dac modm_architecture_register modm: architecture: register modm_platform_dac-&gt;modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_dac-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_dac-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_dac-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-dac-stm32-f0-f1-f2-f3-f4-f7-g0-g4-h7-l0-l1-l4-l5-u5/","title":"Digital-to-Analog Converter (DAC)","text":"<p>lbuild module: <code>modm:platform:dac</code></p> <p>This module is only available for stm32{f0,f1,f2,f3,f4,f7,g0,g4,h7,l0,l1,l4,l5,u5}.</p>"},{"location":"reference/module/modm-platform-dac-stm32-f0-f1-f2-f3-f4-f7-g0-g4-h7-l0-l1-l4-l5-u5/#dependencies","title":"Dependencies","text":"<p> modm:platform:dac modm_platform_dac modm: platform: dac modm_cmsis_device modm: cmsis: device modm_platform_dac-&gt;modm_cmsis_device </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-dma-rp2040/","title":"Direct Memory Access (DMA)","text":"<p>lbuild module: <code>modm:platform:dma</code></p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-platform-dma-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:platform:dma modm_platform_dma modm: platform: dma modm_cmsis_device modm: cmsis: device modm_platform_dma-&gt;modm_cmsis_device modm_platform_clockgen modm: platform: clockgen modm_platform_dma-&gt;modm_platform_clockgen </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-dma-same7x-s7x-v7x/","title":"Direct Memory Access (DMA)","text":"<p>lbuild module: <code>modm:platform:dma</code></p> <p>This module is only available for same7x/s7x/v7x.</p>"},{"location":"reference/module/modm-platform-dma-same7x-s7x-v7x/#dependencies","title":"Dependencies","text":"<p> modm:platform:dma modm_platform_dma modm: platform: dma modm_cmsis_device modm: cmsis: device modm_platform_dma-&gt;modm_cmsis_device modm_platform_clockgen modm: platform: clockgen modm_platform_dma-&gt;modm_platform_clockgen </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-dma-stm32-c0-f0-f1-f2-f3-f4-f7-g0-g4-h7-l0-l1-l4-l5/","title":"Direct Memory Access (DMA)","text":"<p>lbuild module: <code>modm:platform:dma</code></p> <p>This module is only available for stm32{c0,f0,f1,f2,f3,f4,f7,g0,g4,h7,l0,l1,l4,l5}.</p>"},{"location":"reference/module/modm-platform-dma-stm32-c0-f0-f1-f2-f3-f4-f7-g0-g4-h7-l0-l1-l4-l5/#dependencies","title":"Dependencies","text":"<p> modm:platform:dma modm_platform_dma modm: platform: dma modm_cmsis_device modm: cmsis: device modm_platform_dma-&gt;modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_dma-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-eth/","title":"Ethernet","text":"<p>lbuild module: <code>modm:platform:eth</code></p> <p>This module is only available for stm32{f4,f7}.</p>"},{"location":"reference/module/modm-platform-eth/#dependencies","title":"Dependencies","text":"<p> modm:platform:eth modm_platform_eth modm: platform: eth modm_architecture_assert modm: architecture: assert modm_platform_eth-&gt;modm_architecture_assert modm_architecture_delay modm: architecture: delay modm_platform_eth-&gt;modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_eth-&gt;modm_architecture_interrupt modm_architecture_register modm: architecture: register modm_platform_eth-&gt;modm_architecture_register modm_math_utils modm: math: utils modm_platform_eth-&gt;modm_math_utils modm_platform_gpio modm: platform: gpio modm_platform_eth-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_eth-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-exti/","title":"External Interrupt/Event Controller (EXTI)","text":"<p>lbuild module: <code>modm:platform:exti</code></p> <p>This driver provides an API for configuring all EXTI lines via register access. Note that you need to pass a mask, which allows you to configure multiple EXTI lines at once.</p> <p>A typical use-case is to trigger on multiple GPIO inputs:</p> <pre><code>// all trigger on both edges\nExti::setTriggers&lt;GpioA0, GpioC4, GpioD6&gt;(Exti::Trigger::BothEdges);\n// Sets the specific GPIO port per line\nExti::setTriggerSources&lt;GpioA0, GpioC4, GpioD6&gt;();\n\n// Enables EXTI4 and EXTI9_5 IRQ handlers with the same priority of 10!\nExti::enableVectors&lt;GpioC4, GpioD6&gt;(10);\n// Sets a different priority for EXTI0\nExti::enableVector&lt;GpioA0&gt;(5);\n// Enable all interrupts at the same time\nExti::enableInterrupts&lt;GpioA0, GpioC4, GpioD6&gt;();\n\n// You must manually define the IRQ handlers but *only*\n// if you disable the `with_handlers` option!\nMODM_ISR(EXTI0) { Exti::acknowledgeFlags&lt;GpioA0&gt;(); }\nMODM_ISR(EXTI4) { Exti::acknowledgeFlags&lt;GpioC4&gt;(); }\nMODM_ISR(EXTI9_5) { Exti::acknowledgeFlags&lt;GpioD6&gt;(); }\n</code></pre> <p>Note that you can also use this to configure more than just GPIO trigger sources, you can configure all other device specific EXTI lines as well. However, you need to manually configure the NVIC vector and possibly also configure the sending peripheral separately.</p> <pre><code>// Configure the RTC peripheral to send the tamper event\n// Line 21 is the RTC tamper alert on STM32F4x6\nExti::setTrigger(1ul &lt;&lt; 21, Exti::Trigger::RisingEdge);\nExti::enableInterrupts(1ul &lt;&lt; 21);\n// Manually enable the RTC_Alarm IRQ\nNVIC_SetPriority(RTC_Alarm_IRQn, 10);\nNVIC_EnableIRQ(RTC_Alarm_IRQn);\n// Different IRQ naming scheme, not EXTI_RTC!\nMODM_ISR(RTC_Alarm) {}\n</code></pre> <p>You can also trigger events instead of interrupts to facilitate WFE.</p> <pre><code>Exti::setTrigger(1ul &lt;&lt; 21, Exti::Trigger::FallingEdge);\nExti::enableEvents(1ul &lt;&lt; 21);\n</code></pre> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-platform-exti/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-exti/#with_handlers","title":"with_handlers","text":"<p>Use callbacks for GPIO lines</p> <p>To simplify the external IRQ management of external GPIO triggers, you can use the connect method to attach a <code>void(uint8_t)</code> callback to EXTI lines 0-15, which gets passed the triggered line number as an argument:</p> <pre><code>Exti::connect&lt;GpioA0&gt;(Exti::Trigger::FallingEdge,\n                      [count=uint32_t(0)](uint8_t line) mutable\n{\n    MODM_LOG_INFO &lt;&lt; \"Line \" &lt;&lt; line &lt;&lt; \" triggered \" &lt;&lt; ++count &lt;&lt; \" times!\" &lt;&lt; modm::endl;\n});\n// to disable the handler and IRQ later\nExti::disconnect&lt;GpioA0&gt;();\n</code></pre> <p>Duplicate Symbols for EXTI_IRQHandler</p> <p>This option internally defines all <code>MODM_ISR(EXTI*)</code> IRQs, so you cannot define them anymore in your application!</p> <p>The callback is implemented using <code>modm::inplace_function</code>, therefore uses no heap, but has a fixed storage size of <code>sizeof(void*)</code> by default. You can increase this storage size by defining a new global storage size <code>MODM_EXTI_HANDLER_STORAGE=bytes</code> in your <code>project.xml</code>:</p> <pre><code>&lt;library&gt;\n  &lt;collectors&gt;\n    &lt;collect name=\"modm:build:cppdefines\"&gt;MODM_EXTI_HANDLER_STORAGE=12&lt;/collect&gt;\n  &lt;/collectors&gt;\n&lt;/library&gt;\n</code></pre> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-platform-exti/#dependencies","title":"Dependencies","text":"<p> modm:platform:exti modm_platform_exti modm: platform: exti modm_cmsis_device modm: cmsis: device modm_platform_exti-&gt;modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_exti-&gt;modm_platform_gpio modm_utils modm: utils modm_platform_exti-&gt;modm_utils </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-extint-rp2040/","title":"External Interrupt Handler","text":"<p>lbuild module: <code>modm:platform:extint</code></p> <p>This driver provides an API for configuring all IRQ lines via register access.</p> <pre><code>// Powers on the LED on the low-&gt;high transition, and off on high-&gt;low.\nGpioInput0::setInput();\nIntHandler::connect&lt;GpioInput0&gt;(Gpio::InputTrigger::BothEdges,\n                                [](Gpio::InputTrigger_t triggers) {\n                                    Led::set(!!(triggers &amp; Gpio::InputTrigger::RisingEdge));\n                                });\n\n// Toggles LED each time gpio input is at the high level.\nGpioInput1::setInput(Gpio::InputType::PullDown);\nIntHandler::connect&lt;GpioInput1&gt;(Gpio::InputTrigger::HighLevel,\n                                [](Gpio::InputTrigger_t) { Led::toggle(); });\n</code></pre>"},{"location":"reference/module/modm-platform-extint-rp2040/#multicore-mode","title":"Multicore mode","text":"<p>Each core can register callbacks in the same IntHandler, but for the different pins (current implementation's constraint).</p> <p>Also, enable/disable and connect/disconnect calls affect the NVIC of the executing core only.</p>"},{"location":"reference/module/modm-platform-extint-rp2040/#callbacks","title":"Callbacks","text":"<p>The callback is implemented using <code>modm::inplace_function</code>, therefore uses no heap, but has a fixed storage size of <code>sizeof(void*)</code> by default. You can increase this storage size by defining a new global storage size <code>MODM_EXTINT_HANDLER_STORAGE=bytes</code> in your <code>project.xml</code>:</p> <pre><code>&lt;library&gt;\n  &lt;collectors&gt;\n    &lt;collect name=\"modm:build:cppdefines\"&gt;MODM_EXTINT_HANDLER_STORAGE=12&lt;/collect&gt;\n  &lt;/collectors&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"reference/module/modm-platform-extint-rp2040/#irq-types","title":"IRQ Types","text":"<p>You can explicitly enable or disable handling of the specific IRQ type in your <code>project.xml</code>:</p> <pre><code>&lt;library&gt;\n  &lt;options&gt;\n    &lt;option name=\"modm:platform:extint:gpio\"&gt;no&lt;/option&gt;\n    &lt;option name=\"modm:platform:extint:qspi\"&gt;yes&lt;/option&gt;\n  &lt;/options&gt;\n&lt;/library&gt;\n</code></pre> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-platform-extint-rp2040/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-extint-rp2040/#gpio","title":"gpio","text":"<p>Enable IRQ support for GPIO</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-platform-extint-rp2040/#qspi","title":"qspi","text":"<p>Enable IRQ support for QSPI</p> <p>Default: <code>no</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-platform-extint-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:platform:extint modm_platform_extint modm: platform: extint modm_architecture_interrupt modm: architecture: interrupt modm_platform_extint-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_extint-&gt;modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_extint-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-extint-samd1x-d2x-dax/","title":"External Interrupt","text":"<p>lbuild module: <code>modm:platform:extint</code></p> <p>This module is only available for samd1x/d2x/dax.</p>"},{"location":"reference/module/modm-platform-extint-samd1x-d2x-dax/#dependencies","title":"Dependencies","text":"<p> modm:platform:extint modm_platform_extint modm: platform: extint modm_cmsis_device modm: cmsis: device modm_platform_extint-&gt;modm_cmsis_device modm_platform_gclk modm: platform: gclk modm_platform_extint-&gt;modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_platform_extint-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-fault/","title":"ARM Cortex-M Fault Reporters","text":"<p>lbuild module: <code>modm:platform:fault</code></p> <p>This module manages data storage for core dumps provided by the <code>modm:crashcatcher</code> module to investigate HardFault events via offline post-mortem debugging. The data is stored in the volatile memory designated for the heap.</p> <p>This works as follows:</p> <ol> <li>A HardFault occurs and is intercepted by CrashCatcher.</li> <li>CrashCatcher calls into this module to store the core dump in the heap as    defined by the linkerscript's <code>.table.heap</code> section, thus effectively    overwriting the heap, then reboots the device.</li> <li>On reboot, only the remaining heap memory is initialized, leaving the core    dump data intact.</li> <li>The application has no limitations other than a reduced total heap size!    It may access the report data at any time and use all hardware to send out    this report.</li> <li>After the application clears the report and reboots, the heap will once    again be fully available.</li> </ol>"},{"location":"reference/module/modm-platform-fault/#restrictions-on-hardfault-entry","title":"Restrictions on HardFault Entry","text":"<p>A HardFault is a serious bug and should it happen your application is most likely compromised in some way. Here are some important points to take note of.</p> <ol> <li>The HardFault has a hardcoded priority of -1 and only the NMI and the Reset    exceptions have a higher priority (-2 and -3). This means ALL device interrupts    have a LOWER priority!</li> <li>The HardFault is a synchronous exception, it will NOT wait for anything to    complete, especially not the currently executing interrupt (if any).</li> <li>There are many reasons for the HardFault exception to be raised (e.g. accessing    invalid memory, executing undefined instructions, dividing by zero) making    it very difficult to recover in a generic way. It is therefore reasonable    to abandon execution (=&gt; reboot) rather than resuming execution in an    increasingly unstable application.</li> </ol> <p>On HardFault entry, this module calls the function <code>modm_hardfault_entry()</code> which can be overwritten by the application to put the devices hardware in a safe mode. This can be as simple as disabling power to external components, however, its execution should be strictly time bound and NOT depend on other interrupts completing (they won't), which will cause a deadlock.</p> <pre><code>void modm_hardfault_entry()\n{\n    Board::MotorDrivers::disable();\n    // return from this function as fast as possible\n}\n</code></pre> <p>After this function returns, this module will generate the coredump into the heap and reboot the device.</p>"},{"location":"reference/module/modm-platform-fault/#reporting-the-fault","title":"Reporting the Fault","text":"<p>In order to recover from the HardFault the device is rebooted with a smaller heap. Once the <code>main()</code> function is reached, the application code should check for <code>FaultReporter::hasReport()</code> and then only initialize the bare minimum of Hardware to send this report to the developer.</p> <p>To access the report, use the <code>FaultReporter::begin()</code> and <code>FaultReporter::end()</code> functions which return a <code>const_iterator</code> of the actual core dump data, that can be used in a range-based for loop.</p> <p>Remember to call  <code>FaultReporter::clearAndReboot()</code> to clear the report, reboot the device and reclaim the full heap.</p> <pre><code>int main()\n{\n    if (FaultReporter::hasReport()) // Check first after boot\n    {\n        Application::partialInitialize(); // Initialize only the necessary\n        reportBegin();\n        for (const uint8_t data : FaultReporter::buildId())\n            reportBuildId(data); // send each byte of Build ID\n        for (const uint8_t data : FaultReporter())\n            reportData(data); // send each byte of data\n        reportEnd(); // end the report\n        FaultReporter::clearAndReboot(); // clear the report and reboot\n        // never reached\n    }\n    // Normal initialization\n    Application::initialize();\n}\n</code></pre> <p>The application is able to use the heap, however, depending on the report size (controllable via the <code>report_level</code> option) the heap may be much smaller then normal. Make sure your application can deal with that.</p> <p>For complex applications which perhaps communicate asynchronously (CAN, Ethernet, Wireless) it may not be possible to send the report in one piece or at the same time. The report data remains available until you reboot, even after you've cleared the report.</p> <pre><code>int main()\n{\n    const bool faultReport{FaultReporter::hasReport()};\n    FaultReporter::clear(); // only clear report but do not reboot\n    Application::initialize();\n\n    while (true)\n    {\n        doOtherStuff();\n        if (faultReport and applicationReady)\n        {\n            // Still valid AFTER clear, but BEFORE reboot\n            const auto id = FaultReporter::buildId();\n            auto begin = FaultReporter::begin();\n            auto end = FaultReporter::end();\n            //\n            Application::sendReport(id, begin, end);\n            // reboot when report has been fully sent\n        }\n    }\n}\n</code></pre>"},{"location":"reference/module/modm-platform-fault/#coredump-via-gdb","title":"Coredump via GDB","text":"<p>In case you encounter a HardFault while debugging and you did not include this module or if you simply want to store the current system state for later analysis or to share with other developers, you can simply call the <code>modm_coredump</code> function inside GDB and it will generate a <code>coredump.txt</code> file. Note that this coredump file contains all volatile memories including the heap, so this method is strongly recommended if you can attach a debugger.</p> <p>Consult your chosen build system module for additional integrations.</p>"},{"location":"reference/module/modm-platform-fault/#using-the-fault-report","title":"Using the Fault Report","text":"<p>The fault report contains a core dump generated by CrashCatcher and is supposed to be used by CrashDebug to present the memory view to the GDB debugger. For this, you must use the ELF file that corresponds to the devices firmware, as well as copy the coredump data formatted as hexadecimal values into a text file, then call the debugger like this:</p> <pre><code>arm-none-eabi-gdb -tui executable.elf -ex \"set target-charset ASCII\" \\\n    -ex \"target remote | CrashDebug --elf executable.elf --dump coredump.txt\"\n</code></pre> <p>Note that the <code>FaultReporter::buildId()</code> contains the GNU Build ID, which can help you find the right ELF file:</p> <pre><code>arm-none-eabi-readelf -n executable.elf\n\nDisplaying notes found in: .build_id\n  Owner                 Data size Description\n  GNU                  0x00000014 NT_GNU_BUILD_ID (unique build ID bitstring)\n    Build ID: 59f08f7a37a7340799d9dba6b0c092bc3c9515c5\n</code></pre>"},{"location":"reference/module/modm-platform-fault/#post-mortem-debugging-with-scons","title":"Post-Mortem Debugging with SCons","text":"<p>The <code>modm:build:scons</code> module provides a few helper methods for working with fault reports. You still need to copy the coredump data manually, however, the firmware selection is automated.</p> <p>The SCons build system will automatically cache the ELF file for the build id for every firmware upload (using <code>scons artifact</code>). When a fault is reported, you can tell SCons the firmware build id and it will use the corresponding ELF file automatically.</p> <pre><code># Copy data into coredump.txt\ntouch coredump.txt\n# Start postmortem debugging of executable with this build id\nscons debug-coredump firmware=59f08f7a37a7340799d9dba6b0c092bc3c9515c5\n</code></pre> <p>This module is only available for rp, sam, stm32.</p>"},{"location":"reference/module/modm-platform-fault/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-fault/#report_level","title":"report_level","text":"<p>Fault Report Level</p> <p>This module will try to store as much data as is available in the heap and any leftover data will be discarded. This means the application may not have any heap available after a reboot.</p> <p>You can control how much data is generated by choosing the right report level:</p> <ul> <li>core: Just dumps the core registers, which describe where the fault occurred         and why. This is usually less than 250 Bytes.</li> <li>stack: Dumps the main stack memory. This will get you a full backtrace, but          may take a few kB of space.</li> <li>data: Dumps all memory sections containing static data: <code>.data</code>, <code>.fastdata</code>,         <code>.bss</code>. This allows you to see data that isn't related to your current         fault location, however, this can take several tens of kB of data.</li> </ul> <p>It is strongly recommended to choose the report level that generates less data than you heap size. The <code>scons size</code> output displays this very prominently, if the Data size is smaller than your Heap size, you're good to use the <code>core+stack+data</code> setting:</p> <pre><code>Data:      5.2 KiB (26.0% used) = 2285 B static (11.2%) + 3040 B stack (14.8%)\n(.bss + .data + .fastdata + .noinit + .stack)\n\nHeap:     14.8 KiB (74.0% available)\n(.heap1)\n</code></pre> <p>If Heap is smaller than the Data, you may need to switch to using only the <code>core+stack</code> setting:</p> <pre><code>Data:     11.2 KiB (56.0% used) = 8429 B static (41.2%) + 3040 B stack (14.8%)\n(.bss + .data + .fastdata + .noinit + .stack)\n\nHeap:      8.8 KiB (44.0% available)\n(.heap1)\n</code></pre> <p>Default: <code>core+stack+data</code> Inputs: <code>[core, core+stack, core+stack+data]</code> </p>"},{"location":"reference/module/modm-platform-fault/#dependencies","title":"Dependencies","text":"<p> modm:platform:fault modm_platform_fault modm: platform: fault modm_architecture_build_id modm: architecture: build_id modm_platform_fault-&gt;modm_architecture_build_id modm_cmsis_device modm: cmsis: device modm_platform_fault-&gt;modm_cmsis_device modm_crashcatcher modm: crashcatcher modm_platform_fault-&gt;modm_crashcatcher </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-flash/","title":"Flash Memory","text":"<p>lbuild module: <code>modm:platform:flash</code></p> <p>This module is only available for stm32{f1,f4,g0,g4}.</p>"},{"location":"reference/module/modm-platform-flash/#dependencies","title":"Dependencies","text":"<p> modm:platform:flash modm_platform_flash modm: platform: flash modm_architecture_register modm: architecture: register modm_platform_flash-&gt;modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_flash-&gt;modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_flash-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-fsmc/","title":"Flexible (Static) Memory Controller (FSMC/FMC)","text":"<p>lbuild module: <code>modm:platform:fsmc</code></p> <p>This module is only available for stm32{f1,f2,f4,l1}.</p>"},{"location":"reference/module/modm-platform-fsmc/#dependencies","title":"Dependencies","text":"<p> modm:platform:fsmc modm_platform_fsmc modm: platform: fsmc modm_cmsis_device modm: cmsis: device modm_platform_fsmc-&gt;modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_fsmc-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-gclk/","title":"Generic Clock Controller (GCLK)","text":"<p>lbuild module: <code>modm:platform:gclk</code></p> <p>This module is only available for sam{d1x/d2x/dax,d5x/e5x}.</p>"},{"location":"reference/module/modm-platform-gclk/#dependencies","title":"Dependencies","text":"<p> modm:platform:gclk modm_platform_gclk modm: platform: gclk modm_architecture_delay modm: architecture: delay modm_platform_gclk-&gt;modm_architecture_delay modm_cmsis_device modm: cmsis: device modm_platform_gclk-&gt;modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_gclk-&gt;modm_platform_clock </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-gpio-avr/","title":"General Purpose I/O (GPIO)","text":"<p>lbuild module: <code>modm:platform:gpio</code></p> <p>This module provides register access to GPIO and connect their signals to the respective peripherals in a compile-time verified way.</p> <p>Each GPIO is represented as its own class with only static methods, which implement the <code>modm::GpioIO</code> interface and provide additional platform-specific methods.</p> <pre><code>using namespace modm::platform;\n\nusing Button = GpioA0;\nButton::setInput(Gpio::InputType::PullUp);\nbool input = Button::read();\n\nusing Led = GpioInverted&lt;GpioB3&gt;; // inverts the IO logic of the pin\n\nLed::setOutput();\nLed::set(input);\n</code></pre> <p>You can also use an unordered set of GPIOs, which is useful when configuring a large number of pins, since the register accesses will be bundled and thus less code is generated.</p> <pre><code>using Set = GpioSet&lt;GpioA0, GpioB1, GpioC2, GpioD3&gt;;\nSet::setInput();\n</code></pre> <p>To write and read a set of GPIOs, you need to use an ordered implementation, which defines the pins from MSB to LSB, left-to-right. You can also check the number of ports in case your use-case requires atomic reads/writes.</p> <pre><code>using Port = SoftwareGpioPort&lt;GpioA7, GpioA2, GpioA6, GpioA0&gt;;\nstatic_assert(Port::number_of_ports == 1, \"Read/write needs to be atomic\");\nPort::setInput(Gpio::InputType::PullUp);\nuint8_t nibble = Port::read();\nPort::setOutput();\nPort::write(nibble);\n</code></pre> <p>For efficient access you can use a strictly-ordered implementation with a start pin and width. Note that you can reverse the data order with a negative width.</p> <pre><code>using Port = GpioPort&lt;GpioA0, 8&gt;;\nPort::setOutput();\nPort::write(data);\n\nusing ReversePort = GpioPort&lt;GpioB7, -8&gt;;\nReversePort::setInput();\nuint8_t data = ReversePort::read();\n</code></pre> <p>Finally, you can use an empty GPIO implementation in cases where the API requires a GPIO, but you don't need one, for example, a bit-banged SPI without MISO pin:</p> <pre><code>// write only SPI\nusing SPI = modm::platform::BitBangSpiMaster&lt;GpioA0, GpioA1, GpioUnused&gt;;\n</code></pre>"},{"location":"reference/module/modm-platform-gpio-avr/#peripheral-signals","title":"Peripheral Signals","text":"<p>To make it easier to connect pins with peripherals, this module implements a compile-time map of (pin, signal, peripheral). Note that you must provide both peripherals and signals to be unambiguous.</p> <pre><code>GpioConnector&lt;Peripheral::Uart0, GpioD0::Txd, GpioD1::Rxd&gt;::connect();\n</code></pre> <p>However, it is recommended to wrap this functionality into a separate function <code>Driver::connect&lt;Signals...&gt;(config)</code>, so that additional driver specific pin configuration can be done:</p> <pre><code>template&lt; class... Signals &gt;\nvoid Uart0::connect()\n{\n    Connector = GpioConnector&lt;Peripheral::Uart0, Signals...&gt;;\n    Connector::disconnect(); // reset to floating input\n\n    // extract pins from signals\n    using Rxd = Connector::GetSignal&lt;Gpio::Signal::Rxd&gt;;\n    using Txd = Connector::GetSignal&lt;Gpio::Signal::Txd&gt;;\n    // if not found, returns GpioUnused, you can check for this case\n    static_assert(not Connector::isValid&lt;Txd&gt;,\n                  \"This UART driver requires the Txd signal\");\n\n    // configure both pins\n    Rxd::configure(Gpio::InputType::PullUp);\n    Txd::setOutput();\n\n    // connect both pins to alternate functions\n    // This will static assert if signals do not make sense\n    Connector::connect();\n}\n// Connect these pin signals to Uart0\nUart0::connect&lt;GpioD0::Txd, GpioD1::Rxd&gt;();\n</code></pre> <p>Note that you may pass a variable number of signals to this connect function, leaving out signals you don't need and adding signals that are not required.</p> <pre><code>// Connect only one signal\nUart1::connect&lt;GpioD0::Txd&gt;();\n// Connect more signals than required\nUart1::connect&lt;GpioD0::Txd, GpioD2::Xck&gt;();\n</code></pre>"},{"location":"reference/module/modm-platform-gpio-avr/#external-interrupts","title":"External Interrupts","text":"<p>You can also configure the external interrupts, however, you must provide the interrupt yourself.</p> <pre><code>GpioD2::setInputTrigger(Gpio::InputTrigger::RisingEdge);\nGpioD2::enableExternalInterrupt();\n\nMODM_ISR(INT0)\n{\n    // your code\n    GpioD2::acknowledgeInterruptFlag();\n}\n\nGpioD2::disableExternalInterrupt();\n</code></pre> <p>When using multiple Pin-Change interrupts you need to first check the corresponding flag to determine which pin triggered the collective interrupt.</p> <pre><code>GpioB1::enablePcInterrupt();\nGpioB2::enablePcInterrupt();\n\nMODM_ISR(PCINT0)\n{\n    if (GpioB1::getPcInterruptFlag()) {\n        bool state = GpioB1::read();\n        // your code\n        GpioB1::acknowledgePcInterruptFlag();\n    }\n    if (GpioB2::getPcInterruptFlag()) {\n        bool state = GpioB2::read();\n        // your code\n        GpioB2::acknowledgePcInterruptFlag();\n    }\n}\n</code></pre> <p>This module is only available for avr.</p>"},{"location":"reference/module/modm-platform-gpio-avr/#dependencies","title":"Dependencies","text":"<p> modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio-&gt;modm_architecture_gpio modm_math_utils modm: math: utils modm_platform_gpio-&gt;modm_math_utils </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-gpio-hosted/","title":"Hosted GPIO","text":"<p>lbuild module: <code>modm:platform:gpio</code></p> <p>This module is only available for hosted.</p>"},{"location":"reference/module/modm-platform-gpio-hosted/#dependencies","title":"Dependencies","text":"<p> modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio-&gt;modm_architecture_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-gpio-rp2040/","title":"General Purpose I/O (GPIO)","text":"<p>lbuild module: <code>modm:platform:gpio</code></p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-platform-gpio-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio-&gt;modm_architecture_gpio modm_architecture_register modm: architecture: register modm_platform_gpio-&gt;modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_gpio-&gt;modm_cmsis_device modm_math_utils modm: math: utils modm_platform_gpio-&gt;modm_math_utils </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-gpio-sam/","title":"General Purpose I/O (GPIO)","text":"<p>lbuild module: <code>modm:platform:gpio</code></p> <p>This module is only available for sam.</p>"},{"location":"reference/module/modm-platform-gpio-sam/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-gpio-sam/#enable_ports","title":"enable_ports","text":"<p>Enable clock for these GPIO ports during startup</p> <p>Default: <code>{A, B, C, D, E}</code> same7x/s7x/v7x Default: <code>{A, B, C, D}</code> samd5x/e5x Default: <code>{A, B, C}</code> samd5x/e5x Default: <code>{A, B, D}</code> same7x/s7x/v7x Default: <code>{A, B}</code> sam{d1x/d2x/dax,d5x/e5x,g5x} Default: <code>{A}</code> samd1x/d2x/dax Inputs: <code>[A]</code> samd1x/d2x/dax Inputs: <code>[A, B]</code> sam{d1x/d2x/dax,d5x/e5x,g5x} Inputs: <code>[A, B, C]</code> samd5x/e5x Inputs: <code>[A, B, C, D]</code> samd5x/e5x Inputs: <code>[A, B, C, D, E]</code> same7x/s7x/v7x Inputs: <code>[A, B, D]</code> same7x/s7x/v7x </p>"},{"location":"reference/module/modm-platform-gpio-sam/#dependencies","title":"Dependencies","text":"<p> modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio-&gt;modm_architecture_gpio modm_cmsis_device modm: cmsis: device modm_platform_gpio-&gt;modm_cmsis_device modm_math_utils modm: math: utils modm_platform_gpio-&gt;modm_math_utils </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-gpio-stm32/","title":"General Purpose I/O (GPIO)","text":"<p>lbuild module: <code>modm:platform:gpio</code></p> <p>This module provides register access to GPIO and connect their signals to the respective peripherals in a compile-time verified way. This module also enables all GPIO peripheral clocks on startup by default.</p> <p>Each GPIO is represented as its own class with only static methods, which implement the <code>modm::GpioIO</code> interface and provide additional platform-specific methods.</p> <pre><code>using namespace modm::platform;\n\nusing Button = GpioA0;\nButton::setInput(Gpio::InputType::PullUp);\nbool input = Button::read();\n\nusing Led = GpioInverted&lt;GpioB3&gt;; // inverts the IO logic of the pin\n\nLed::setOutput(Gpio::OutputType::OpenDrain, Gpio::OutputSpeed::MHz2);\nLed::set(input);\n\nusing Analog = GpioC12;\nAnalog::setAnalogInput(); // Use pin for ADC/DAC/COMP\nAnalog::lock(); // this prevents changes until next reboot\n\nusing Signal = GpioD9;\nSignal::setAlternateFunction(4); // For AF id see datasheet\nSignal::setAlternateFunction(); // STM32F1 has no AF id\nSignal::disconnect(); // Switch back to floating input\n\n// Some STM32s have remappable pinouts\nGpioA11::remap(); // STM32G0: Remap A9 -&gt; A11.\n</code></pre> <p>You can also use an unordered set of GPIOs, which is useful when configuring a large number of pins, since the register accesses will be bundled and thus less code is generated.</p> <pre><code>using Set = GpioSet&lt;GpioA0, GpioB1, GpioC2, GpioD3&gt;;\nSet::setInput();\n</code></pre> <p>To write and read a set of GPIOs, you need to use an ordered implementation, which defines the pins from MSB to LSB, left-to-right. You can also check the number of ports in case your use-case requires atomic reads/writes.</p> <pre><code>using Port = SoftwareGpioPort&lt;GpioA10, GpioA2, GpioA6, GpioA14&gt;;\nstatic_assert(Port::number_of_ports == 1, \"Read/write needs to be atomic\");\nPort::setOutput(Gpio::OutputType::OpenDrain);\nPort::configure(Gpio::InputType::PullUp);\nuint8_t nibble = Port::read();\nPort::write(nibble);\n</code></pre> <p>For efficient access you can use a strictly-ordered implementation with a start pin and width. Note that you can reverse the data order with a negative width.</p> <pre><code>using Port = GpioPort&lt;GpioA0, 8&gt;;\nPort::setOutput();\nPort::write(data);\n\nusing ReversePort = GpioPort&lt;GpioB7, -8&gt;;\nReversePort::setInput();\nuint8_t data = ReversePort::read();\n</code></pre> <p>Finally, you can use an empty GPIO implementation in cases where the API requires a GPIO, but you don't need one, for example, a bit-banged SPI without MISO pin:</p> <pre><code>// write only SPI\nusing SPI = modm::platform::BitBangSpiMaster&lt;GpioA0, GpioA1, GpioUnused&gt;;\n</code></pre>"},{"location":"reference/module/modm-platform-gpio-stm32/#alternate-function-signals","title":"Alternate Function Signals","text":"<p>To make it easier to connect pins with peripherals, this module implements a compile-time map of (pin, signal, peripheral) to Alternate Function ID (AF). Note that you must provide both peripherals and signals to be unambiguous.</p> <pre><code>GpioConnector&lt;Peripheral::Usart1, GpioD0::Tx, GpioD1::Rx&gt;::connect();\n</code></pre> <p>However, it is recommended to wrap this functionality into a separate function <code>Driver::connect&lt;Signals...&gt;(config)</code>, so that additional driver specific pin configuration can be done:</p> <pre><code>template&lt; class... Signals &gt;\nvoid Uart1::connect()\n{\n    Connector = GpioConnector&lt;Peripheral::Usart1, Signals...&gt;;\n    Connector::disconnect(); // reset to floating input\n\n    // extract pins from signals\n    using Rx = Connector::GetSignal&lt;Gpio::Signal::Rx&gt;;\n    using Tx = Connector::GetSignal&lt;Gpio::Signal::Tx&gt;;\n    // if not found, returns GpioUnused, you can check for this case\n    static_assert(not Connector::isValid&lt;Tx&gt;,\n                  \"This UART driver requires the Tx signal\");\n\n    // configure both pins\n    Rx::configure(Gpio::InputType::PullUp);\n    Tx::configure(Gpio::OutputType::PushPull);\n\n    // connect both pins to alternate functions\n    // This will static assert if signals do not make sense\n    Connector::connect();\n}\n// Connect these pin signals to Usart1\nUart1::connect&lt;GpioD0::Tx, GpioD1::Rx&gt;();\n</code></pre> <p>Note that you may pass a variable number of signals to this connect function, leaving out signals you don't need and adding signals that are not required.</p> <pre><code>// Connect only one signal\nUart1::connect&lt;GpioD0::Tx&gt;();\n// Connect more signals than required\nUart1::connect&lt;GpioD0::Tx, GpioD2::Cts&gt;();\n</code></pre> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-platform-gpio-stm32/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-gpio-stm32/#enable_ports","title":"enable_ports","text":"<p>Enable clock for these GPIO ports during startup</p> <p>Default: <code>{A, B, C, D, E, F, G, H, I, J, K}</code> stm32{f4,f7,h7} Default: <code>{A, B, C, D, E, F, G, H, I, J}</code> stm32{h7,u5} Default: <code>{A, B, C, D, E, F, G, H, I}</code> stm32{f2,f4,f7,h7,l4,u5} Default: <code>{A, B, C, D, E, F, G, H}</code> stm32{f2,f3,f4,f7,h7,l1,l4,l5,u5} Default: <code>{A, B, C, D, E, F, G}</code> stm32{f1,g4} Default: <code>{A, B, C, D, E, F}</code> stm32{f0,f3,g0} Default: <code>{A, B, C, D, E, G, H}</code> stm32{l4,l5,u5} Default: <code>{A, B, C, D, E, H, I}</code> stm32{f4,u5} Default: <code>{A, B, C, D, E, H}</code> stm32{f2,f4,f7,h7,l0,l1,l4,l5,u5} Default: <code>{A, B, C, D, E}</code> stm32f1 Default: <code>{A, B, C, D, F, G}</code> stm32g4 Default: <code>{A, B, C, D, F}</code> stm32{c0,f0,f3,g0} Default: <code>{A, B, C, D, G, H}</code> stm32{l4,l5} Default: <code>{A, B, C, D, H}</code> stm32{f2,f4,f7,h7,l0,l1,l4,l5,u5} Default: <code>{A, B, C, D}</code> stm32f1 Default: <code>{A, B, C, E, H}</code> stm32u5 Default: <code>{A, B, C, F, G}</code> stm32g4 Default: <code>{A, B, C, F}</code> stm32{c0,f0,f3,g0} Default: <code>{A, B, C, G, H}</code> stm32u5 Default: <code>{A, B, C, H}</code> stm32{f4,l0,l1,l4,l5,u5} Default: <code>{A, B, C}</code> stm32{g0,l0} Default: <code>{A, B, D}</code> stm32f1 Default: <code>{A, B, F, G}</code> stm32g4 Default: <code>{A, B, F}</code> stm32{f0,f3} Default: <code>{A, F}</code> stm32f038f6p6 Inputs: <code>[A, B, C]</code> stm32{g0,l0} Inputs: <code>[A, B, C, D]</code> stm32f1 Inputs: <code>[A, B, C, D, E]</code> stm32f1 Inputs: <code>[A, B, C, D, E, F]</code> stm32{f0,f3,g0} Inputs: <code>[A, B, C, D, E, F, G]</code> stm32{f1,g4} Inputs: <code>[A, B, C, D, E, F, G, H]</code> stm32{f2,f3,f4,f7,h7,l1,l4,l5,u5} Inputs: <code>[A, B, C, D, E, F, G, H, I]</code> stm32{f2,f4,f7,h7,l4,u5} Inputs: <code>[A, B, C, D, E, F, G, H, I, J]</code> stm32{h7,u5} Inputs: <code>[A, B, C, D, E, F, G, H, I, J, K]</code> stm32{f4,f7,h7} Inputs: <code>[A, B, C, D, E, G, H]</code> stm32{l4,l5,u5} Inputs: <code>[A, B, C, D, E, H]</code> stm32{f2,f4,f7,h7,l0,l1,l4,l5,u5} Inputs: <code>[A, B, C, D, E, H, I]</code> stm32{f4,u5} Inputs: <code>[A, B, C, D, F]</code> stm32{c0,f0,f3,g0} Inputs: <code>[A, B, C, D, F, G]</code> stm32g4 Inputs: <code>[A, B, C, D, G, H]</code> stm32{l4,l5} Inputs: <code>[A, B, C, D, H]</code> stm32{f2,f4,f7,h7,l0,l1,l4,l5,u5} Inputs: <code>[A, B, C, E, H]</code> stm32u5 Inputs: <code>[A, B, C, F]</code> stm32{c0,f0,f3,g0} Inputs: <code>[A, B, C, F, G]</code> stm32g4 Inputs: <code>[A, B, C, G, H]</code> stm32u5 Inputs: <code>[A, B, C, H]</code> stm32{f4,l0,l1,l4,l5,u5} Inputs: <code>[A, B, D]</code> stm32f1 Inputs: <code>[A, B, F]</code> stm32{f0,f3} Inputs: <code>[A, B, F, G]</code> stm32g4 Inputs: <code>[A, F]</code> stm32f038f6p6 </p>"},{"location":"reference/module/modm-platform-gpio-stm32/#queries","title":"Queries","text":""},{"location":"reference/module/modm-platform-gpio-stm32/#all_signals","title":"all_signals","text":""},{"location":"reference/module/modm-platform-gpio-stm32/#dependencies","title":"Dependencies","text":"<p> modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio-&gt;modm_architecture_gpio modm_cmsis_device modm: cmsis: device modm_platform_gpio-&gt;modm_cmsis_device modm_math_utils modm: math: utils modm_platform_gpio-&gt;modm_math_utils modm_platform_rcc modm: platform: rcc modm_platform_gpio-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-heap-avr/","title":"Dynamic Memory","text":"<p>lbuild module: <code>modm:platform:heap</code></p> <p>This module is only available for avr.</p>"},{"location":"reference/module/modm-platform-heap-avr/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-heap-avr/#ram_block_length","title":"ram_block_length","text":"<p>Default: <code>16</code> Inputs: <code>[2, 4, 8, 16, 32, 64]</code> </p>"},{"location":"reference/module/modm-platform-heap-avr/#ram_length","title":"ram_length","text":"<p>Default: <code>1Ki (1024)</code> Inputs: <code>[64 .. 1Ki .. 32Ki]</code> </p>"},{"location":"reference/module/modm-platform-heap-avr/#dependencies","title":"Dependencies","text":"<p> modm:platform:heap modm_platform_heap modm: platform: heap modm_architecture_assert modm: architecture: assert modm_platform_heap-&gt;modm_architecture_assert modm_architecture_memory modm: architecture: memory modm_platform_heap-&gt;modm_architecture_memory </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/","title":"Heap Memory","text":"<p>lbuild module: <code>modm:platform:heap</code></p> <p>Your applicaton is linked against the <code>newlib-nano</code> libc, which only requires the implementation of the <code>void* sbrk(ptrdiff_t size)</code> hook to use the heap.</p> <p>However, the <code>sbrk</code> mechanism can only grow and shrink forward and backwards in memory and in particular it does not support discontinuous jumps from one memory section to another. The limitation stems from being designed for use with a MMU which would simply map another physical page into the linear virtual address space so that the heap section appears continuous to <code>sbrk</code>.</p> <p>Since we do not have a MMU on Cortex-M, this strategy limits the use of the default newlib allocator to one continuous memory region. Therefore this module implements alternative allocators for devices with multiple memory regions with different traits and extends the C++ <code>operator new</code> to access them.</p> <p>See the <code>modm:architecture:memory</code> module for what kind of memory traits exist.</p>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#heap-is-not-implemented-error","title":"Heap is not Implemented Error","text":"<p>This module is not included by default, and any attempt to use the heap fails with one or multiple linker error messages similiar to this:</p> <pre><code>`_sbrk_r' referenced in section `.text._malloc_r'\n    of libc_nano.a(lib_a-nano-mallocr.o): defined in discarded section\n      `.Heap_is_not_implemented!_\n           _Please_include_the__modm:platform:heap__module_in_your_project!'\n    of libmodm.a(no_heap.o)\n</code></pre> <p>This is to prevent you from accidentally using the heap, which may not be desirable for your application. If this occurs you have three choices. You can:</p> <ol> <li>find and remove calls to malloc/new in your application, or</li> <li>include this module with its predefined allocators, or</li> <li>implement your own allocator.</li> </ol>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#predefined-allocators","title":"Predefined Allocators","text":"<p>There are several trade-offs to each allocator, however, as a rule of thumb, choose:</p> <ul> <li><code>newlib</code> for devices with one large continuous RAM region.</li> <li><code>block</code> for devices with one very small RAM region.</li> <li><code>tlsf</code> for devices with multiple, different discontinuous RAM regions.</li> </ul> <p>Multi-SRAM regions</p> <p>For devices which contain separate memories laid out in a continuous way (often called SRAM1, SRAM2, SRAM3, etc.) the <code>newlib</code> and <code>block</code> strategies choose the largest continuous memory region, even though unaligned accesses across memory regions may not be supported in hardware and lead to a bus fault! Consider using the TLSF implementation, which does not suffer from this issue.</p> <p>Allocators are not interrupt- or thread-safe</p> <p>No locking is implemented by default, if you need this feature, consider implementing your own custom allocator algorithm!</p>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#newlib","title":"Newlib","text":"<p>The newlib-nano allocator is a simple linked list, its overhead is therefore low, but the access time may not be good. Due to the limitations of the <code>sbrk</code> mechanism only the largest memory region is used as heap! Depending on the device memory architecture this can leave large memory regions unused.</p> <p>Consider using the TLSF allocator for devices with multiple discontinuous memories.</p>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#block","title":"Block","text":"<p>For devices with very small memories, we recommend using the block allocator strategy, which uses a very light-weight and simple algorithm. This also only operates on one continuous memory region as heap.</p> <p>The Block allocator does not implement realloc!</p> <p>This is a bug in <code>modm:driver:block.allocator</code> and currently a <code>modm_assert</code> will fail.</p>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#tlsf","title":"TLSF","text":"<p>To use all non-statically allocated memory for heap, use the TLSF strategy, which natively supports multiple memory regions. This implementation treats all internal memories as separate regions, so unaligned access across memory boundaries is not an issue. To request heap memory of different traits, see the <code>modm:architecture:memory</code> module.</p> <p>TLSF has static overhead</p> <p>The TLSF implementation has a static overhead of about 1kB per memory trait group, however, these can then contain multiple discontinuous regions. The upside of this large static allocation is very fast allocation times of O(1), but we recommend using TLSF only for devices with multiple large memory regions.</p>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#custom-allocator","title":"Custom Allocator","text":"<p>To implement your own allocator do not include this module. Instead initialize your heap in the function <code>__modm_initialize_memory()</code>, which gets called by the startup script after hardware init, but before static constructors are called (see <code>modm:platform:cortex-m</code> for details).</p> <p>The simplest way to do so is to allocate a huge array into one of the heap sections and use this as your heap. Consult <code>modm:platform:core</code> for what heap sections your target provides!</p> <pre><code>modm_section(\".heap1\") // always the main heap section\nuint8_t heap_begin[10*1024]; // 10 kB heap\nconst uint8_t *const heap_end{heap_begin + sizeof(heap_begin)};\n\nextern \"C\" void __modm_initialize_memory()\n{\n    // Initialize your specific allocator algorithm here\n    allocator.initialize();\n}\n</code></pre> <p>Static constructors are only called afterwards!</p> <p>Since constructors may call the heap, it must be initialized before static constructors are called. Only trivially constructed (POD) objects are already initialized!</p>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#using-the-heaptable","title":"Using the HeapTable","text":"<p>If you prefer a little more control, include the <code>modm:architecture:memory</code> module to get access to the internal <code>modm::platform::HeapTable</code> API, which lists memory regions by traits and sizes.</p> <p>For example to find the largest continuous memory section with default traits you can use this code:</p> <pre><code>const uint8_t *heap_begin{nullptr};\nconst uint8_t *heap_end{nullptr};\nextern \"C\" void __modm_initialize_memory()\n{\n    bool success = HeapTable::find_largest(&amp;heap_begin, &amp;heap_end,\n                                           modm::MemoryDefault);\n    modm_assert(success, \"heap.init\", \"No default memory section found!\");\n}\n</code></pre> <p>If you want to know more about the available memory regions, you can iterate over the heap table directly. This gives you full control over where you want to place you heap. You can print this table at runtime to get a feel for it:</p> <pre><code>for (const auto [traits, start, end, size] : modm::platform::HeapTable())\n{\n    MODM_LOG_INFO.printf(\"Memory section %#x @[0x%p,0x%p](%u)\\n\",\n                         traits.value, start, end, size);\n}\n</code></pre>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#providing-sbrk","title":"Providing sbrk","text":"<p>To use the builtin allocator from newlib, all you need to provide is an implementation of the <code>sbrk</code> function. A simple implementation for a [<code>heap_begin</code>, <code>heap_end</code>] memory region looks like this:</p> <pre><code>const uint8_t *heap_top{heap_begin};\nextern \"C\" void* _sbrk_r(struct _reent *,  ptrdiff_t size)\n{\n    const uint8_t *const heap = heap_top;\n    heap_top += size;\n    modm_assert(heap_top &lt; heap_end, \"heap.sbrk\", \"Heap overflowed!\");\n    return (void*) heap;\n}\n</code></pre>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#providing-operator-delete","title":"Providing operator delete","text":"<p>Unfortunately virtual C++ destructors can emit a call to <code>operator delete</code> even for classes with static allocation and also in program without a single call to <code>operator new</code> or <code>malloc</code>. Therefore if this module is not included, calls to <code>operator delete</code> are ignored and you must overwrite this behavior with this function that only points to <code>free</code>.</p> <pre><code>extern \"C\" void operator_delete(void* ptr)\n{\n    free(ptr);\n}\n</code></pre>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#wrapping-malloc","title":"Wrapping malloc","text":"<p>To use a completely custom allocator, you need to replace the newlib allocator by wrapping the <code>malloc</code>, <code>calloc</code>, <code>realloc</code> and <code>free</code> functions via the linker by adding this to your project configuration:</p> <pre><code>&lt;library&gt;\n  &lt;!-- repos, modules, options, etc... --&gt;\n  &lt;collectors&gt;\n    &lt;collect name=\":build:linkflags\"&gt;-Wl,-wrap,_malloc_r&lt;/collect&gt;\n    &lt;collect name=\":build:linkflags\"&gt;-Wl,-wrap,_calloc_r&lt;/collect&gt;\n    &lt;collect name=\":build:linkflags\"&gt;-Wl,-wrap,_realloc_r&lt;/collect&gt;\n    &lt;collect name=\":build:linkflags\"&gt;-Wl,-wrap,_free_r&lt;/collect&gt;\n  &lt;/collectors&gt;\n&lt;/library&gt;\n</code></pre> <p>And then implement the following functions with your custom allocator:</p> <pre><code>extern \"C\" void *\n__wrap__malloc_r(struct _reent *, size_t size)\n{\n    return allocator.malloc(size);\n}\nextern \"C\" void *\n__wrap__calloc_r(struct _reent *, size_t size)\n{\n    return allocator.calloc(size);\n}\nextern \"C\" void *\n__wrap__realloc_r(struct _reent *, void *ptr, size_t size)\n{\n    return allocator.realloc(ptr, size);\n}\nextern \"C\" void \n__wrap__free_r(struct _reent *, void *p)\n{\n    allocator.free(p);\n}\n</code></pre> <p>This is particularly recommended if you need a thread-safe malloc, which you implement here via the <code>_reent</code> struct. Consult newlib docs for details.</p> <p>sbrk is not called anymore</p> <p>When wrapping these malloc functions, <code>_sbrk_r</code> is not called anymore, and therefore is thrown away by the linker, thus the linker error disappears. You therefore do not need to implement it, not even as a stub.</p> <p>To also support memory traits, you need to overwrite the default implementation of <code>malloc_traits(size, traits)</code> which would otherwise just ignore the traits:</p> <pre><code>extern \"C\" void *\nmalloc_traits(size_t size, uint32_t ctraits)\n{\n    // Convert back from C land to C++ land:\n    const modm::MemoryTraits traits{ctraits};\n    if (traits &amp; modm::MemoryTrait::AccessDMA) {\n        // check for space in DMA-able heap regions\n    } else {\n        // check other regions\n    }\n    return ptr;\n}\n</code></pre> <p>This module is only available for rp, sam, stm32.</p>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#allocator","title":"allocator","text":"<p>Heap allocator algorithms</p> <p>Default: <code>block</code> samd1x/d2x/dax, stm32{f0,f1,l0,l1} Default: <code>newlib</code> rp, sam{d1x/d2x/dax,e7x/s7x/v7x,g5x}, stm32{c0,f0,f1,f2,f3,f4,f7,g0,g4,l0,l1,l4,l5} Default: <code>tlsf</code> samd5x/e5x, stm32{h7,u5} Inputs: <code>[block, newlib, tlsf]</code> Input Dependency: <code>block -&gt; modm:driver:block.allocator</code> Input Dependency: <code>tlsf -&gt; modm:tlsf</code> </p>"},{"location":"reference/module/modm-platform-heap-rp--sam--stm32/#dependencies","title":"Dependencies","text":"<p> modm:platform:heap modm_platform_heap modm: platform: heap modm_architecture_assert modm: architecture: assert modm_platform_heap-&gt;modm_architecture_assert modm_architecture_memory modm: architecture: memory modm_platform_heap-&gt;modm_architecture_memory modm_driver_block_allocator modm: driver: block.allocator modm_platform_heap-&gt;modm_driver_block_allocator modm_tlsf modm: tlsf modm_platform_heap-&gt;modm_tlsf </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-i2c-avr/","title":"Inter-Integrated Circuit (I\u00b2C)","text":"<p>lbuild module: <code>modm:platform:i2c</code></p> <p>This module is only available for avr.</p>"},{"location":"reference/module/modm-platform-i2c-avr/#dependencies","title":"Dependencies","text":"<p> modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c-&gt;modm_architecture_accessor modm_architecture_i2c modm: architecture: i2c modm_platform_i2c-&gt;modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c-&gt;modm_architecture_interrupt modm_platform_gpio modm: platform: gpio modm_platform_i2c-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-i2c-bitbang/","title":"Software Inter-Integrated Circuit (I\u00b2C)","text":"<p>lbuild module: <code>modm:platform:i2c.bitbang</code></p>"},{"location":"reference/module/modm-platform-i2c-bitbang/#dependencies","title":"Dependencies","text":"<p> modm:platform:i2c.bitbang modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_architecture_delay modm: architecture: delay modm_platform_i2c_bitbang-&gt;modm_architecture_delay modm_architecture_fiber modm: architecture: fiber modm_platform_i2c_bitbang-&gt;modm_architecture_fiber modm_architecture_gpio modm: architecture: gpio modm_platform_i2c_bitbang-&gt;modm_architecture_gpio modm_architecture_i2c modm: architecture: i2c modm_platform_i2c_bitbang-&gt;modm_architecture_i2c modm_platform_gpio modm: platform: gpio modm_platform_i2c_bitbang-&gt;modm_platform_gpio </p>"},{"location":"reference/module/modm-platform-i2c-rp2040/","title":"Inter-Integrated Circuit (I\u00b2C)","text":"<p>lbuild module: <code>modm:platform:i2c</code></p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-platform-i2c-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_i2c modm: architecture: i2c modm_platform_i2c-&gt;modm_architecture_i2c modm_cmsis_device modm: cmsis: device modm_platform_i2c-&gt;modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_i2c-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-i2c-same7x-s7x-v7x/","title":"Inter-Integrated Circuit (I\u00b2C)","text":"<p>lbuild module: <code>modm:platform:i2c</code></p> <p>This module is only available for same7x/s7x/v7x.</p>"},{"location":"reference/module/modm-platform-i2c-same7x-s7x-v7x/#dependencies","title":"Dependencies","text":"<p> modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c-&gt;modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_platform_i2c-&gt;modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_i2c-&gt;modm_architecture_clock modm_architecture_i2c modm: architecture: i2c modm_platform_i2c-&gt;modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_i2c-&gt;modm_cmsis_device modm_container modm: container modm_platform_i2c-&gt;modm_container modm_platform_gpio modm: platform: gpio modm_platform_i2c-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-i2c-stm32-c0-f0-f3-f7-g0-g4-h7-l0-l4-l5-u5/","title":"Inter-Integrated Circuit (I\u00b2C)","text":"<p>lbuild module: <code>modm:platform:i2c</code></p> <p>This module is only available for stm32{c0,f0,f3,f7,g0,g4,h7,l0,l4,l5,u5}.</p>"},{"location":"reference/module/modm-platform-i2c-stm32-c0-f0-f3-f7-g0-g4-h7-l0-l4-l5-u5/#dependencies","title":"Dependencies","text":"<p> modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c-&gt;modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_platform_i2c-&gt;modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_i2c-&gt;modm_architecture_clock modm_architecture_i2c modm: architecture: i2c modm_platform_i2c-&gt;modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_i2c-&gt;modm_cmsis_device modm_container modm: container modm_platform_i2c-&gt;modm_container modm_platform_gpio modm: platform: gpio modm_platform_i2c-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-i2c-stm32-f1-f2-f4-l1/","title":"Inter-Integrated Circuit (I\u00b2C)","text":"<p>lbuild module: <code>modm:platform:i2c</code></p> <p>This module is only available for stm32{f1,f2,f4,l1}.</p>"},{"location":"reference/module/modm-platform-i2c-stm32-f1-f2-f4-l1/#dependencies","title":"Dependencies","text":"<p> modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c-&gt;modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_platform_i2c-&gt;modm_architecture_atomic modm_architecture_i2c modm: architecture: i2c modm_platform_i2c-&gt;modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_i2c-&gt;modm_cmsis_device modm_container modm: container modm_platform_i2c-&gt;modm_container modm_math_algorithm modm: math: algorithm modm_platform_i2c-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_i2c-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-id/","title":"Unique ID","text":"<p>lbuild module: <code>modm:platform:id</code></p> <p>This module is only available for stm32.</p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-itm/","title":"Instrumentation Trace Macrocell (ITM)","text":"<p>lbuild module: <code>modm:platform:itm</code></p> <p>This module provides the ITM port 0 as a (buffered) Uart interface. You can use this class as a transmit-only alternative for logging:</p> <pre><code>modm::IODeviceWrapper&lt;modm::platform::Itm,\n                      modm::IOBuffer::DiscardIfFull&gt; itm_device;\nmodm::IOStream stream(itm_device);\n\nmodm::platform::Itm::initialize();\nstream &lt;&lt; \"Hello World\" &lt;&lt; modm::endl;\n</code></pre>"},{"location":"reference/module/modm-platform-itm/#caveats","title":"Caveats","text":"<p>The ITM is part of the ARM Cortex-M debug functionality and forwards its data to the Trace Port Interface Unit (TPIU) which outputs over the trace pins. Only the SWO trace pin is currently supported (asynchronous tracing).</p> <p>The ITM is not a UART replacement!</p> <p>The TPIU only outputs data when a debugger is attached to the target!</p> <p>The <code>Itm</code> class will safely discard any data if a debugger is not attached, so you can use it for debugging without running the risk of a deadlock.</p> <p>The ITM requires polling!</p> <p>The hardware does not generate a \"buffer empty\" interrupt, so the buffered implementation requires you to call the <code>update()</code> function!</p> <p>By default the <code>Itm</code> class is non-buffered and therefore blocking. You must set the <code>modm:platform:itm:buffer.tx</code> option to non-zero to use the buffered version!</p>"},{"location":"reference/module/modm-platform-itm/#receiving-data","title":"Receiving Data","text":"<p>You must use OpenOCD to configure your target's hardware, as well as capture the asynchronous trace stream.</p> <p>Is the SWO pin connected to your debugger?</p> <p>Check if your debugger supports trace output and if the SWO pin is actually connected to it on your development board!</p> <p>To log the output to a file called <code>itm.fifo</code> you can call the <code>modm_log_itm</code> command manually.</p> <pre><code>openocd -f modm/openocd.cfg -c \"modm_log_itm itm.fifo 64000000\"\n</code></pre> <p>You can then either use <code>tail -f itm.fifo</code> to display the raw data stream (which is often enough) or use the <code>itmdump</code> program for an advanced use-case (like de-multiplexing data streams).</p> <p>OpenOCD requires the CPU/HCLK frequency</p> <p>You must provide the CPU/HCLK frequency of your target, so that OpenOCD can correctly set the prescaler for the asynchronous SWO output.</p> <p>When using the <code>modm:build:scons</code> or <code>modm:build:make</code> modules, you can also use the convenience wrapper, which logs to a temporary file and displays its contents on the terminal:</p> <pre><code> $ scons log-itm fcpu=64000000\n\u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500&gt; Single Wire Viewer\n\u2570\u2500\u2500\u2500\u2500\u2500SWO\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt\nHello from the SWO.\ndebug\ninfo\nwarning\nerror\nloop 0\nloop 1\nloop 2\nloop 3\nloop 4\nloop 5\n</code></pre> <p>Alternatively you can also use a JLink debug probe which auto-detects the CPU frequency:</p> <pre><code>  $ scons log-itm-jlink\n\u256d\u2500\u2500\u2500\u2500JLink\u2500\u2500\u2500\u2500&gt; Single Wire Viewer\n\u2570\u2500\u2500\u2500\u2500\u2500SWO\u2500\u2500\u2500\u2500\u2500\u2500 stm32l476rgt6\n\nTarget CPU (stm32l476rg) is running @ 48251 kHz.\nReceiving SWO data @ 4500 kHz.\nShowing data from stimulus port(s): 0\n-----------------------------------------------\nHello from the SWO.\ndebug\ninfo\nwarning\nerror\nloop 0\nloop 1\nloop 2\nloop 3\nloop 4\nloop 5\n</code></pre> <p>This module is only available for sam{d5x/e5x,e7x/s7x/v7x,g5x}, stm32{f1,f2,f3,f4,f7,g4,h7,l1,l4,l5,u5}.</p>"},{"location":"reference/module/modm-platform-itm/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-itm/#buffertx","title":"buffer.tx","text":"<p>Transmit buffer size</p> <p>You must call the <code>update()</code> function repeatedly when a transmit buffer is used, otherwise you have to call <code>flushWriteBuffer()</code> to empty the buffer.</p> <p>Default: <code>0</code> Inputs: <code>[0 ... 64Ki-2]</code> </p>"},{"location":"reference/module/modm-platform-itm/#dependencies","title":"Dependencies","text":"<p> modm:platform:itm modm_platform_itm modm: platform: itm modm_architecture_fiber modm: architecture: fiber modm_platform_itm-&gt;modm_architecture_fiber modm_architecture_uart modm: architecture: uart modm_platform_itm-&gt;modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_itm-&gt;modm_cmsis_device </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-iwdg/","title":"Independent watchdog","text":"<p>lbuild module: <code>modm:platform:iwdg</code></p> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-platform-iwdg/#dependencies","title":"Dependencies","text":"<p> modm:platform:iwdg modm_platform_iwdg modm: platform: iwdg modm_cmsis_device modm: cmsis: device modm_platform_iwdg-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_iwdg-&gt;modm_math_algorithm </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-multicore/","title":"RP2040 multi-core module","text":"<p>lbuild module: <code>modm:platform:multicore</code></p> <p>This module adds the ability to run code on CPU1 and provides mailbox, spinlock and mutex implementations, and additionally a stack of size <code>modm:platform:cortex-m:main_stack_size</code> is added to the CORE1 memory and the <code>modm::atomic::Lock</code> is made multicore safe. You can use attributes for placing objects into core-coupled memories:</p> <pre><code>modm_core0_data uint8_t data = 0xab;\nmodm_core1_bss uint16_t zero;\nmodm_core0_noinit uint32_t uninitialized;\n\nmodm_core1_code\nvoid function()\n{\n    data = 0xcd;\n    zero = 100;\n    uninitialized = 200;\n}\n</code></pre> <p>We provide a symmetric multiprocessing (SMP) abstraction, where the same binary is used for both cores. By default CPU0 is used to boot the device and code running on CPU1 needs to be explicitly started:</p> <pre><code>void function()\n{\n    uint8_t cpuid = Core::cpuId();\n}\nfunction(); // cpuid == 0\nmulticore::Core1::run(function); // cpuid == 1\n// Before CPU1 executes code, this function is called\n// so that you can customize the CPU1 environment\nextern \"C\" void modm_initialize_core1()\n{\n    // set a custom vector table for CPU1\n    SCB-&gt;VTOR = custom_vector_table;\n}\n</code></pre> <p>This module is only available for rp2040.</p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-pwm/","title":"PWM Generator","text":"<p>lbuild module: <code>modm:platform:pwm</code></p> <p>This module is only available for same7x/s7x/v7x.</p>"},{"location":"reference/module/modm-platform-pwm/#dependencies","title":"Dependencies","text":"<p> modm:platform:pwm modm_platform_pwm modm: platform: pwm modm_cmsis_device modm: cmsis: device modm_platform_pwm-&gt;modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_pwm-&gt;modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_pwm-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-random/","title":"Random Number Generator (RNG)","text":"<p>lbuild module: <code>modm:platform:random</code></p> <p>This module is only available for stm32{f2,f4,f7,g0,g4,h7,l0,l4,l5,u5}.</p>"},{"location":"reference/module/modm-platform-random/#dependencies","title":"Dependencies","text":"<p> modm:platform:random modm_platform_random modm: platform: random modm_cmsis_device modm: cmsis: device modm_platform_random-&gt;modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_random-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-rcc/","title":"Reset and Clock Control (RCC)","text":"<p>lbuild module: <code>modm:platform:rcc</code></p> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-platform-rcc/#dependencies","title":"Dependencies","text":"<p> modm:platform:rcc modm_platform_rcc modm: platform: rcc modm_architecture_delay modm: architecture: delay modm_platform_rcc-&gt;modm_architecture_delay modm_cmsis_device modm: cmsis: device modm_platform_rcc-&gt;modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_rcc-&gt;modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_rcc-&gt;modm_platform_gpio modm_utils modm: utils modm_platform_rcc-&gt;modm_utils </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-rtc/","title":"Real Time Clock (RTC)","text":"<p>lbuild module: <code>modm:platform:rtc</code></p> <p>The STM32 RTC implements a full calendar in hardware to provide a date and time in binary-coded decimal (BCD) format. Several optimized methods are provided to provide an efficient conversion from this hardware format to a software representation.</p> <p>The epoch of the RTC is chosen to be the 1<sup>st</sup> of January 1970 to be compatible with UNIX timestamps. Since the year is limited to two BCD digits, the RTC will roll over in 2070.</p> <p>Note that the RTC hardware has no support for time zones, so you have to handle that in software.</p>"},{"location":"reference/module/modm-platform-rtc/#initialization","title":"Initialization","text":"<p>The RTC keeps running during a reset of the microcontroller when the backup domain is powered. To prevent clock drift, the <code>initialize()</code> function will check if the RTC is already running and only initialize the prescaler differs from the programmed one. If the return value is <code>false</code> the RTC was already initialized and running:</p> <pre><code>struct SystemClock\n{\n    static constexpr uint32_t Rtc = 32'768;\n};\nconst bool inited = Rtc::initialize&lt;SystemClock&gt;();\nif (not inited) { /* RTC was already running from before reset */ }\n</code></pre> <p>To always initialize the RTC, set the <code>forced</code> argument to <code>true</code>:</p> <pre><code>Rtc::initialize&lt;SystemClock&gt;(true);\n</code></pre> <p>To give the RTC an initial date and time, use the <code>setDateTime()</code> function. You can use the compile time as a basic reference time, and only set the time forward to not reset the time on every reset:</p> <pre><code>constexpr auto cdt = modm::DateTime::fromBuildTime();\nif (Rtc::dateTime() &lt; cdt) Rtc::setDateTime(cdt);\n</code></pre>"},{"location":"reference/module/modm-platform-rtc/#accessing-date-and-time","title":"Accessing Date and Time","text":"<p>The RTC hardware provides the date and time in BCD format which can be atomically read out with the <code>dateTime()</code> function, which returns a <code>DateTime</code> object that can be used to access the individual date and time components:</p> <pre><code>const auto dt = Rtc::dateTime();\ndt.year_month_day();\ndt.day_of_year();\ndt.weekday();\n\ndt.hours();\ndt.minutes();\ndt.seconds();\ndt.subseconds();\n\n// prints ISO encoding: 2024-12-22 18:39:21.342\nMODM_LOG_INFO &lt;&lt; dt &lt;&lt; modm::endl;\n\n// Efficient conversion to std::tm\nconst std::tm tm = dt.tm();\n</code></pre> <p>Please note that while the <code>DateTime</code> object provides methods to compute to seconds and milliseconds since epoch, these are slow and should be avoided. Instead, use the <code>Rtc::now()</code>, <code>Rtc::time_t()</code> and <code>Rtc::timeval()</code> functions to access optimized and cached conversion methods which are much faster:</p> <pre><code>const Rtc::time_point tp = Rtc::now();\n// instead of Rtc::dateTime().time_since_epoch();\nconst std::time_t tt = Rtc::time_t();\n// instead of Rtc::dateTime().time_t();\nconst struct timeval tv = Rtc::timeval();\n// instead of Rtc::dateTime().timeval();\n</code></pre> <p>This module is only available for stm32{c0,f0,f2,f3,f4,f7,g0,g4,h7,l0,l1,l4,l5,u5}.</p>"},{"location":"reference/module/modm-platform-rtc/#dependencies","title":"Dependencies","text":"<p> modm:platform:rtc modm_platform_rtc modm: platform: rtc modm_architecture_fiber modm: architecture: fiber modm_platform_rtc-&gt;modm_architecture_fiber modm_cmsis_device modm: cmsis: device modm_platform_rtc-&gt;modm_cmsis_device modm_math_calendar modm: math: calendar modm_platform_rtc-&gt;modm_math_calendar modm_platform_rcc modm: platform: rcc modm_platform_rtc-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-rtt/","title":"UART over RTT","text":"<p>lbuild module: <code>modm:platform:rtt</code></p> <p>The RTT channels are exposed as a UART interface which you can use like so:</p> <pre><code>// Access data via static methods\nusing Rtt = modm::platform::Rtt&lt;0&gt;;\n// Create a software loopback\nif (uint8_t data; Rtt::read(data)) { Rtt::write(data); }\n\n// Wrap into an IOStream\nmodm::IODeviceWrapper&lt;Rtt, modm::IOBuffer::BlockIfFull&gt; rtt_device;\nmodm::IOStream stream(rtt_device);\n// Writing data\nstream &lt;&lt; \"Hello World\" &lt;&lt; modm::endl;\n\n// Reading data from an IOStream\nif (char data; stream.get(data), data != modm::IOStream::eof)\n{ /* process new data */ }\n</code></pre> <p>To configure the number and size of RTT channels, see the <code>modm:rtt</code> module.</p> <p>This module is only available for rp, sam, stm32.</p>"},{"location":"reference/module/modm-platform-rtt/#dependencies","title":"Dependencies","text":"<p> modm:platform:rtt modm_platform_rtt modm: platform: rtt modm_architecture_fiber modm: architecture: fiber modm_platform_rtt-&gt;modm_architecture_fiber modm_architecture_uart modm: architecture: uart modm_platform_rtt-&gt;modm_architecture_uart modm_rtt modm: rtt modm_platform_rtt-&gt;modm_rtt </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-socketcan/","title":"SocketCAN","text":"<p>lbuild module: <code>modm:platform:socketcan</code></p> <p>This module is only available for hostedlinux.</p>"},{"location":"reference/module/modm-platform-socketcan/#dependencies","title":"Dependencies","text":"<p> modm:platform:socketcan modm_platform_socketcan modm: platform: socketcan modm_architecture_can modm: architecture: can modm_platform_socketcan-&gt;modm_architecture_can modm_debug modm: debug modm_platform_socketcan-&gt;modm_debug </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-spi-avr/","title":"Serial Peripheral Interface (SPI)","text":"<p>lbuild module: <code>modm:platform:spi</code></p> <p>This module is only available for avr.</p>"},{"location":"reference/module/modm-platform-spi-avr/#dependencies","title":"Dependencies","text":"<p> modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_atomic modm: architecture: atomic modm_platform_spi-&gt;modm_architecture_atomic modm_architecture_fiber modm: architecture: fiber modm_platform_spi-&gt;modm_architecture_fiber modm_architecture_spi modm: architecture: spi modm_platform_spi-&gt;modm_architecture_spi modm_math_algorithm modm: math: algorithm modm_platform_spi-&gt;modm_math_algorithm modm_math_utils modm: math: utils modm_platform_spi-&gt;modm_math_utils modm_platform_gpio modm: platform: gpio modm_platform_spi-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-spi-bitbang/","title":"Software Serial Peripheral Interface (SPI)","text":"<p>lbuild module: <code>modm:platform:spi.bitbang</code></p>"},{"location":"reference/module/modm-platform-spi-bitbang/#dependencies","title":"Dependencies","text":"<p> modm:platform:spi.bitbang modm_platform_spi_bitbang modm: platform: spi.bitbang modm_architecture_delay modm: architecture: delay modm_platform_spi_bitbang-&gt;modm_architecture_delay modm_architecture_fiber modm: architecture: fiber modm_platform_spi_bitbang-&gt;modm_architecture_fiber modm_architecture_spi modm: architecture: spi modm_platform_spi_bitbang-&gt;modm_architecture_spi modm_platform_gpio modm: platform: gpio modm_platform_spi_bitbang-&gt;modm_platform_gpio </p>"},{"location":"reference/module/modm-platform-spi-rp2040/","title":"Serial Peripheral Interface (SPI)","text":"<p>lbuild module: <code>modm:platform:spi</code></p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-platform-spi-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_assert modm: architecture: assert modm_platform_spi-&gt;modm_architecture_assert modm_architecture_fiber modm: architecture: fiber modm_platform_spi-&gt;modm_architecture_fiber modm_architecture_spi modm: architecture: spi modm_platform_spi-&gt;modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_spi-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_spi-&gt;modm_math_algorithm modm_platform_clockgen modm: platform: clockgen modm_platform_spi-&gt;modm_platform_clockgen modm_platform_gpio modm: platform: gpio modm_platform_spi-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-spi-same7x-s7x-v7x/","title":"Serial Peripheral Interface (SPI)","text":"<p>lbuild module: <code>modm:platform:spi</code></p> <p>This module is only available for same7x/s7x/v7x.</p>"},{"location":"reference/module/modm-platform-spi-same7x-s7x-v7x/#dependencies","title":"Dependencies","text":"<p> modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_fiber modm: architecture: fiber modm_platform_spi-&gt;modm_architecture_fiber modm_architecture_register modm: architecture: register modm_platform_spi-&gt;modm_architecture_register modm_architecture_spi modm: architecture: spi modm_platform_spi-&gt;modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_spi-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_spi-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_spi-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-spi-samg5x/","title":"Serial Peripheral Interface (SPI)","text":"<p>lbuild module: <code>modm:platform:spi</code></p> <p>This module is only available for samg5x.</p>"},{"location":"reference/module/modm-platform-spi-samg5x/#dependencies","title":"Dependencies","text":"<p> modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_register modm: architecture: register modm_platform_spi-&gt;modm_architecture_register modm_architecture_spi modm: architecture: spi modm_platform_spi-&gt;modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_spi-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_spi-&gt;modm_math_algorithm modm_platform_clockgen modm: platform: clockgen modm_platform_spi-&gt;modm_platform_clockgen modm_platform_gpio modm: platform: gpio modm_platform_spi-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-spi-stm32-c0-f0-f1-f2-f3-f4-f7-g0-g4-l0-l1-l4-l5/","title":"Serial Peripheral Interface (SPI)","text":"<p>lbuild module: <code>modm:platform:spi</code></p> <p>This module is only available for stm32{c0,f0,f1,f2,f3,f4,f7,g0,g4,l0,l1,l4,l5}.</p>"},{"location":"reference/module/modm-platform-spi-stm32-c0-f0-f1-f2-f3-f4-f7-g0-g4-l0-l1-l4-l5/#dependencies","title":"Dependencies","text":"<p> modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_fiber modm: architecture: fiber modm_platform_spi-&gt;modm_architecture_fiber modm_architecture_register modm: architecture: register modm_platform_spi-&gt;modm_architecture_register modm_architecture_spi modm: architecture: spi modm_platform_spi-&gt;modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_spi-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_spi-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_spi-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_spi-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-spi-stm32h7/","title":"Serial Peripheral Interface (SPI)","text":"<p>lbuild module: <code>modm:platform:spi</code></p> <p>This module is only available for stm32h7.</p>"},{"location":"reference/module/modm-platform-spi-stm32h7/#dependencies","title":"Dependencies","text":"<p> modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_fiber modm: architecture: fiber modm_platform_spi-&gt;modm_architecture_fiber modm_architecture_register modm: architecture: register modm_platform_spi-&gt;modm_architecture_register modm_architecture_spi modm: architecture: spi modm_platform_spi-&gt;modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_spi-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_spi-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_spi-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_spi-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-timer-sam-e7x-s7x-v7x-g5x/","title":"Timers (TC)","text":"<p>lbuild module: <code>modm:platform:timer</code></p> <p>This module is only available for sam{e7x/s7x/v7x,g5x}.</p>"},{"location":"reference/module/modm-platform-timer-sam-e7x-s7x-v7x-g5x/#dependencies","title":"Dependencies","text":"<p> modm:platform:timer modm_platform_timer modm: platform: timer modm_cmsis_device modm: cmsis: device modm_platform_timer-&gt;modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_timer-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-timer-stm32/","title":"Timers (TIM)","text":"<p>lbuild module: <code>modm:platform:timer</code></p> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-platform-timer-stm32/#dependencies","title":"Dependencies","text":"<p> modm:platform:timer modm_platform_timer modm: platform: timer modm_architecture_register modm: architecture: register modm_platform_timer-&gt;modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_timer-&gt;modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_timer-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_timer-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-uart-avr-90-mega/","title":"Universal Asynchronous Receiver Transmitter (UART)","text":"<p>lbuild module: <code>modm:platform:uart</code></p> <p>This module is only available for avr{90,mega}.</p>"},{"location":"reference/module/modm-platform-uart-avr-90-mega/#options","title":"Options","text":""},{"location":"reference/module/modm-platform-uart-avr-90-mega/#bufferrx","title":"buffer.rx","text":"<p>This option is only available for avrmega.</p> <p>Default: <code>8</code> Inputs: <code>[1 .. 8 .. 254]</code> </p>"},{"location":"reference/module/modm-platform-uart-avr-90-mega/#buffertx","title":"buffer.tx","text":"<p>This option is only available for avrmega.</p> <p>Default: <code>64</code> Inputs: <code>[1 .. 64 .. 254]</code> </p>"},{"location":"reference/module/modm-platform-uart-avr-90-mega/#dependencies","title":"Dependencies","text":"<p> modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_atomic modm: architecture: atomic modm_platform_uart-&gt;modm_architecture_atomic modm_architecture_fiber modm: architecture: fiber modm_platform_uart-&gt;modm_architecture_fiber modm_architecture_interrupt modm: architecture: interrupt modm_platform_uart-&gt;modm_architecture_interrupt modm_architecture_uart modm: architecture: uart modm_platform_uart-&gt;modm_architecture_uart modm_math_algorithm modm: math: algorithm modm_platform_uart-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_uart-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-uart-hosted-darwin-linux/","title":"UART and Serial","text":"<p>lbuild module: <code>modm:platform:uart</code></p> <p>This module is only available for hosted{darwin,linux}.</p>"},{"location":"reference/module/modm-platform-uart-hosted-darwin-linux/#dependencies","title":"Dependencies","text":"<p> modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_uart modm: architecture: uart modm_platform_uart-&gt;modm_architecture_uart modm_debug modm: debug modm_platform_uart-&gt;modm_debug modm_io modm: io modm_platform_uart-&gt;modm_io </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-uart-lpuart1/","title":"Instance 1","text":"<p>lbuild module: <code>modm:platform:uart:lpuart1</code></p> <p>This module is only available for stm32{g0,g4,h7,l0,l4,l5,u5}.</p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-uart-lpuart2/","title":"Instance 2","text":"<p>lbuild module: <code>modm:platform:uart:lpuart2</code></p> <p>This module is only available for stm32g0.</p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-uart-rp2040/","title":"Universal Asynchronous Receiver Transmitter (UART)","text":"<p>lbuild module: <code>modm:platform:uart</code></p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-platform-uart-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_fiber modm: architecture: fiber modm_platform_uart-&gt;modm_architecture_fiber modm_architecture_interrupt modm: architecture: interrupt modm_platform_uart-&gt;modm_architecture_interrupt modm_architecture_uart modm: architecture: uart modm_platform_uart-&gt;modm_architecture_uart modm_math_algorithm modm: math: algorithm modm_platform_uart-&gt;modm_math_algorithm modm_platform_clockgen modm: platform: clockgen modm_platform_uart-&gt;modm_platform_clockgen modm_platform_gpio modm: platform: gpio modm_platform_uart-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-uart-sam-d1x-d2x-dax-d5x-e5x/","title":"Universal Asynchronous Receiver Transmitter (UART)","text":"<p>lbuild module: <code>modm:platform:uart</code></p> <p>This module is only available for sam{d1x/d2x/dax,d5x/e5x}.</p>"},{"location":"reference/module/modm-platform-uart-sam-d1x-d2x-dax-d5x-e5x/#dependencies","title":"Dependencies","text":"<p> modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_fiber modm: architecture: fiber modm_platform_uart-&gt;modm_architecture_fiber modm_architecture_uart modm: architecture: uart modm_platform_uart-&gt;modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_uart-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_uart-&gt;modm_math_algorithm modm_platform_gclk modm: platform: gclk modm_platform_uart-&gt;modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_platform_uart-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-uart-same7x-s7x-v7x/","title":"Universal Asynchronous Receiver Transmitter (UART)","text":"<p>lbuild module: <code>modm:platform:uart</code></p> <p>This module is only available for same7x/s7x/v7x.</p>"},{"location":"reference/module/modm-platform-uart-same7x-s7x-v7x/#dependencies","title":"Dependencies","text":"<p> modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_fiber modm: architecture: fiber modm_platform_uart-&gt;modm_architecture_fiber modm_architecture_uart modm: architecture: uart modm_platform_uart-&gt;modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_uart-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_uart-&gt;modm_math_algorithm modm_platform_clockgen modm: platform: clockgen modm_platform_uart-&gt;modm_platform_clockgen modm_platform_gpio modm: platform: gpio modm_platform_uart-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-uart-spi/","title":"USART in SPI Mode","text":"<p>lbuild module: <code>modm:platform:uart.spi</code></p> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-platform-uart-spi/#dependencies","title":"Dependencies","text":"<p> modm:platform:uart.spi modm_platform_uart_spi modm: platform: uart.spi modm_architecture_fiber modm: architecture: fiber modm_platform_uart_spi-&gt;modm_architecture_fiber modm_architecture_spi modm: architecture: spi modm_platform_uart_spi-&gt;modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_uart_spi-&gt;modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_uart_spi-&gt;modm_platform_gpio modm_platform_uart modm: platform: uart modm_platform_uart_spi-&gt;modm_platform_uart </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-uart-stm32/","title":"Universal Asynchronous Receiver Transmitter (UART)","text":"<p>lbuild module: <code>modm:platform:uart</code></p> <p>The UART buffer configuration is implemented as C++ template arguments:</p> <pre><code>using namespace modm::platform;\n// Using only hardware buffers for Tx and Rx (both 1 symbol)\nusing UartN = BufferedUart&lt;U(s)artHalN&gt;;\n// using only TX software buffer\nusing UartN = BufferedUart&lt;U(s)artHalN, UartTxBuffer&lt;512&gt;&gt;;\n// using only RX software buffer\nusing UartN = BufferedUart&lt;U(s)artHalN, UartRxBuffer&lt;256&gt;&gt;;\n// using both TX and RX software buffers\nusing UartN = BufferedUart&lt;U(s)artHalN, UartTxBuffer&lt;512&gt;, UartRxBuffer&lt;256&gt;&gt;;\n</code></pre>"},{"location":"reference/module/modm-platform-uart-stm32/#using-freertos-buffers","title":"Using FreeRTOS buffers","text":"<p>A special buffer implementation is available for FreeRTOS that uses the proper queue implementation to sleep and wake up the calling thread:</p> <pre><code>// using both TX and RX software buffers\nusing UartTxRxN = BufferedUart&lt;U(s)artHalN, UartTxBufferFreeRtos&lt;512&gt;, UartRxBufferFreeRtos&lt;256&gt;&gt;;\n</code></pre> <p>This module is only available for stm32.</p>"},{"location":"reference/module/modm-platform-uart-stm32/#dependencies","title":"Dependencies","text":"<p> modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_atomic modm: architecture: atomic modm_platform_uart-&gt;modm_architecture_atomic modm_architecture_fiber modm: architecture: fiber modm_platform_uart-&gt;modm_architecture_fiber modm_architecture_interrupt modm: architecture: interrupt modm_platform_uart-&gt;modm_architecture_interrupt modm_architecture_register modm: architecture: register modm_platform_uart-&gt;modm_architecture_register modm_architecture_uart modm: architecture: uart modm_platform_uart-&gt;modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_uart-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_uart-&gt;modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_uart-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_uart-&gt;modm_platform_rcc modm_utils modm: utils modm_platform_uart-&gt;modm_utils </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-usart/","title":"Universal Synchronous Asynchronous Receiver Transmitter (USART)","text":"<p>lbuild module: <code>modm:platform:usart</code></p> <p>This module is only available for sam{e7x/s7x/v7x,g5x}.</p>"},{"location":"reference/module/modm-platform-usart/#dependencies","title":"Dependencies","text":"<p> modm:platform:usart modm_platform_usart modm: platform: usart modm_architecture_fiber modm: architecture: fiber modm_platform_usart-&gt;modm_architecture_fiber modm_architecture_uart modm: architecture: uart modm_platform_usart-&gt;modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_usart-&gt;modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_usart-&gt;modm_math_algorithm modm_platform_clockgen modm: platform: clockgen modm_platform_usart-&gt;modm_platform_clockgen modm_platform_gpio modm: platform: gpio modm_platform_usart-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-usb-fs/","title":"Full Speed","text":"<p>lbuild module: <code>modm:platform:usb:fs</code></p> <p>This module is only available for stm32{f1,f2,f4,f7,h7,l4,u5}.</p>"},{"location":"reference/module/modm-platform-usb-fs/#dependencies","title":"Dependencies","text":"<p> modm:platform:usb:fs modm_platform_usb_fs modm: platform: usb: fs modm_platform_gpio modm: platform: gpio modm_platform_usb_fs-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-usb-hs/","title":"High Speed","text":"<p>lbuild module: <code>modm:platform:usb:hs</code></p> <p>This module is only available for stm32{f2,f4,f7,h7,u5}.</p>"},{"location":"reference/module/modm-platform-usb-hs/#dependencies","title":"Dependencies","text":"<p> modm:platform:usb:hs modm_platform_usb_hs modm: platform: usb: hs modm_platform_gpio modm: platform: gpio modm_platform_usb_hs-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-usb-rp2040/","title":"Universal Serial Bus (USB)","text":"<p>lbuild module: <code>modm:platform:usb</code></p> <p>This module is only available for rp2040.</p>"},{"location":"reference/module/modm-platform-usb-rp2040/#dependencies","title":"Dependencies","text":"<p> modm:platform:usb modm_platform_usb modm: platform: usb modm_architecture_interrupt modm: architecture: interrupt modm_platform_usb-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_usb-&gt;modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_usb-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-usb-sam-d1x-d2x-dax-d5x-e5x-g5x/","title":"Universal Serial Bus (USB)","text":"<p>lbuild module: <code>modm:platform:usb</code></p> <p>This module is only available for sam{d1x/d2x/dax,d5x/e5x,g5x}.</p>"},{"location":"reference/module/modm-platform-usb-sam-d1x-d2x-dax-d5x-e5x-g5x/#dependencies","title":"Dependencies","text":"<p> modm:platform:usb modm_platform_usb modm: platform: usb modm_architecture_interrupt modm: architecture: interrupt modm_platform_usb-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_usb-&gt;modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_usb-&gt;modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_usb-&gt;modm_platform_gpio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform-usb-stm32-c0-f0-f1-f2-f3-f4-f7-g4-h7-l0-l1-l4-l5-u5/","title":"Universal Serial Bus (USB)","text":"<p>lbuild module: <code>modm:platform:usb</code></p> <p>This module is only available for stm32{c0,f0,f1,f2,f3,f4,f7,g4,h7,l0,l1,l4,l5,u5}.</p>"},{"location":"reference/module/modm-platform-usb-stm32-c0-f0-f1-f2-f3-f4-f7-g4-h7-l0-l1-l4-l5-u5/#queries","title":"Queries","text":""},{"location":"reference/module/modm-platform-usb-stm32-c0-f0-f1-f2-f3-f4-f7-g4-h7-l0-l1-l4-l5-u5/#irqs","title":"irqs","text":"<p>Filters the USB interrupts by port:</p> <ul> <li><code>usb_irqs</code>: All unfiltered USB interrupts</li> <li><code>port_irqs</code>: Filtered USB interrupts categorized by port: <code>fs</code> or <code>hs</code>.</li> <li><code>is_remap</code>: True when <code>port_irqs</code> contains remapped IRQs (specific to STM32F3)</li> </ul> <p>Interrupts used by USB FS:</p> <ul> <li>OTG_FS (no suffix)</li> <li>USB</li> <li>USBWakeUp (no suffix)</li> <li>USB_LP* (any suffix)</li> <li>USB_HP* (any suffix)</li> </ul> <p>Interrupts used by USB HS:</p> <ul> <li>OTG_HS (no suffix)</li> </ul> <p>:returns: a dictionary of USB interrupt properties</p>"},{"location":"reference/module/modm-platform-usb-stm32-c0-f0-f1-f2-f3-f4-f7-g4-h7-l0-l1-l4-l5-u5/#dependencies","title":"Dependencies","text":"<p> modm:platform:usb modm_platform_usb modm: platform: usb modm_architecture_interrupt modm: architecture: interrupt modm_platform_usb-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_usb-&gt;modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_usb-&gt;modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_usb-&gt;modm_platform_rcc </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-platform/","title":"Platform HAL","text":"<p>lbuild module: <code>modm:platform</code></p> <p>Target-specific implementation of the Hardware Abstraction Layer.</p>"},{"location":"reference/module/modm-printf/","title":"Standalone printf/sprintf formatted printing function library","text":"<p>lbuild module: <code>modm:printf</code></p> <p>This is a small but fully-loaded implementation of C's formatted printing family of functions. It was originally designed by Marco Paland, with the primary use case being in embedded systems - where these functions are unavailable, or when one needs to avoid the memory footprint of linking against a full-fledged libc. The library can be made even smaller by partially excluding some of the supported format specifiers during compilation. The library stands alone, with no external dependencies.</p> <p>For the library API see https://github.com/eyalroz/printf#library-api.</p>"},{"location":"reference/module/modm-printf/#configuration","title":"Configuration","text":"<p>On embedded targets, the <code>printf</code> family of functions are automatically replaced by this module using the <code>-fno-builtin-printf</code> compile flag to prevent compiler optimizations to substitute simple calls with <code>puts</code>. 64-bit integer support is disabled by default on AVRs. You can overwrite these defaults in a <code>modm_config_printf.h</code> file placed into your top-level include path:</p> <pre><code>// 64-bit long long support is disabled on AVR by default\n#define PRINTF_SUPPORT_LONG_LONG 1\n// 5 instead of 6 for backwards compatibility\n#define PRINTF_DEFAULT_FLOAT_PRECISION  5\n// Only on embedded targets, on hosted the libc implementation is used\n#define PRINTF_ALIAS_STANDARD_FUNCTION_NAMES 1\n</code></pre>"},{"location":"reference/module/modm-printf/#redirecting-the-output","title":"Redirecting the Output","text":"<p>All output is directed to a single function, which you must overwrite in your application to the interface of your choice.</p> <pre><code>extern \"C\" void putchar_(char c)\n{\n    // Redirect the printf output to UART.\n    Board::stlink::Uart::write(c);\n    // or IOStream if the board already has a logger\n    // MODM_LOG_INFO &lt;&lt; c;\n}\n</code></pre>"},{"location":"reference/module/modm-printf/#printf-is-not-implemented-error","title":"printf is not implemented Error","text":"<p>This module is not included by default and any attempt to use any of the printf methods fails with one or multiple linker error messages similiar to this:</p> <pre><code>`printf' referenced in section `.text.startup.main'\n    of main.o: defined in discarded section\n      `.printf_is_not_implemented!_\n           _Please_include_the__modm:printf__module_in_your_project!'\n    of libmodm.a(no_printf.o)\n</code></pre> <p>This is to prevent you from accidentally using the Newlib implementation of printf, which is very expensive and also dynamically allocated memory. You can either:</p> <ol> <li>Include this module, which provides a fast printf implementation.</li> <li>Provide your own implementation by strongly linking against printf functions.</li> </ol>"},{"location":"reference/module/modm-processing-fiber/","title":"Fibers","text":"<p>lbuild module: <code>modm:processing:fiber</code></p> <p>This module provides a lightweight stackful fiber implementation including a simple round-robin scheduler. Here is a minimal example that blinks an LED:</p> <pre><code>modm::Fiber fiber([]\n{\n    Board::LedBlue::setOutput();\n    while(true)\n    {\n        Board::LedBlue::toggle();\n        modm::this_fiber::sleep_for(1s);\n    }\n});\nint main()\n{\n    modm::fiber::Scheduler::run();\n    return 0;\n}\n</code></pre>"},{"location":"reference/module/modm-processing-fiber/#construction","title":"Construction","text":"<p>You can construct a fiber from any function without return type or arguments:</p> <pre><code>modm::Fiber fiber([]{});\nvoid function() {}\nmodm::Fiber fiber2(function);\n</code></pre> <p>To call objects with arguments, wrap the data into a lambda closure and pass it to fiber. The closure will be constructed at the top of the stack and allows the lambda wrapper to call your function with an argument:</p> <pre><code>struct DataObject\n{\n    void member_function(int arg);\n} object;\nint number{42};\nmodm::Fiber fiber([&amp;]\n{\n    object.member_function(number);\n});\n</code></pre> <p>Remember to use the right capture method for the lifetime of the objects you want to call. You can <code>std::move()</code> already constructed objects into the capture, or construct them in the capture directly, if they would get destroyed after fiber construction. You may need to mark the lambda mutable:</p> <pre><code>modm::Fiber fiber2([obj=std::move(object), obj2=DataObject()] mutable\n{\n    obj.member_function(24);\n    obj2.member_function(42);\n});\n</code></pre> <p>Do not construct <code>modm::Fiber</code> on the stack!</p> <p>Apart from the general lifetime issues of constructing objects on the stack, the allocated fiber stack size is likely too large for the caller stack and will lead to a stack overflow.</p> <p>A fiber can be passed a <code>modm::fiber::stop_token</code> to allow the fiber to be stopped cooperatively.</p> <pre><code>modm::Fiber fiber([](modm::fiber::stop_token stoken)\n{\n    // set up\n    while(not stoken.stop_requested())\n    {\n        // run your task\n    }\n    // clean up\n});\n// externally request the fiber to stop\nfiber.request_stop();\n// wait until fiber has stopped\nfiber.join();\n</code></pre> <p>Note that the fiber destructor requests to stop and joins automatically. The interface and behavior is similar to the C++20 <code>std::jthread</code>.</p>"},{"location":"reference/module/modm-processing-fiber/#delayed-start","title":"Delayed Start","text":"<p>Fiber are added to the scheduler automatically and start execution when the scheduler is run. You can disable this behavior by setting <code>start</code> to <code>modm::fiber::Start::Later</code> during construction and manually starting the fiber when it is ready, also from another fiber:</p> <pre><code>// fiber does not automatically start executing\nmodm::Fiber fiber2(function, modm::fiber::Start::Later);\n// fiber2 is automatically executing\nmodm::Fiber fiber1([&amp;]\n{\n    modm::this_fiber::sleep_for(1s);\n    fiber2.start();\n});\nmodm::fiber::Scheduler::run();\n// fiber1 waits 1s, then starts fiber2 and exits\n</code></pre> <p>Fibers can end by returning from their wrapper, after which they will be removed from the scheduler. A fiber can then be restarted again by calling <code>start()</code>, which will call the closure again from the beginning. Note, that the lambda capture is not destructed and reconstructed, but remains unchanged between restarts. If you need a fiber that is only callable once, you can implement this behavior manually with a boolean in the capture:</p> <pre><code>modm::Fiber fiber([ran=false]\n{\n    if (ran) return;\n    ran = true;\n    // only called once.\n});\n</code></pre>"},{"location":"reference/module/modm-processing-fiber/#customization","title":"Customization","text":"<p>The most important customization is the fiber stack size expressed in bytes:</p> <pre><code>modm::Fiber&lt;128&gt; fiber1(...);\nmodm::Fiber&lt;256&gt; fiber2(...);\n</code></pre> <p>The <code>Fiber</code> class is intentionally constructed at runtime, so that it does not increase your program size, as the <code>.data</code> section would. You may also place the fibers into the <code>.faststack</code> section, which is not zeroed and thus saves a bit of time on startup:</p> <pre><code>modm_faststack modm::Fiber(stack, function);\n</code></pre> <p>However, it may be desirable to control the placement of the fiber task structure and especially the stack, depending on the types of memories available on your device. This is possible when you construct the stack and task in combination with the <code>modm_section()</code> macros and its specializations:</p> <pre><code>// Place a very large stack in the external memory\nmodm_section(\".sdram_noinit\") modm::fiber::Stack&lt;1024*10&gt; large_stack;\n// But keep the task control structure in internal memory\nmodm_fastdata modm::fiber::Task fiber(large_stack, big_function);\n</code></pre>"},{"location":"reference/module/modm-processing-fiber/#subclassing","title":"Subclassing","text":"<p>You can inherit from the <code>modm::Fiber</code> class to extend a fiber with a proper object interface. This is useful for providing a more expressive interface to a fiber by means of shared memory.</p> <pre><code>class CustomFiber : public modm::Fiber&lt;&gt;\n{\npublic:\n    CustomFiber() : Fiber([this]{ run(); }) {}\n\n    // called from another fiber\n    void trigger() { trigger_ = true; }\n\nprivate:\n    bool trigger_{false}; // shared memory between fibers\n\n    void inline\n    run()\n    {\n        while(true)\n        {\n            modm::this_fiber::poll([&amp;]{ return trigger_; });\n            trigger_ = false;\n            // long running response to the trigger\n        }\n    }\n};\n</code></pre>"},{"location":"reference/module/modm-processing-fiber/#concurrency-support","title":"Concurrency Support","text":"<p>The <code>modm::fiber</code> namespace provides several standard concurrency primitives to synchronize fibers based on the <code>std::thread</code> interface behavior. Most primitives are implemented on top of <code>&lt;atomic&gt;</code>, therefore can be called from within (nested) interrupts. The API docs explicitly mention if a function is safe to call from an interrupt.</p>"},{"location":"reference/module/modm-processing-fiber/#threads","title":"Threads","text":"<ul> <li><code>Task</code> implements most of the <code>std::jthread</code> interface.</li> </ul> <p>In particular, <code>Task</code> only implements functionality that does not require dynamic memory allocations. The stack memory needs to be allocated externally and fibers are not movable or copyable and therefore cannot be detached or swapped.</p>"},{"location":"reference/module/modm-processing-fiber/#thread-cancellation","title":"Thread Cancellation","text":"<ul> <li><code>stop_token</code> and <code>stop_source</code> with simplified implementations.</li> <li><code>stop_callback</code> not implemented.</li> </ul> <p>To avoid dynamic memory allocations, a <code>stop_state</code> object provides the actual memory required for the limited functionality:</p> <pre><code>modm::fiber::stop_state state;\n// only valid as long as state is valid!\nauto source = state.get_source();\nauto token = state.get_token();\n// use token in a condition variable\ncv.wait(lock, token, predicate);\n// request a stop somewhere else\nsource.request_stop();\n</code></pre> <p>Implemented using interrupt-safe atomics.</p>"},{"location":"reference/module/modm-processing-fiber/#mutual-exclusion","title":"Mutual Exclusion","text":"<ul> <li><code>mutex</code> and <code>timed_mutex</code>.</li> <li><code>recursive_mutex</code> and <code>recursive_timed_mutex</code>.</li> <li><code>shared_mutex</code> and <code>shared_timed_mutex</code>.</li> </ul> <p>Implemented using interrupt-safe atomics.</p>"},{"location":"reference/module/modm-processing-fiber/#generic-mutex-management","title":"Generic Mutex Management","text":"<ul> <li><code>lock_guard</code>, <code>scoped_lock</code>, <code>unique_lock</code> and <code>shared_lock</code>.</li> <li><code>defer_lock_t</code>, <code>try_to_lock_t</code> and <code>adopt_lock_t</code>.</li> <li><code>defer_lock</code>, <code>try_to_lock</code> and <code>adopt_lock</code>.</li> </ul>"},{"location":"reference/module/modm-processing-fiber/#generic-locking-algorithms","title":"Generic Locking Algorithms","text":"<ul> <li><code>try_lock</code> and <code>lock</code>.</li> </ul>"},{"location":"reference/module/modm-processing-fiber/#call-once","title":"Call Once","text":"<ul> <li><code>once_flag</code> and <code>call_once</code>.</li> </ul> <p>Implemented using interrupt-safe atomic flag.</p>"},{"location":"reference/module/modm-processing-fiber/#condition-variables","title":"Condition Variables","text":"<ul> <li><code>condition_variable</code> and <code>condition_variable_any</code>.</li> <li><code>cv_status</code>.</li> <li><code>notify_all_at_thread_exit</code> not implemented.</li> </ul> <p>Notification is implemented as a interrupt-safe 16-bit atomic counter.</p>"},{"location":"reference/module/modm-processing-fiber/#semaphores","title":"Semaphores","text":"<ul> <li><code>counting_semaphore</code> and <code>binary_semaphore</code>.</li> </ul> <p>Counts are implemented as interrupt-safe 16-bits atomics.</p>"},{"location":"reference/module/modm-processing-fiber/#latches-and-barriers","title":"Latches and Barriers","text":"<ul> <li><code>latch</code>: implemented as interrupt-safe atomics.</li> <li><code>barrier</code>: not interrupt-safe!</li> </ul> <p>Counts are implemented as 16-bits.</p>"},{"location":"reference/module/modm-processing-fiber/#stack-usage","title":"Stack Usage","text":"<p>To measure the stack usage of a fiber, you need to start the scheduler with the <code>AutoWatermark</code> option, then you may query the stack usage inside or outside the fiber:</p> <pre><code>modm::fiber::Scheduler::run(modm::fiber::Scheduler::AutoWatermark);\n// can be called from anywhere at any time!\nsize_t total = fiber.stack_size();\nsize_t used = fiber.stack_usage();\n</code></pre> <p>Note that stack usage measurement through watermarking can be inaccurate if the registers contain the watermark value.</p>"},{"location":"reference/module/modm-processing-fiber/#stack-overflow","title":"Stack Overflow","text":"<p>Each context switch checks if the stack overflowed, in which case the scheduler will abandon execution and trigger an assertion on the main stack with the identifier <code>fbr.stkof</code> and the fiber pointer as context. Note that the assertion is executed on the main stack and not on the fiber stack that overflowed!</p> <p>On ARMv8-M devices, the stack overflow is checked in hardware via the PSPLIM register, therefore the context switch is a little faster.</p>"},{"location":"reference/module/modm-processing-fiber/#scheduling","title":"Scheduling","text":"<p>The scheduler <code>run()</code> function will suspend execution of the call site, usually the main function, start each fiber and continue to execute them until they all ended and then return execution to the call site:</p> <pre><code>while(true)\n{\n    modm::fiber::Scheduler::run();\n    // sleep until the next interrupt?\n    __WFI();\n    // then start the fibers again\n    fiber.start();\n}\n</code></pre> <p>Please note that neither the fiber nor scheduler is interrupt safe, so starting threads from interrupt context is a bad idea!</p> <p>Using <code>yield()</code> outside of a fiber</p> <p>If <code>yield()</code> is called before the scheduler started or if only one fiber is running, it simply returns in-place, since there is nowhere to switch to.</p>"},{"location":"reference/module/modm-processing-fiber/#platforms","title":"Platforms","text":"<p>Fibers are implemented by saving callee registers to the current stack, then switching to a new stack and restoring callee registers from this stack. The static <code>modm::this_fiber::yield()</code> function wraps this functionality in a transparent way.</p>"},{"location":"reference/module/modm-processing-fiber/#avr","title":"AVR","text":"<p>On AVRs the fiber stack is shared with the currently active interrupt. This requires the fiber stack size to include the worst case stack size of all interrupts. Fortunately on AVRs interrupts cannot be nested.</p> <p>Therefore the default stack size is a fairly large 512B.</p>"},{"location":"reference/module/modm-processing-fiber/#arm-cortex-m","title":"Arm Cortex-M","text":"<p>On Cortex-M, the main function is entered using the MSP in Handler mode. After calling <code>modm::fiber::Scheduler::run()</code> the PSP is used as a Fiber stack pointer in Thread mode. Therefore all interrupts are using the main stack whose size is defined by the <code>modm:platform:cortex-m:main_stack_size</code> option and will not increase the fiber stack size at all.</p> <p>The default stack size is 1KiB.</p>"},{"location":"reference/module/modm-processing-fiber/#hosted","title":"Hosted","text":"<p>Two implementations for x86_64 and ARM64 are provided.</p> <p>The default stack size is 1MiB.</p>"},{"location":"reference/module/modm-processing-fiber/#multi-core-scheduling","title":"Multi-Core Scheduling","text":"<p>When using this module in combination with the <code>modm:platform:multicore</code> module, each core gets its own fiber scheduler, which will internally be selected based on the CPU ID. Since the scheduler is not thread-safe, you cannot add fibers from one core to the other. Instead you must construct the fiber without starting it, and when executing on the other core, <code>start()</code> it in that context.</p> <p>Here is an example for the RP2040 device, which additionally allocates the stack and task into the core-affine memory:</p> <pre><code>// allocate into core0 memory\nmodm_faststack_core0 modm::Fiber fiber0(function);\n// allocate into core1 memory but DO NOT start yet!\nmodm_faststack_core1 modm::Fiber fiber1(function, modm::fiber::Start::Later);\n\nvoid core1_main()\n{\n    // start fiber1 in the core1 context!\n    fiber1.start();\n    modm::fiber::Scheduler::run();\n}\n\nint main()\n{\n    modm::platform::multicore::Core1::run(core1_main);\n    // run fiber0 in core0 context\n    modm::fiber::Scheduler::run();\n    return 0;\n}\n</code></pre>"},{"location":"reference/module/modm-processing-fiber/#dependencies","title":"Dependencies","text":"<p> modm:processing:fiber modm_processing_fiber modm: processing: fiber modm_architecture_assert modm: architecture: assert modm_processing_fiber-&gt;modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_processing_fiber-&gt;modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_processing_fiber-&gt;modm_architecture_clock modm_architecture_fiber modm: architecture: fiber modm_processing_fiber-&gt;modm_architecture_fiber modm_cmsis_device modm: cmsis: device modm_processing_fiber-&gt;modm_cmsis_device modm_stdc++ modm: stdc++ modm_processing_fiber-&gt;modm_stdc++ </p>"},{"location":"reference/module/modm-processing-protothread/","title":"Protothreads","text":"<p>lbuild module: <code>modm:processing:protothread</code></p> <p>Protothreads are deprecated!</p> <p>Protothreads are deprecated and will be removed in the future! Please use the fiber shim layer by setting the <code>modm:processing:protothread:use_fiber</code> option and then port your code to use <code>modm:processing:fiber</code> directly.</p> <p>Protothreads are extremely lightweight stackless threads designed for severely memory constrained systems, such as small embedded systems or wireless sensor network nodes. Protothreads provide linear code execution for event-driven systems implemented in C. Protothreads can be used with or without an underlying operating system to provide blocking event-handlers.</p> <p>Protothreads provide sequential flow of control without complex state machines or full multi-threading.</p> <p>Since they implement some kind of cooperative multi-threading, Protothreads are non-preemptable. Therefore, a context switch can only take place on blocking operations, which means you don't need complex synchronization.</p> <p>Protothreads are also stackless, so local variables are not preserved across context switches, and must instead become member variables of the <code>modm::Protothread</code> subclass</p> <p>A protothread runs within a single function (<code>modm::Protothread::run()</code>) and cannot span over other functions. A protothread may call normal functions, but cannot block inside a called function. Blocking inside nested function calls is instead made by spawning a separate protothread for each potentially blocking function.</p> <p>The protothread concept was developed by Adam Dunkels and Oliver Schmidt: http://dunkels.com/adam/pt</p> <p>Originally ported to C++ for use by Hamilton Jet (www.hamiltonjet.co.nz) by Ben Hoyt, but stripped down for public release.</p>"},{"location":"reference/module/modm-processing-protothread/#example","title":"Example","text":"<pre><code>#include &lt;modm/processing/protothread.hpp&gt;\n\nusing Led = GpioB0;\n\nclass BlinkingLight : public modm::pt::Protothread\n{\npublic:\n    bool\n    run()\n    {\n        PT_BEGIN();\n\n        // set everything up\n        Led::setOutput();\n        Led::set();\n\n        while (true)\n        {\n            timeout.restart(100ms);\n            Led::set();\n            PT_WAIT_UNTIL(timeout.isExpired());\n\n            timeout.restart(200ms);\n            Led::reset();\n            PT_WAIT_UNTIL(timeout.isExpired());\n        }\n\n        PT_END();\n    }\n\nprivate:\n    modm::ShortTimeout timeout;\n};\n// ...\n\nBlinkingLight light;\n\nwhile (true) {\n    light.run();\n}\n</code></pre>"},{"location":"reference/module/modm-processing-protothread/#using-fibers","title":"Using Fibers","text":"<p>Protothreads can be implemented using stackful fibers by setting the <code>use_fiber</code> option, which replaces the preprocessor macros and C++ implementations of this and the <code>modm:processing:resumable</code> module with a fiber version.</p> <p>Specifically, the <code>PT_*</code> and <code>RF_*</code> macros are now forwarding their arguments unmodified and instead relying on <code>modm::this_fiber::yield()</code> for context switching:</p> <pre><code>#define PT_YIELD() modm::this_fiber::yield()\n#define PT_WAIT_WHILE(cond) while(cond) { modm::this_fiber::yield(); }\n#define PT_CALL(func) func\n</code></pre> <p>The <code>modm::pt::Protothread</code> class is implemented using <code>modm::Fiber&lt;&gt;</code> with the default stack size <code>MODM_PROTOTHREAD_STACK_SIZE</code>. It automatically runs the two virtual methods <code>bool run()</code> and <code>bool update()</code> if they are defined in the protothread class.</p> <p>There should be no modification of the existing code necessary with the exception that you must replace the main loop calling all protothreads with the fiber scheduler:</p> <pre><code>int main()\n{\n    /*\n    while(true)\n    {\n        protothread1.update();\n        protothread2.update();\n    }\n    */\n    modm::fiber::Scheduler::run();\n    return 0;\n}\n</code></pre>"},{"location":"reference/module/modm-processing-protothread/#restrictions","title":"Restrictions","text":"<p>If the default stack size is too low, you can set <code>MODM_PROTOTHREAD_STACK_SIZE</code> to a higher value, however, this will apply to all protothreads, consuming a lot more memory. Instead, we recommend refactoring the protothread into a fiber function.</p> <p>See the <code>modm:processing:resumable</code> module for additional restrictions when calling resumable functions from a protothread.</p>"},{"location":"reference/module/modm-processing-protothread/#options","title":"Options","text":""},{"location":"reference/module/modm-processing-protothread/#use_fiber","title":"use_fiber","text":"<p>Implement Protothreads and Resumable Functions via Fibers</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> Input Dependency: <code>yes -&gt; modm:processing:fiber</code> </p>"},{"location":"reference/module/modm-processing-protothread/#dependencies","title":"Dependencies","text":"<p> modm:processing:protothread modm_processing_protothread modm: processing: protothread modm_architecture modm: architecture modm_processing_protothread-&gt;modm_architecture modm_processing_fiber modm: processing: fiber modm_processing_protothread-&gt;modm_processing_fiber </p>"},{"location":"reference/module/modm-processing-resumable/","title":"Resumable Functions","text":"<p>lbuild module: <code>modm:processing:resumable</code></p> <p>Resumable Functions are deprecated!</p> <p>Unfortunately GCC12 is the last version that supported the way we implemented Resumables. Since GCC13 the implementation does not compile anymore and cannot be fixed without significant breaking changes. Please port your code to use <code>modm:processing:fiber</code> instead.</p> <p>An implementation of lightweight resumable functions which allow for nested calling.</p> <p>This base class and its macros allows you to implement and use several resumable functions in one class. This allows you to modularize your code by placing it into its own resumable functions instead of the placing everything into one big method. It also allows you to call and run resumable functions within your resumables, so you can reuse their functionality.</p> <p>Note that you should call resumable functions within a protothreads, with the <code>PT_CALL(group.resumable())</code> macro, which will return the result of the resumable function. To call a resumable function inside another resumable function, use the <code>RF_CALL(group.resumable())</code>.</p> <p>You may use the <code>RF_CALL_BLOCKING(group.resumable())</code> macro to execute a resumable function outside of a protothread, however, this which will force the CPU to busy-wait until the resumable function ended.</p> <p>Resumable functions are not thread-safe!</p> <p>Use an external mutex to arbitrate access if two Protothreads access the same resumable function.</p> <p>You can either run your group of resumable functions independently from each other, or only run one function at a time, but it may nest calls to its own group's functions. So you need to inherit your group from <code>modm::Resumable&lt;#Functions&gt;</code>, and from <code>modm::NestedResumable&lt;#Functions&gt;</code> respectively.</p>"},{"location":"reference/module/modm-processing-resumable/#independent-operation","title":"Independent operation","text":"<p>You must begin each resumable function using <code>RF_BEGIN(index)</code> where <code>index</code> is the unique index of your resumable function starting at zero. You may exit and return a value by using <code>RF_RETURN(value)</code> or return the result of another resumable function using <code>RF_RETURN_CALL(resumable())</code>. This return value is wrapped in a <code>modm::ResumableResult&lt;Type&gt;</code> struct and transparently returned by the <code>RF_CALL</code> macro so it can be used to influence your program flow. If the resumable function reaches <code>RF_END()</code> it will exit automatically, with the result of <code>0</code> cast to the return type. Should you wish to return a value at the end, you may use <code>RF_END_RETURN(value)</code>. You may also return the result of another resumable function using <code>RF_END_RETURN_CALL(resumable())</code>.</p> <p>Be aware that this class keeps a separate state for each of your resumable functions. This allows each resumable function to be run at the same time. This might require the use of an internal semaphore or mutex if such dependencies exist in your use case. Take a look at the <code>NestedResumable</code> class for mutually exclusive resumable functions, which also require a little less memory.</p>"},{"location":"reference/module/modm-processing-resumable/#nested-operation","title":"Nested operation","text":"<p>You are responsible to choosing the right nesting depth! This class will guard itself against calling another resumable function at too deep a nesting level and fail the <code>rf.nest</code> assertion! It is then up to you to recognize this in your program design and increase the nesting depth or rethink your code.</p> <p>The resumable functions of this class are mutually exclusive, so only one resumable function of the same object can run at the same time. Even if you call another resumable function, it will simply return <code>modm::rf::WrongState</code>. Using the <code>RF_CALL(resumable())</code> macro, you can wait for these resumable functions to become available and then run them, so you usually do not need to worry about those cases.</p> <p>You must begin each resumable function using <code>RF_BEGIN()</code>. You may exit and return a value by using <code>RF_RETURN(value)</code> or return the result of another resumable function using <code>RF_RETURN_CALL(resumable())</code>. This return value is wrapped in a <code>modm::ResumableResult&lt;Type&gt;</code> struct and transparently returned by the <code>RF_CALL</code> macro so it can be used to influence your program flow. If the resumable function reaches <code>RF_END()</code> it will exit automatically, with the result of <code>0</code> cast to the return type. Should you wish to return a value at the end, you may use <code>RF_END_RETURN(value)</code>. You may also return the result of another resumable function using <code>RF_END_RETURN_CALL(resumable())</code>.</p>"},{"location":"reference/module/modm-processing-resumable/#example","title":"Example","text":"<p>Here is a (slightly over-engineered) example:</p> <pre><code>#include &lt;modm/platform.hpp&gt;\n#include &lt;modm/processing.hpp&gt;\n\nusing Led = GpioOutputB0;\n\nclass BlinkingLight : public modm::pt::Protothread, private modm::NestedResumable&lt;2&gt;\n{\npublic:\n    bool\n    run()\n    {\n        PT_BEGIN();\n\n        // set everything up\n        Led::setOutput();\n        Led::set();\n\n        while (true)\n        {\n            Led::set();\n            PT_CALL(waitForTimer());\n\n            Led::reset();\n            PT_CALL(setTimer(200));\n\n            PT_WAIT_UNTIL(timeout.isExpired());\n        }\n\n        PT_END();\n    }\n\n    modm::ResumableResult&lt;bool&gt;\n    waitForTimer()\n    {\n        RF_BEGIN();\n\n        // nested calling is allowed\n        if (RF_CALL(setTimer(100)))\n        {\n            RF_WAIT_UNTIL(timeout.isExpired());\n            RF_RETURN(true);\n        }\n\n        RF_END_RETURN(false);\n    }\n\n    modm::ResumableResult&lt;bool&gt;\n    setTimer(uint16_t new_timeout)\n    {\n        RF_BEGIN();\n\n        timeout.restart(std::chrono::milliseconds(new_timeout));\n\n        if(timeout.isArmed()) {\n            RF_RETURN(true);\n        }\n\n        // clean up code goes here\n\n        RF_END_RETURN(false);\n    }\n\nprivate:\n    modm::ShortTimeout timeout;\n};\n\nBlinkingLight light;\n\nwhile (true) {\n    light.run();\n}\n</code></pre> <p>For other examples take a look in the <code>examples</code> folder in the modm root folder. The given example is in <code>modm/examples/generic/resumable</code>.</p>"},{"location":"reference/module/modm-processing-resumable/#using-fibers","title":"Using Fibers","text":"<p>Resumable functions can be implemented using stackful fibers by setting the <code>modm:processing:protothread:use_fiber</code> option, which replaces the preprocessor macros and C++ implementations of this and the <code>modm:processing:protothreads</code> module with a fiber version.</p> <p>Specifically, the <code>PT_*</code> and <code>RF_*</code> macros are now forwarding their arguments unmodified and instead relying on <code>modm::this_fiber::yield()</code> for context switching:</p> <pre><code>#define RF_YIELD() modm::this_fiber::yield()\n#define RF_WAIT_WHILE(cond) while(cond) { modm::this_fiber::yield(); }\n#define RF_CALL(func) func\n#define RF_RETURN(value) return value\n</code></pre> <p>You may call <code>RF_CALL_BLOCKING(resumable)</code> outside a fiber context, in which case the <code>modm::this_fiber::yield()</code> will return immediately, which is the same behavior as before.</p> <p>However, the <code>modm::ResumableResult</code>, <code>modm::Resumable</code>, and <code>modm::NestedResumable</code> classes are now empty implementations:</p> <pre><code>// Only forwards the return value\ntemplate &lt;typename T&gt; using ResumableResult = T;\n\n// Empty base classes\ntemplate&lt;uint8_t Functions=0&gt; class Resumable {};\ntemplate&lt;uint8_t Levels=0&gt; class NestedResumable {};\n</code></pre> <p>There should be no modification necessary to the resumable functions itself.</p>"},{"location":"reference/module/modm-processing-resumable/#restrictions","title":"Restrictions","text":"<p>There is one minor limitations when using fibers: 1) no nesting depth checking for <code>NestedResumable</code>, 2) stopping resumable functions is not implementable.</p> <p>The nesting depth is limited by the stack size of the fiber, so it would manifest as a stack overflow, which would need to be checked differently.</p> <p>The utility member functions - <code>Resumable::stopAllResumables()</code>, - <code>Resumable::stopResumable(uint8_t)</code>, and - <code>NestedResumable::stopResumable()</code> cannot be implemented using fibers as that would require the resumable to implement a cancellation point using <code>modm::fiber::stop_token</code>. However, since there is no concept of this in the original API, it is simply missing and thus cannot be implemented transparently.</p>"},{"location":"reference/module/modm-processing-resumable/#options","title":"Options","text":""},{"location":"reference/module/modm-processing-resumable/#check_nesting_depth","title":"check_nesting_depth","text":"<p>Check nesting call depth</p> <p>Nested resumable functions protect against memory corruption by checking if the nesting level is within the allocated nesting level depth, on first entry to the function. If the allocated nesting level is exceeded, the assertion <code>resumable.begin.nesting</code> fails.</p> <p>You may disable this behavior by disabling this check, then instead of the assertion, the function on entry returns the <code>modm::rf::NestingError</code> state value. <code>PT_CALL()</code> and <code>RF_CALL()</code> macros will respond to this error by stopping function polling and just continuing program execution.</p> <p>Performance Penalty</p> <p>This check is performed during the call to <code>RF_BEGIN(N)</code>, so exactly once on function entry and not during every polling call, so the performance penalty is relatively small.</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-processing-resumable/#dependencies","title":"Dependencies","text":"<p> modm:processing:resumable modm_processing_resumable modm: processing: resumable modm_architecture_assert modm: architecture: assert modm_processing_resumable-&gt;modm_architecture_assert modm_architecture_fiber modm: architecture: fiber modm_processing_resumable-&gt;modm_architecture_fiber </p>"},{"location":"reference/module/modm-processing-rtos/","title":"RTOS Abstractions","text":"<p>lbuild module: <code>modm:processing:rtos</code></p> <p>Basic building blocks of an RTOS abstracted as C++ classes and implemented either with FreeRTOS or stdlibc++.</p> <p>This module is only available for hosted, stm32.</p>"},{"location":"reference/module/modm-processing-rtos/#dependencies","title":"Dependencies","text":"<p> modm:processing:rtos modm_processing_rtos modm: processing: rtos modm_freertos modm: freertos modm_processing_rtos-&gt;modm_freertos modm_platform_heap modm: platform: heap modm_processing_rtos-&gt;modm_platform_heap </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-processing-scheduler/","title":"Generic Scheduler","text":"<p>lbuild module: <code>modm:processing:scheduler</code></p> <p>Priority task scheduling</p>"},{"location":"reference/module/modm-processing-scheduler/#dependencies","title":"Dependencies","text":"<p> modm:processing:scheduler modm_processing_scheduler modm: processing: scheduler modm_architecture_accessor modm: architecture: accessor modm_processing_scheduler-&gt;modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_processing_scheduler-&gt;modm_architecture_atomic </p>"},{"location":"reference/module/modm-processing-timer/","title":"Software Timers","text":"<p>lbuild module: <code>modm:processing:timer</code></p> <p>This module provides polling based software timers for executing code after a delay or periodically in millisecond resolution via <code>modm::Clock</code> and in microsecond resolution via <code>modm::PreciseClock</code>.</p> <p>To delay or delegate execution to the future, you can use <code>modm::Timeout</code> to set a duration after which the timeout expires and executes your code:</p> <pre><code>modm::Timeout timeout{100ms};\nwhile (not timeout.isExpired()) ;\n// your code after a delay\n</code></pre> <p>However, this construct is not very useful, particularly since you could also simply use <code>modm::delay(100ms)</code> for this, so instead use the <code>execute()</code> method to poll non-blockingly for expiration:</p> <pre><code>modm::Timeout timeout{100ms};\n\nvoid update()\n{\n    if (timeout.execute())\n    {\n        // your code after a expiration\n    }\n}\n// You must call the update() function in your main loop now!\nint main()\n{\n    while(1)\n    {\n        update();\n    }\n}\n</code></pre> <p>The <code>execute()</code> method returns true only once after expiration, so it can be continuously polled somewhere in your code. A more comfortable use-case is to use a <code>modm::Timeout</code> inside a class that needs to provide some asynchronous method for timekeeping:</p> <pre><code>class DelayEvents\n{\n    modm::Timeout timeout;\npublic:\n    void event() { timeout.restart(100ms); }\n    void update()\n    {\n        if (timeout.execute()) {\n            // delegated code here\n        }\n    }\n}\n</code></pre> <p>However, for more complex use-cases, these classes are intended to be used with fibers (from module <code>modm:processing:fiber</code>) to implement non-blocking delays.</p> <pre><code>modm::Fiber fiber_timeout([]\n{\n    modm::Timeout timeout(100ms);\n    timeout.wait();\n    // NOTE: for such simple delays, use the built-in fiber sleep function!\n    modm::this_fiber::sleep_for(100ms);\n});\n</code></pre> <p>For periodic timeouts, you could simply restart the timeout, however, the <code>restart()</code> method schedules a timeout from the current time onwards:</p> <pre><code>modm::Timeout timeout(100ms);\nmodm::Fiber fiber_timeout([]\n{\n    while(true)\n    {\n        timeout.wait(); // yields fiber until timeout\n        // delayed code introduces latency\n        timeout.restart(); // restarts but with *current* time!!!\n    }\n});\n</code></pre> <p>This can lead to longer period than required, particularly in a system that has a lot to do and cannot service every timeout immediately. The solution is to use a <code>modm::PeriodicTimer</code>, which only reimplements the <code>wait()</code> method to automatically restart the timer, by adding the interval to the old time, thus keeping the period accurate:</p> <pre><code>modm::PeriodicTimer timer{100ms};\nmodm::Fiber fiber_timer([]\n{\n    while(true)\n    {\n        timer.wait(); // automatically restarts\n        // code can take up to 100ms, but timer period won't drift\n    }\n});\n</code></pre> <p>The <code>wait()</code> method actually returns the number of missed periods, so that in a heavily congested system you do not need to keep track of time yourself. This can be particularly useful when dealing with soft real-time physical systems like LED animations or control loops:</p> <pre><code>modm::PeriodicTimer timer{1ms}; // render at 1kHz ideally\nmodm::Fiber fiber_timer([]\n{\n    while(true)\n    {\n        // call only once regardless of the number of periods\n        animation.step(timer.wait()); // still compute the missing steps\n        animation.render();           // but only render once please\n\n        // or alternatively to call the code the number of missed periods\n        for (auto periods{timer.wait()}; periods; periods--)\n        {\n            // periods is decreasing!\n        }\n        // This is fine, since execute() is evaluated only once!\n        for (auto periods : modm::range(timer.wait()))\n        {\n            // periods is increasing!\n        }\n        // THIS WILL NOT WORK, since execute() reschedules itself immediately!\n        for (auto periods{0}; periods &lt; timer.wait(); periods++)\n        {\n            // called at most only once!!! periods == 0 always!\n        }\n    }\n});\n</code></pre> <p>DO NOT use for hard real time systems!</p> <p>You are responsible for polling these timers <code>execute()</code> methods as often as required. If you need to meet hard real time deadlines these are not the timers you are looking for!</p> <p>Timers are stopped by default!</p> <p>If you want to start a timer at construction time, give the constructor a duration. Duration Zero will expire the timer immediately</p>"},{"location":"reference/module/modm-processing-timer/#resolution","title":"Resolution","text":"<p>Two timer resolutions are available, using <code>modm::Clock</code> for milliseconds and <code>modm::PreciseClock</code> for microseconds. They follow the same naming scheme:</p> <ul> <li><code>modm::Timeout</code>, <code>modm::PeriodicTimer</code>: 49 days in milliseconds and 8 bytes.</li> <li><code>modm::PreciseTimeout</code>, <code>modm::PrecisePeriodicTimer</code>: 71 mins in microseconds   and 8 bytes.</li> </ul> <p>If you deal with short time periods, you can save a little memory by using the 16-bit versions of the same timers:</p> <ul> <li><code>modm::ShortTimeout</code>, <code>modm::ShortPeriodicTimer</code>: 65 seconds in milliseconds   and 4 bytes.</li> <li><code>modm::ShortPreciseTimeout</code>, <code>modm::ShortPrecisePeriodicTimer</code>: 65   milliseconds in microseconds and 4 bytes.</li> </ul>"},{"location":"reference/module/modm-processing-timer/#dependencies","title":"Dependencies","text":"<p> modm:processing:timer modm_processing_timer modm: processing: timer modm_architecture_assert modm: architecture: assert modm_processing_timer-&gt;modm_architecture_assert modm_architecture_clock modm: architecture: clock modm_processing_timer-&gt;modm_architecture_clock modm_architecture_fiber modm: architecture: fiber modm_processing_timer-&gt;modm_architecture_fiber modm_math_utils modm: math: utils modm_processing_timer-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-processing/","title":"Processing","text":"<p>lbuild module: <code>modm:processing</code></p> <p>Constructs to influence program flow execution, timing, synchronization and delegation.</p>"},{"location":"reference/module/modm-ros/","title":"ROS Library","text":"<p>lbuild module: <code>modm:ros</code></p> <p>Repository of generated messages headers for rosserial. See https://github.com/modm-io/ros-lib.</p>"},{"location":"reference/module/modm-rtt/","title":"Real Time Transfer (RTT)","text":"<p>lbuild module: <code>modm:rtt</code></p> <p>This module implements the RTT protocol compatible with JLink and OpenOCD. RTT works by placing multiple ring-buffers in RAM which the debugger read and writes using background memory accesses via SWD. It therefore works on any Cortex-M device without extra pins except for the SWDCLK and SWDIO.</p> <p>You can define the number of channels and their buffer size by setting the <code>buffer.tx</code> and <code>buffer.rx</code> set options. Note that you can define multiple buffer sizes indexed by channel. Here is an example of three channels:</p> <pre><code>&lt;!-- Channel0: TX only with 256B buffer --&gt;\n&lt;!-- Channel1: RX only with 128B buffer --&gt;\n&lt;!-- Channel2: TX with 512B and RX with 64B buffer --&gt;\n&lt;option name=\"modm:rtt:buffer.tx\"&gt;256, 0, 512&lt;/option&gt;\n&lt;option name=\"modm:rtt:buffer.rx\"&gt;0, 128, 64&lt;/option&gt;\n</code></pre> <p>You can set the buffer size to <code>0</code> if you don't want to use this channel direction. This won't allocate a buffer and save a little RAM.</p> <p>The API reference is available here.</p>"},{"location":"reference/module/modm-rtt/#accessing-data","title":"Accessing Data","text":"<p>OpenOCD has built-in support for RTT and modm generates a config that opens each RTT channel as a TCP port starting at 9090 (ie. 9090=channel 0, 9091=channel 1, etc).</p> <pre><code>openocd -f modm/openocd.cfg -c modm_rtt\n</code></pre> <p>You can also call this from inside GDB via the <code>monitor</code> command:</p> <pre><code>(gdb) monitor modm_rtt\nrtt: Searching for control block 'SEGGER RTT'\nrtt: Control block found at 0x20001024\nListening on port 9090 for rtt connections\n(gdb) continue&amp;\n</code></pre> <p>You can then use netcat to connect to one or multiple streams:</p> <pre><code>stty -icanon -echo\nnc localhost 9090\nstty sane\n</code></pre> <p>Note that this connection does not halt the target, you should therefore be able to use this at any point during program execution.</p> <p>A simple RTT client is integrated into the build system generator, however, it can only connect to one stream at a time (disconnect with Ctrl+C).</p> <pre><code> $ scons log-rtt\n\u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500&gt; Real Time Transfer\n\u2570\u2500\u2500\u2500\u2500\u2500RTT\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt\nInfo : rtt: Searching for control block 'SEGGER RTT'\nInfo : rtt: Control block found at 0x20000008\nListening on port 9090 for rtt connections\nloop 51\nloop 52\nloop 53\n^C\n\n $ make log-rtt channel=0\nInfo : rtt: Searching for control block 'SEGGER RTT'\nInfo : rtt: Control block found at 0x20000008\nListening on port 9090 for rtt connections\nloop 58\nloop 60\nloop 61\n</code></pre> <p>If you want to use this as a proper communication channel with a custom protocol you should implement the OpenOCD config yourself (with different ports).</p> <p>You can also use JLink to access the RTT data, which may be significantly faster than OpenOCD if the debug probe has hardware support for the protocol. Note the port JLink uses is 19021 (channel 0) and 19022 (channel 1), etc.</p> <pre><code> $ scons log-rtt-jlink\n\u256d\u2500\u2500\u2500\u2500JLink\u2500\u2500\u2500\u2500&gt; Real Time Transfer\n\u2570\u2500\u2500\u2500\u2500\u2500RTT\u2500\u2500\u2500\u2500\u2500\u2500 stm32l476rgt6\n\nSEGGER J-Link - Real time terminal output\nRTT Demo on Nucleo-64\nloop: 0\nloop: 1\nloop: 2\nloop: 3\nloop: 4\nloop: 5\nloop: 6\nloop: 7\n</code></pre> <p>This module is only available for rp, sam, stm32.</p>"},{"location":"reference/module/modm-rtt/#options","title":"Options","text":""},{"location":"reference/module/modm-rtt/#bufferrx","title":"buffer.rx","text":"<p>Receive buffer sizes</p> <p>Default: <code>[32]</code> Inputs: <code>[0 ... +Inf]</code> </p>"},{"location":"reference/module/modm-rtt/#buffertx","title":"buffer.tx","text":"<p>Transmit buffer sizes</p> <p>Default: <code>[512]</code> Inputs: <code>[0 ... +Inf]</code> </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-stdc%2B%2B/","title":"C++ Standard Environment","text":"<p>lbuild module: <code>modm:stdc++</code></p> <p>Refines the C++ language to make it easier to use on embedded targets. Depending on the module options, the compiler options are appended with either:</p> <ul> <li><code>-fno-exceptions</code>: no C++ exceptions.</li> <li><code>-fno-rtti</code>: no C++ run-time type information.</li> <li><code>-fno-threadsafe-statics</code>: no protection of static variable initialization.</li> </ul> <p>or:</p> <ul> <li><code>-fexceptions</code>: with C++ exceptions.</li> <li><code>-frtti</code>: with C++ run-time type information.</li> </ul> <p>The <code>std::atomic</code> interface is implemented for the AVR and Cortex-M devices.</p>"},{"location":"reference/module/modm-stdc%2B%2B/#avr","title":"AVR","text":"<p>A partial port of GCC libstdc++ is provided: See https://github.com/modm-io/avr-libstdcpp.</p>"},{"location":"reference/module/modm-stdc%2B%2B/#options","title":"Options","text":""},{"location":"reference/module/modm-stdc%2B%2B/#assert_on_exception","title":"assert_on_exception","text":"<p>Assert on exception in stdlib. Set to False to save flash.</p> <p>This option is only available for avr.</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-stdc%2B%2B/#exceptions","title":"exceptions","text":"<p>C++ Exceptions</p> <p>Enables the full use of C++ exception handling.</p> <p>Check your code size</p> <p>The inclusion of the stack unwind tables will increase your code size quite a bit. Check whether your target has enough memory for this!</p> <p>This option is only available for rp, sam, stm32.</p> <p>Default: <code>no</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-stdc%2B%2B/#rtti","title":"rtti","text":"<p>C++ Runtime Type Information</p> <p>Enables the full use of C++ runtime type information.</p> <p>Check your code size</p> <p>The inclusion of the RTTI information will increase your code size quite a bit. Check whether your target has enough memory for this!</p> <p>This option is only available for rp, sam, stm32.</p> <p>Default: <code>no</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-stdc%2B%2B/#safe_statics","title":"safe_statics","text":"<p>C++ Safe Statics Initialization</p> <p>Enables safe initialization of statics inside functions and interrupts. In case of recursive initialization the debug assertion <code>stat.rec</code> is raised.</p> <p>Further reading on this topic:</p> <ul> <li>C++ ABI for the ARM Architecture</li> <li>Adventures in Systems Programming: C++ Local Statics</li> <li>C++11 thread-safe static object initialization</li> </ul> <p>This option is only available for avr, rp, sam, stm32.</p> <p>Default: <code>yes</code> Inputs: <code>[yes, no]</code> </p>"},{"location":"reference/module/modm-stdc%2B%2B/#dependencies","title":"Dependencies","text":"<p> modm:stdc++ modm_stdc++ modm: stdc++ modm_architecture_assert modm: architecture: assert modm_stdc++-&gt;modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_stdc++-&gt;modm_architecture_atomic modm_stdc modm: stdc modm_stdc++-&gt;modm_stdc </p>"},{"location":"reference/module/modm-stdc/","title":"C Standard Environment","text":"<p>lbuild module: <code>modm:stdc</code></p> <p>Refines the C language to make it easier to use on embedded targets.</p>"},{"location":"reference/module/modm-stdc/#arm-cortex-m","title":"ARM Cortex-M","text":"<p>Additional compiler options:</p> <ul> <li><code>--specs=nano.specs</code>: use Newlib Nano (when not using exceptions).</li> <li><code>--specs=nosys.specs</code>: No additional C library features are implemented.</li> </ul>"},{"location":"reference/module/modm-stdc/#dependencies","title":"Dependencies","text":"<p> modm:stdc modm_stdc modm: stdc modm_architecture_assert modm: architecture: assert modm_stdc-&gt;modm_architecture_assert </p>"},{"location":"reference/module/modm-tinyusb-device-audio/","title":"Device class AUDIO","text":"<p>lbuild module: <code>modm:tinyusb:device:audio</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-device-audio/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:audio modm_tinyusb_device_audio modm: tinyusb: device: audio modm_tinyusb modm: tinyusb modm_tinyusb_device_audio-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-bth/","title":"Device class BTH","text":"<p>lbuild module: <code>modm:tinyusb:device:bth</code></p> <p>Configuration options:</p> <ul> <li><code>CFG_TUD_BTH_ISO_ALT_COUNT</code> = [undef] modm default: 1</li> </ul>"},{"location":"reference/module/modm-tinyusb-device-bth/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:bth modm_tinyusb_device_bth modm: tinyusb: device: bth modm_tinyusb modm: tinyusb modm_tinyusb_device_bth-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-cdc/","title":"Device class CDC","text":"<p>lbuild module: <code>modm:tinyusb:device:cdc</code></p> <p>Configuration options:</p> <ul> <li><code>CFG_TUD_CDC_EP_BUFSIZE</code> = 64/512 (fs/hs)</li> <li><code>CFG_TUD_CDC_RX_BUFSIZE</code> = [undef] modm default: 512</li> <li><code>CFG_TUD_CDC_TX_BUFSIZE</code> = [undef] modm default: 512</li> </ul>"},{"location":"reference/module/modm-tinyusb-device-cdc/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:cdc modm_tinyusb_device_cdc modm: tinyusb: device: cdc modm_architecture_uart modm: architecture: uart modm_tinyusb_device_cdc-&gt;modm_architecture_uart modm_tinyusb modm: tinyusb modm_tinyusb_device_cdc-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-dfu/","title":"Device class DFU","text":"<p>lbuild module: <code>modm:tinyusb:device:dfu</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-device-dfu/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:dfu modm_tinyusb_device_dfu modm: tinyusb: device: dfu modm_tinyusb modm: tinyusb modm_tinyusb_device_dfu-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-dfu_rt/","title":"Device class DFU_RT","text":"<p>lbuild module: <code>modm:tinyusb:device:dfu_rt</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-device-dfu_rt/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:dfu_rt modm_tinyusb_device_dfu_rt modm: tinyusb: device: dfu_rt modm_tinyusb modm: tinyusb modm_tinyusb_device_dfu_rt-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-ecm_rndis/","title":"Device class ECM_RNDIS","text":"<p>lbuild module: <code>modm:tinyusb:device:ecm_rndis</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-device-ecm_rndis/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:ecm_rndis modm_tinyusb_device_ecm_rndis modm: tinyusb: device: ecm_rndis modm_tinyusb modm: tinyusb modm_tinyusb_device_ecm_rndis-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-hid/","title":"Device class HID","text":"<p>lbuild module: <code>modm:tinyusb:device:hid</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-device-hid/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:hid modm_tinyusb_device_hid modm: tinyusb: device: hid modm_tinyusb modm: tinyusb modm_tinyusb_device_hid-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-midi/","title":"Device class MIDI","text":"<p>lbuild module: <code>modm:tinyusb:device:midi</code></p> <p>Configuration options:</p> <ul> <li><code>CFG_TUD_MIDI_EP_BUFSIZE</code> = 64/512 (fs/hs)</li> <li><code>CFG_TUD_MIDI_RX_BUFSIZE</code> = [undef] modm default: 64/512 (fs/hs)</li> <li><code>CFG_TUD_MIDI_TX_BUFSIZE</code> = [undef] modm default: 64/512 (fs/hs)</li> </ul>"},{"location":"reference/module/modm-tinyusb-device-midi/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:midi modm_tinyusb_device_midi modm: tinyusb: device: midi modm_tinyusb modm: tinyusb modm_tinyusb_device_midi-&gt;modm_tinyusb modm_tinyusb_device_audio modm: tinyusb: device: audio modm_tinyusb_device_midi-&gt;modm_tinyusb_device_audio </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-msc/","title":"Device class MSC","text":"<p>lbuild module: <code>modm:tinyusb:device:msc</code></p> <p>Configuration options:</p> <ul> <li><code>CFG_TUD_MSC_EP_BUFSIZE</code> = [undef] modm default: 512</li> </ul>"},{"location":"reference/module/modm-tinyusb-device-msc/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:msc modm_tinyusb_device_msc modm: tinyusb: device: msc modm_tinyusb modm: tinyusb modm_tinyusb_device_msc-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-ncm/","title":"Device class NCM","text":"<p>lbuild module: <code>modm:tinyusb:device:ncm</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-device-ncm/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:ncm modm_tinyusb_device_ncm modm: tinyusb: device: ncm modm_tinyusb modm: tinyusb modm_tinyusb_device_ncm-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-usbtmc/","title":"Device class USBTMC","text":"<p>lbuild module: <code>modm:tinyusb:device:usbtmc</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-device-usbtmc/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:usbtmc modm_tinyusb_device_usbtmc modm: tinyusb: device: usbtmc modm_tinyusb modm: tinyusb modm_tinyusb_device_usbtmc-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-vendor/","title":"Device class VENDOR","text":"<p>lbuild module: <code>modm:tinyusb:device:vendor</code></p> <p>Configuration options:</p> <ul> <li><code>CFG_TUD_VENDOR_EPSIZE</code> = 64</li> <li><code>CFG_TUD_VENDOR_RX_BUFSIZE</code> = [undef] modm default: 64/512 (fs/hs)</li> <li><code>CFG_TUD_VENDOR_TX_BUFSIZE</code> = [undef] modm default: 64/512 (fs/hs)</li> </ul>"},{"location":"reference/module/modm-tinyusb-device-vendor/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:vendor modm_tinyusb_device_vendor modm: tinyusb: device: vendor modm_tinyusb modm: tinyusb modm_tinyusb_device_vendor-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device-video/","title":"Device class VIDEO","text":"<p>lbuild module: <code>modm:tinyusb:device:video</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-device-video/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device:video modm_tinyusb_device_video modm: tinyusb: device: video modm_tinyusb modm: tinyusb modm_tinyusb_device_video-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-device/","title":"TinyUSB in Device Mode","text":"<p>lbuild module: <code>modm:tinyusb:device</code></p> <p>Configuration options:</p> <ul> <li><code>CFG_TUD_ENDPOINT0_SIZE</code> = 64</li> <li><code>CFG_TUD_EP_MAX</code> = 9</li> <li><code>CFG_TUD_TASK_QUEUE_SZ</code> = 16</li> </ul>"},{"location":"reference/module/modm-tinyusb-device/#options","title":"Options","text":""},{"location":"reference/module/modm-tinyusb-device/#port","title":"port","text":"<p>USB Port selection</p> <p>This option is only available for stm32{f2,f4,f7,h7}.</p> <p>Default: <code>fs</code> Inputs: <code>[fs, hs]</code> Input Dependency: <code>fs -&gt; modm:platform:usb:fs</code> Input Dependency: <code>hs -&gt; modm:platform:usb:hs</code> </p>"},{"location":"reference/module/modm-tinyusb-device/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:device modm_tinyusb_device modm: tinyusb: device modm_platform_usb_fs modm: platform: usb: fs modm_tinyusb_device-&gt;modm_platform_usb_fs modm_platform_usb_hs modm: platform: usb: hs modm_tinyusb_device-&gt;modm_platform_usb_hs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-host-cdc/","title":"Host class CDC","text":"<p>lbuild module: <code>modm:tinyusb:host:cdc</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-host-cdc/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:host:cdc modm_tinyusb_host_cdc modm: tinyusb: host: cdc modm_tinyusb modm: tinyusb modm_tinyusb_host_cdc-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-host-cdc_rndis/","title":"Host class CDC_RNDIS","text":"<p>lbuild module: <code>modm:tinyusb:host:cdc_rndis</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-host-cdc_rndis/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:host:cdc_rndis modm_tinyusb_host_cdc_rndis modm: tinyusb: host: cdc_rndis modm_tinyusb modm: tinyusb modm_tinyusb_host_cdc_rndis-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-host-hid/","title":"Host class HID","text":"<p>lbuild module: <code>modm:tinyusb:host:hid</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-host-hid/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:host:hid modm_tinyusb_host_hid modm: tinyusb: host: hid modm_tinyusb modm: tinyusb modm_tinyusb_host_hid-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-host-msc/","title":"Host class MSC","text":"<p>lbuild module: <code>modm:tinyusb:host:msc</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-host-msc/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:host:msc modm_tinyusb_host_msc modm: tinyusb: host: msc modm_tinyusb modm: tinyusb modm_tinyusb_host_msc-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-host-vendor/","title":"Host class VENDOR","text":"<p>lbuild module: <code>modm:tinyusb:host:vendor</code></p> <p>Please consult the TinyUSB docs for configuration options.</p>"},{"location":"reference/module/modm-tinyusb-host-vendor/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:host:vendor modm_tinyusb_host_vendor modm: tinyusb: host: vendor modm_tinyusb modm: tinyusb modm_tinyusb_host_vendor-&gt;modm_tinyusb </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb-host/","title":"TinyUSB in Host Mode","text":"<p>lbuild module: <code>modm:tinyusb:host</code></p> <p>Configuration options:</p> <ul> <li><code>CFG_TUH_EP_MAX</code> = 9</li> <li><code>CFG_TUH_TASK_QUEUE_SZ</code> = 16</li> <li><code>CFG_TUH_ENUMERATION_BUFSZIE</code> [sic] = 256</li> </ul> <p>This module is only available for samg5x, stm32{f1,f2,f4,f7,h7,l4,u5}.</p>"},{"location":"reference/module/modm-tinyusb-host/#options","title":"Options","text":""},{"location":"reference/module/modm-tinyusb-host/#port","title":"port","text":"<p>USB Port selection</p> <p>This option is only available for stm32{f2,f4,f7,h7}.</p> <p>Default: <code>hs</code> Inputs: <code>[fs, hs]</code> Input Dependency: <code>fs -&gt; modm:platform:usb:fs</code> Input Dependency: <code>hs -&gt; modm:platform:usb:hs</code> </p>"},{"location":"reference/module/modm-tinyusb-host/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb:host modm_tinyusb_host modm: tinyusb: host modm_platform_usb_fs modm: platform: usb: fs modm_tinyusb_host-&gt;modm_platform_usb_fs modm_platform_usb_hs modm: platform: usb: hs modm_tinyusb_host-&gt;modm_platform_usb_hs </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tinyusb/","title":"TinyUSB","text":"<p>lbuild module: <code>modm:tinyusb</code></p> <p>TinyUSB is an open-source cross-platform USB Host/Device stack for embedded system, designed to be memory-safe with no dynamic allocation and thread-safe with all interrupt events are deferred then handled in the non-ISR task function.</p> <p>This module provides a autogenerated port for TinyUSB, which includes the correct interrupt mapping, a serial number based on the UID of the device, as well as remapping the assertions of TinyUSB.</p>"},{"location":"reference/module/modm-tinyusb/#full-vs-high-speed-ports","title":"Full vs High Speed Ports","text":"<p>Some microcontroller have USB peripherals capable of using external high speed transceivers via an ULPI interface. TinyUSB can be configured to run device and host classes on one port or both on separate ports at the same time. You can configure this via these module options:</p> <pre><code>&lt;option name=\"modm:tinyusb:device:port\"&gt;fs&lt;/option&gt;\n&lt;option name=\"modm:tinyusb:host:port\"&gt;hs&lt;/option&gt;\n</code></pre> <p>However, the high speed capable port can also run in full speed mode, in which case you must configure TinyUSB to not use the ULPI interface:</p> <pre><code>&lt;option name=\"modm:tinyusb:max-speed\"&gt;full&lt;/option&gt;\n</code></pre>"},{"location":"reference/module/modm-tinyusb/#initializing-usb","title":"Initializing USB","text":"<p>The <code>modm:platform:usb</code> module provides the correct way of initializing the USB peripheral, however, you must connect the right signals too:</p> <pre><code>// USB is timing-sensitive, so prioritize the IRQs accordingly\nUsb::initialize&lt;SystemClock&gt;(/*priority=*/3);\n\n// For Device-Only USB implementations, this is enough\nUsb::connect&lt;GpioA11::Dm, GpioA12::Dp&gt;();\n\n// But for On-The-Go (OTG) USB implementations, you need more:\nUsb::connect&lt;GpioA11::Dm, GpioA12::Dp, GpioA10::Id&gt;();\n\n// For high speed USB ports, you need to connect all ULPI signals:\nUsbHs::connect&lt;\n        GpioA5::Ulpick, GpioC0::Ulpistp, GpioC2::Ulpidir, GpioH4::Ulpinxt,\n        GpioA3::Ulpid0, GpioB0::Ulpid1, GpioB1::Ulpid2, GpioB10::Ulpid3,\n        GpioB11::Ulpid4, GpioB12::Ulpid5, GpioB13::Ulpid6, GpioB5::Ulpid7&gt;();\n</code></pre> <p>Note that depending on your specific hardware setup, you may need to fiddle around to find the right VBus sensing mechanism. Please look at the TinyUSB board definitions and examples for inspiration.</p> <pre><code>// Enable hardware Vbus sensing on GpioA9 (this can be tricky to get right!)\nUSB_OTG_FS-&gt;GCCFG |= USB_OTG_GCCFG_VBDEN;\n</code></pre> <p>USB shares resources with CAN</p> <p>Note that on STM32F1 and STM32F3 the USB interrupts and RAM are shared with CAN, thus there are conflicts in IRQ definitions as well as resource limitions in hardware. On some STM32F3, the USB IRQs can be remapped, this is done automatically by our port.</p>"},{"location":"reference/module/modm-tinyusb/#autogeneration-of-usb-descriptors","title":"Autogeneration of USB Descriptors","text":"<p>You can select the device classes you want to use via the <code>modm:tinyusb:config</code> list option:</p> <ul> <li><code>device.cdc</code>: Serial connection (uses two endpoints!)</li> <li><code>device.msc</code>: Mass Storage class.</li> <li><code>device.midi</code>: MIDI device.</li> <li><code>device.vendor</code>: WebUSB device.</li> <li><code>device.dfu_rt</code>: DFU runtime.</li> </ul> <p>Note that you can add multiple devices at the same time, as long as there are enough endpoints and USB RAM available:</p> <pre><code>&lt;!-- Using the CDC and MSC classes together --&gt;\n&lt;option name=\"modm:tinyusb:config\"&gt;device.cdc,device.msc&lt;/option&gt;\n&lt;!-- Using two CDC ports! --&gt;\n&lt;option name=\"modm:tinyusb:config\"&gt;device.cdc,device.cdc&lt;/option&gt;\n</code></pre> <p>modm will generate the USB descriptors automatically for the set of device classes you've chosen. You can then implement your app via TinyUSB callbacks.</p>"},{"location":"reference/module/modm-tinyusb/#partial-customization","title":"Partial Customization","text":"<p>You can overwrite or add configurations via a <code>&lt;tusb_config_local.h&gt;</code> file, which will be included at the very beginning of the modm-generated <code>tusb_config.h</code> file:</p> <pre><code>// Overwrite the modm default\n#define CFG_TUD_CDC_TX_BUFSIZE 1024\n// Overwrite the TinyUSB default\n#define CFG_TUD_CDC_EP_BUFSIZE 1024\n</code></pre> <p>You can also replace the following weakly linked descriptor functions and objects in case you want to update only a small part of the autogenerated descriptors:</p> <ul> <li><code>const uint8_t* tud_descriptor_device_cb(void)</code> to replace the autogenerated   <code>tusb_desc_device_t</code> descriptor.</li> <li><code>const uint8_t* tud_descriptor_configuration_cb(uint8_t index)</code> to replace   the endpoint descriptions.</li> <li><code>const char* tud_string_desc_arr[]</code> to replace the string descriptors.</li> <li><code>const uint16_t* tud_descriptor_string_cb(uint8_t index, uint16_t langid)</code></li> </ul>"},{"location":"reference/module/modm-tinyusb/#manual-usb-descriptors","title":"Manual USB Descriptors","text":"<p>If you leave the <code>modm:tinyusb:config</code> option empty, no descriptors are generated, so you can implement them yourself. Note that you must also manually depend on the device classes you want to implement:</p> <pre><code>&lt;module&gt;modm:tinyusb:device:audio&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:bth&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:cdc&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:dfu&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:dfu_rt&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:ecm_rndis&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:hid&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:midi&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:msc&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:ncm&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:usbtmc&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:vendor&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:device:video&lt;/module&gt;\n</code></pre> <p>Some of these classes require a lot of configuration that you must provide via the <code>&lt;tusb_config_local.h&gt;</code> file. Please consult the TinyUSB documentation and examples for their purpose.</p>"},{"location":"reference/module/modm-tinyusb/#host-classes","title":"Host classes","text":"<p>To use the host classes you must depend on them manually as modm does not provide a configuration option for them:</p> <pre><code>&lt;module&gt;modm:tinyusb:host:cdc&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:host:cdc_rndis&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:host:hid&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:host:msc&lt;/module&gt;\n&lt;module&gt;modm:tinyusb:host:vendor&lt;/module&gt;\n</code></pre>"},{"location":"reference/module/modm-tinyusb/#debugging-tinyusb","title":"Debugging TinyUSB","text":"<p>Since we've made it so easy to add multiple device classes, it's also easy to run out of endpoints or RAM. Therefore we reroute TinyUSBs assertions to <code>modm_assert</code>, so make sure you have implemented the <code>modm_abandon</code> handler! See the <code>modm:architecture:assert</code> module for details.</p> <p>A TinyUSB assertion failure in release mode is fairly cryptic:</p> <pre><code>Assertion 'tu' failed!\nAbandoning...\n</code></pre> <p>If you run this again in debug mode, you'll note a much more detailed assertion description. In this example you've exhaused the number of endpoints:</p> <pre><code>Assertion 'tu' failed!\n  modm/ext/tinyusb/portable/st/synopsys/dcd_synopsys.c:524 -&gt; \"epnum &lt; 4U\"\nAbandoning...\n</code></pre> <p>To trace the TinyUSB core, you can add <code>CFG_TUSB_DEBUG=3</code> to your CPP flags and the output will be forwarded to <code>MODM_LOG_DEBUG</code>.</p> <pre><code>&lt;collect name=\"modm:build:cppdefines\"&gt;CFG_TUSB_DEBUG=3&lt;/collect&gt;\n</code></pre> <p>This module is only available for rp, sam{d1x/d2x/dax,d5x/e5x,g5x}, stm32{c0,f0,f1,f2,f3,f4,f7,g4,h7,l0,l1,l4,l5,u5}.</p>"},{"location":"reference/module/modm-tinyusb/#options","title":"Options","text":""},{"location":"reference/module/modm-tinyusb/#config","title":"config","text":"<p>Endpoint Configuration</p> <p>Default: <code>[]</code> Inputs: <code>[device.cdc, device.dfu_rt, device.midi, device.msc, device.vendor]</code> Input Dependency: <code>device.cdc -&gt; modm:tinyusb:device:cdc</code> Input Dependency: <code>device.dfu_rt -&gt; modm:tinyusb:device:dfu_rt</code> Input Dependency: <code>device.midi -&gt; modm:tinyusb:device:midi</code> Input Dependency: <code>device.msc -&gt; modm:tinyusb:device:msc</code> Input Dependency: <code>device.vendor -&gt; modm:tinyusb:device:vendor</code> </p>"},{"location":"reference/module/modm-tinyusb/#max-speed","title":"max-speed","text":"<p>Maximum HS port speed</p> <p>This option is only available for stm32{f2,f4,f7,h7,u5}.</p> <p>Default: <code>high</code> Inputs: <code>[full, high]</code> </p>"},{"location":"reference/module/modm-tinyusb/#dependencies","title":"Dependencies","text":"<p> modm:tinyusb modm_tinyusb modm: tinyusb modm_architecture_atomic modm: architecture: atomic modm_tinyusb-&gt;modm_architecture_atomic modm_architecture_interrupt modm: architecture: interrupt modm_tinyusb-&gt;modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_tinyusb-&gt;modm_cmsis_device modm_platform_usb modm: platform: usb modm_tinyusb-&gt;modm_platform_usb modm_tinyusb_device_cdc modm: tinyusb: device: cdc modm_tinyusb-&gt;modm_tinyusb_device_cdc modm_tinyusb_device_dfu_rt modm: tinyusb: device: dfu_rt modm_tinyusb-&gt;modm_tinyusb_device_dfu_rt modm_tinyusb_device_midi modm: tinyusb: device: midi modm_tinyusb-&gt;modm_tinyusb_device_midi modm_tinyusb_device_msc modm: tinyusb: device: msc modm_tinyusb-&gt;modm_tinyusb_device_msc modm_tinyusb_device_vendor modm: tinyusb: device: vendor modm_tinyusb-&gt;modm_tinyusb_device_vendor </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-tlsf/","title":"TLSF Allocator","text":"<p>lbuild module: <code>modm:tlsf</code></p> <p>Two-Level Segregated Fit memory allocator implementation. Written by Matthew Conte (matt@baisoku.org). Released under the BSD license. https://github.com/mattconte/tlsf</p>"},{"location":"reference/module/modm-tlsf/#features","title":"Features","text":"<ul> <li>O(1) cost for malloc, free, realloc, memalign</li> <li>Extremely low overhead per allocation (4 bytes)</li> <li>Low overhead per TLSF management of pools (~3kB)</li> <li>Low fragmentation</li> <li>Compiles to only a few kB of code and data</li> <li>Support for adding and removing memory pool regions on the fly</li> </ul>"},{"location":"reference/module/modm-tlsf/#caveats","title":"Caveats","text":"<ul> <li>Currently, assumes architecture can make 4-byte aligned accesses</li> <li>Not designed to be thread safe; the user must provide this</li> </ul>"},{"location":"reference/module/modm-tlsf/#notes","title":"Notes","text":"<p>This code was based on the TLSF 1.4 spec and documentation found at:</p> <pre><code>http://rtportal.upv.es/rtmalloc/allocators/tlsf/index.shtml\n</code></pre> <p>It also leverages the TLSF 2.0 improvement to shrink the per-block overhead from 8 to 4 bytes.</p>"},{"location":"reference/module/modm-tlsf/#history","title":"History","text":"<p>2016/04/10 - v3.1   * Code moved to github   * tlsfbits.h rolled into tlsf.c   * License changed to BSD</p> <p>2014/02/08 - v3.0   * This version is based on improvements from 3DInteractive GmbH   * Interface changed to allow more than one memory pool   * Separated pool handling from control structure (adding, removing, debugging)   * Control structure and pools can still be constructed in the same memory block   * Memory blocks for control structure and pools are checked for alignment   * Added functions to retrieve control structure size, alignment size, min and max block size, overhead of pool structure, and overhead of a single allocation   * Minimal Pool size is tlsf_block_size_min() + tlsf_pool_overhead()   * Pool must be empty when it is removed, in order to allow O(1) removal</p> <p>2011/10/20 - v2.0   * 64-bit support   * More compiler intrinsics for ffs/fls   * ffs/fls verification during TLSF creation in debug builds</p> <p>2008/04/04 - v1.9   * Add tlsf_heap_check, a heap integrity check   * Support a predefined tlsf_assert macro   * Fix realloc case where block should shrink; if adjacent block is in use, execution would go down the slow path</p> <p>2007/02/08 - v1.8   * Fix for unnecessary reallocation in tlsf_realloc</p> <p>2007/02/03 - v1.7   * tlsf_heap_walk takes a callback   * tlsf_realloc now returns NULL on failure   * tlsf_memalign optimization for 4-byte alignment   * Usage of size_t where appropriate</p> <p>2006/11/21 - v1.6   * ffs/fls broken out into tlsfbits.h   * tlsf_overhead queries per-pool overhead</p> <p>2006/11/07 - v1.5   * Smart realloc implementation   * Smart memalign implementation</p> <p>2006/10/11 - v1.4   * Add some ffs/fls implementations   * Minor code footprint reduction</p> <p>2006/09/14 - v1.3   * Profiling indicates heavy use of blocks of size 1-128, so implement small block handling   * Reduce pool overhead by about 1kb   * Reduce minimum block size from 32 to 12 bytes   * Realloc bug fix</p> <p>2006/09/09 - v1.2   * Add tlsf_block_size   * Static assertion mechanism for invariants   * Minor bugfixes</p> <p>2006/09/01 - v1.1   * Add tlsf_realloc   * Add tlsf_walk_heap</p> <p>2006/08/25 - v1.0   * First release</p> <p>This module is only available for rp, sam, stm32.</p>"},{"location":"reference/module/modm-tlsf/#options","title":"Options","text":""},{"location":"reference/module/modm-tlsf/#minimum_pool_size","title":"minimum_pool_size","text":"<p>Minimum pool size in byte</p> <p>Default: <code>1024Ki (1048576)</code> stm32h7 Default: <code>10Ki (10240)</code> stm32{f1,l1} Default: <code>112Ki (114688)</code> stm32g491ret6z Default: <code>128Ki (131072)</code> samd5x/e5x, stm32{f2,f4,l4} Default: <code>12Ki (12288)</code> stm32{c0,f3} Default: <code>144Ki (147456)</code> stm32g0 Default: <code>160Ki (163840)</code> samg5x, stm32l4 Default: <code>16Ki (16384)</code> samd1x/d2x/dax, stm32{f0,f3,l1} Default: <code>18Ki (18432)</code> stm32g0 Default: <code>192Ki (196608)</code> samd5x/e5x, stm32f4 Default: <code>20Ki (20480)</code> stm32{f1,l0} Default: <code>22Ki (22528)</code> stm32g4 Default: <code>2496Ki (2555904)</code> stm32u5 Default: <code>24Ki (24576)</code> stm32{c0,f1} Default: <code>256Ki (262144)</code> sam{d5x/e5x,e7x/s7x/v7x}, stm32{f4,f7,l5,u5} Default: <code>264Ki (270336)</code> rp2040 Default: <code>2Ki (2048)</code> stm32l0 Default: <code>3008Ki (3080192)</code> stm32u5 Default: <code>30Ki (30720)</code> stm32c0 Default: <code>320Ki (327680)</code> stm32{f4,h7,l4} Default: <code>32Ki (32768)</code> samd1x/d2x/dax, stm32{f0,f1,f3,f4,l1} Default: <code>36Ki (36864)</code> stm32{c0,g0} Default: <code>384Ki (393216)</code> same7x/s7x/v7x, stm32{f7,h7} Default: <code>40Ki (40960)</code> stm32{f3,l4} Default: <code>48Ki (49152)</code> stm32{f1,l1} Default: <code>4Ki (4096)</code> samd1x/d2x/dax, stm32{f0,f1,l1} Default: <code>512Ki (524288)</code> stm32{f7,h7} Default: <code>640Ki (655360)</code> stm32l4 Default: <code>64Ki (65536)</code> stm32{f1,f2,f3,f4,l4} Default: <code>6Ki (6144)</code> stm32{c0,f0,f1} Default: <code>768Ki (786432)</code> stm32u5 Default: <code>80Ki (81920)</code> stm32l1 Default: <code>8Ki (8192)</code> samd1x/d2x/dax, stm32{f0,f1,g0,l0,l1} Default: <code>96Ki (98304)</code> stm32{f2,f4,g4} Inputs: <code>[4Ki .. 1024Ki .. 512Mi]</code> stm32h7 Inputs: <code>[4Ki .. 10Ki .. 512Mi]</code> stm32{f1,l1} Inputs: <code>[4Ki .. 112Ki .. 512Mi]</code> stm32g491ret6z Inputs: <code>[4Ki .. 128Ki .. 512Mi]</code> samd5x/e5x, stm32{f2,f4,l4} Inputs: <code>[4Ki .. 12Ki .. 512Mi]</code> stm32{c0,f3} Inputs: <code>[4Ki .. 144Ki .. 512Mi]</code> stm32g0 Inputs: <code>[4Ki .. 160Ki .. 512Mi]</code> samg5x, stm32l4 Inputs: <code>[4Ki .. 16Ki .. 512Mi]</code> samd1x/d2x/dax, stm32{f0,f3,l1} Inputs: <code>[4Ki .. 18Ki .. 512Mi]</code> stm32g0 Inputs: <code>[4Ki .. 192Ki .. 512Mi]</code> samd5x/e5x, stm32f4 Inputs: <code>[4Ki .. 20Ki .. 512Mi]</code> stm32{f1,l0} Inputs: <code>[4Ki .. 22Ki .. 512Mi]</code> stm32g4 Inputs: <code>[4Ki .. 2496Ki .. 512Mi]</code> stm32u5 Inputs: <code>[4Ki .. 24Ki .. 512Mi]</code> stm32{c0,f1} Inputs: <code>[4Ki .. 256Ki .. 512Mi]</code> sam{d5x/e5x,e7x/s7x/v7x}, stm32{f4,f7,l5,u5} Inputs: <code>[4Ki .. 264Ki .. 512Mi]</code> rp2040 Inputs: <code>[4Ki .. 2Ki .. 512Mi]</code> stm32l0 Inputs: <code>[4Ki .. 3008Ki .. 512Mi]</code> stm32u5 Inputs: <code>[4Ki .. 30Ki .. 512Mi]</code> stm32c0 Inputs: <code>[4Ki .. 320Ki .. 512Mi]</code> stm32{f4,h7,l4} Inputs: <code>[4Ki .. 32Ki .. 512Mi]</code> samd1x/d2x/dax, stm32{f0,f1,f3,f4,l1} Inputs: <code>[4Ki .. 36Ki .. 512Mi]</code> stm32{c0,g0} Inputs: <code>[4Ki .. 384Ki .. 512Mi]</code> same7x/s7x/v7x, stm32{f7,h7} Inputs: <code>[4Ki .. 40Ki .. 512Mi]</code> stm32{f3,l4} Inputs: <code>[4Ki .. 48Ki .. 512Mi]</code> stm32{f1,l1} Inputs: <code>[4Ki .. 512Ki .. 512Mi]</code> stm32{f7,h7} Inputs: <code>[4Ki .. 640Ki .. 512Mi]</code> stm32l4 Inputs: <code>[4Ki .. 64Ki .. 512Mi]</code> stm32{f1,f2,f3,f4,l4} Inputs: <code>[4Ki .. 6Ki .. 512Mi]</code> stm32{c0,f0,f1} Inputs: <code>[4Ki .. 768Ki .. 512Mi]</code> stm32u5 Inputs: <code>[4Ki .. 80Ki .. 512Mi]</code> stm32l1 Inputs: <code>[4Ki .. 8Ki .. 512Mi]</code> samd1x/d2x/dax, stm32{f0,f1,g0,l0,l1} Inputs: <code>[4Ki .. 96Ki .. 512Mi]</code> stm32{f2,f4,g4} Inputs: <code>[4Ki ... 512Mi]</code> samd1x/d2x/dax, stm32{f0,f1,l1} </p>"},{"location":"reference/module/modm-tlsf/#subdivisions","title":"subdivisions","text":"<p>Number of subdivisions per memory pool</p> <p>Default: <code>16</code> Inputs: <code>[16, 32]</code> </p> <p>Limited availability: Check with 'lbuild discover' if this module is available for your target!</p>"},{"location":"reference/module/modm-ui-animation/","title":"Animators","text":"<p>lbuild module: <code>modm:ui:animation</code></p> <p>Various classes for animating values.</p>"},{"location":"reference/module/modm-ui-animation/#dependencies","title":"Dependencies","text":"<p> modm:ui:animation modm_ui_animation modm: ui: animation modm_architecture_clock modm: architecture: clock modm_ui_animation-&gt;modm_architecture_clock modm_math_utils modm: math: utils modm_ui_animation-&gt;modm_math_utils modm_processing_timer modm: processing: timer modm_ui_animation-&gt;modm_processing_timer </p>"},{"location":"reference/module/modm-ui-button/","title":"Debouncing Buttons","text":"<p>lbuild module: <code>modm:ui:button</code></p> <p>The <code>modm::ButtonGroup</code> class is able to debounce eight buttons at the same time. The buttons have to be low-active. If this isn't the case invert their signal before passing it to the <code>update()</code> method.</p> <p>The <code>update()</code> method needs to be called periodically for example every 10ms. Preferred in a timer interrupt function.</p> <p>The detection for long or repeated presses works only correctly for one key at a time. This constraint only applies to buttons listed in the <code>mask</code> variable.</p>"},{"location":"reference/module/modm-ui-button/#mode-1","title":"Mode 1","text":"<pre><code>                 Timeline ----&gt;\n                      __      _________________      __\ngetState()       ____/  \\____/                 \\____/  \\____\nisPressed()      ----X-------X----------------------X-------\nisRepeated()     --------------------X--X--X--X-------------\nisReleased()     -------X----------------------X-------X----\n                             |       |__|__|\n                             |_______| \\ /\n                                  \\    interval\n                                  timeout\n</code></pre>"},{"location":"reference/module/modm-ui-button/#mode-2","title":"Mode 2","text":"<pre><code>                 Timeline ----&gt;\n                      __      _________________      __\ngetState()       ____/  \\____/                 \\____/  \\____\nisPressedShort() -------X------------------------------X----\nisPressedLong()  --------------------X----------------------\nisReleased()     -------X----------------------X-------X----\n</code></pre>"},{"location":"reference/module/modm-ui-button/#naming-buttons","title":"Naming Buttons","text":"<p>To name buttons, declare an enum with a bitmask for each button:</p> <pre><code>#include &lt;modm/math/utils/bit_constants.hpp&gt;\n\nenum ButtonIdentifier\n{\n    NONE = 0x00,\n    BUTTON0 = modm::Bit0,\n    BUTTON1 = modm::Bit1,\n    BUTTON2 = modm::Bit2,\n    BUTTON3 = modm::Bit3,\n    BUTTON4 = modm::Bit4,\n    BUTTON5 = modm::Bit5,\n    BUTTON6 = modm::Bit6,\n    BUTTON7 = modm::Bit7,\n    ALL = 0xFF,\n};\n</code></pre> <p>Pass a <code>ButtonIdentifier</code> to any of <code>ButtonGroup::is**()</code> like so</p> <pre><code>if(buttongroup_instance.isPressed(BUTTON0)) {\n    // Do stuff\n}\n</code></pre> <p>This implementation is based on the C functions written by Peter Dannegger (see http://www.mikrocontroller.net/topic/48465).</p>"},{"location":"reference/module/modm-ui-button/#dependencies","title":"Dependencies","text":"<p> modm:ui:button modm_ui_button modm: ui: button modm_architecture_atomic modm: architecture: atomic modm_ui_button-&gt;modm_architecture_atomic </p>"},{"location":"reference/module/modm-ui-color/","title":"Color","text":"<p>lbuild module: <code>modm:ui:color</code></p> <p>Color containers and converters in various formats: RGB, HSV, Brightness, Rgb565</p>"},{"location":"reference/module/modm-ui-color/#dependencies","title":"Dependencies","text":"<p> modm:ui:color modm_ui_color modm: ui: color modm_math_utils modm: math: utils modm_ui_color-&gt;modm_math_utils </p>"},{"location":"reference/module/modm-ui-display/","title":"Display Graphics","text":"<p>lbuild module: <code>modm:ui:display</code></p> <p>Code for writing and drawing on character and graphical displays.</p>"},{"location":"reference/module/modm-ui-display/#coordinate-system","title":"Coordinate System","text":"<pre><code>(0, 0)\n   +---------------------+\n   |  ----&gt; X            |\n   | |                   |\n   | |                   |\n   | V Y                 |\n   |                     |\n   |                     |\n   |                     |\n   +---------------------+\n               e.g. (127, 63)\n</code></pre> <p>The size (width and height) of a graphics primitive always correspond to its mathematical model, ignoring the rendered with. As everything is drawn one pixel wide, the pixels will be rendered to the right and below the mathematically defined points.</p>"},{"location":"reference/module/modm-ui-display/#dependencies","title":"Dependencies","text":"<p> modm:ui:display modm_ui_display modm: ui: display modm_architecture_accessor modm: architecture: accessor modm_ui_display-&gt;modm_architecture_accessor modm_io modm: io modm_ui_display-&gt;modm_io modm_math_geometry modm: math: geometry modm_ui_display-&gt;modm_math_geometry modm_math_utils modm: math: utils modm_ui_display-&gt;modm_math_utils modm_ui_color modm: ui: color modm_ui_display-&gt;modm_ui_color </p>"},{"location":"reference/module/modm-ui-gui/","title":"Graphical User Interface","text":"<p>lbuild module: <code>modm:ui:gui</code></p> <p>Various classes for creating GUI applications.</p>"},{"location":"reference/module/modm-ui-gui/#dependencies","title":"Dependencies","text":"<p> modm:ui:gui modm_ui_gui modm: ui: gui modm_container modm: container modm_ui_gui-&gt;modm_container modm_debug modm: debug modm_ui_gui-&gt;modm_debug modm_processing_timer modm: processing: timer modm_ui_gui-&gt;modm_processing_timer modm_ui_display modm: ui: display modm_ui_gui-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-ui-led/","title":"LED Animation and Gamma Correction","text":"<p>lbuild module: <code>modm:ui:led</code></p> <p>Header: <code>#include &lt;modm/ui/led.hpp&gt;</code></p> <p>This module provides abstractions for animating LEDs by wrapping the modm:ui:animation module and providing look-up tables for performing gamma correction of LED brightness.</p> <p>The main functionality is part of the <code>modm::ui::Led</code> class, which provides a basic interface to fade an LED with an 8-bit value. Note that this class does not do any gamma correction on it's own, it just wraps an 8-bit <code>modm::ui::Animation</code> and a 8-bit value.</p> <p>You must provide a function handler which gets called whenever the LED value needs updating, at most every 1ms, but only when the value has actually changed. The implementation of this function is up to you.</p> <pre><code>void led_handler(uint8_t brightness)\n{\n    // LED control implementation = brightness\n}\nmodm::ui::Led led_function(led_handler);\n// You may also use a lambda function for brevity\nmodm::ui::Led led_lambda([](uint8_t brightness)\n{\n    // LED control implementation = brightness\n});\n</code></pre>"},{"location":"reference/module/modm-ui-led/#animating-leds","title":"Animating LEDs","text":"<p>To animate the LED you need to call the <code>modm::ui::Led::update()</code> member function regularly. The function updates the LED value at most every 1ms, however you may call it more often than that. If the function is called less regularly, it will automatically catch up the skipped milliseconds, and execute the brightness handler at most once if the value has changed. Depending on how smooth you require your animation to be, you may call the update function with intervals of up to 250ms.</p> <p>You can also pass the <code>modm::ui::Led</code> class directly into the <code>modm::ui::KeyFrameAnimation</code> class and it's derivatives, to animate it's brightness by interpolating between key frames. Note that you only need to call the <code>update()</code> member of the animator!</p> <pre><code>modm::ui::Led led;\nmodm::ui::Indicator&lt;uint8_t&gt; indicator(led);\nindicator.start();\n\nwhile (true)\n{\n    indicator.update();\n}\n</code></pre> <p>If you want to animate a lot of LEDs it is more efficient to execute all update methods inside a 1ms <code>modm::PeriodicTimer</code>:</p> <pre><code>modm::PeriodicTimer update_timer(1);\n\nwhile (true)\n{\n    if (update_timer.execute())\n    {\n        led1.update();\n        led2.update();\n        // ...\n        ledN.update();\n    }\n}\n</code></pre>"},{"location":"reference/module/modm-ui-led/#using-gamma-correction","title":"Using Gamma Correction","text":"<p>In order to map the linearly animated brightness value to a gamma-corrected value, this module by default generates look-up tables for a gamma value of 2.2 mapping from a 256 input range to 7, 8, 10, 12 and 16 bit resolution output ranges. The generated tables have this naming schema: <code>modm::ui::table{gamma}_{output_bits}_{input_range}</code>.</p> <p>For example, you can set up a timer to output 16-bit PWM to drive your LED, and use the <code>modm::ui::table22_16_256</code> table to map the linear LED animation values to a gamma corrected 16-bit value:</p> <pre><code>modm::ui::Led led_timer([](uint8_t brightness)\n{\n    Timer4::setCompareValue(1, modm::ui::table22_16_256[brightness]);\n});\n</code></pre> <p>You may also generate other tables using the module options, for example, if you want to map a percentage (0-100%) to LED brightness, without scaling this to the full 256 value range, you can also generate a 100 value look-up table:</p> <pre><code>&lt;option name=\"modm:ui:led:range\"&gt;100,256&lt;/option&gt;\n&lt;option name=\"modm:ui:led:bit\"&gt;8,16&lt;/option&gt;\n</code></pre> <p>This module generated the product of these options, in this case 4 look-up tables. The linker will throw out those you don't use.</p> <pre><code>namespace modm::ui\n{\n    /// 2.2 gamma correction with 8-bit resolution (0 to 255) in 100 steps at 100 bytes.\n    extern modm::accessor::Flash&lt;uint8_t&gt; table22_8_100;\n    /// 2.2 gamma correction with 8-bit resolution (0 to 255) in 256 steps at 256 bytes.\n    extern modm::accessor::Flash&lt;uint8_t&gt; table22_8_256;\n    /// 2.2 gamma correction with 16-bit resolution (0 to 65535) in 100 steps at 200 bytes.\n    extern modm::accessor::Flash&lt;uint16_t&gt; table22_16_100;\n    /// 2.2 gamma correction with 16-bit resolution (0 to 65535) in 256 steps at 512 bytes.\n    extern modm::accessor::Flash&lt;uint16_t&gt; table22_16_256;\n}\n</code></pre> <p>You can then animate your LED in the 0-99 value range:</p> <pre><code>modm::ui::Led led_percentage([](uint8_t brightness)\n{\n    if (brightness &gt;= 100) brightness = 99;\n    Timer4::setCompareValue(1, modm::ui::table22_16_100[brightness]);\n});\nuint8_t percent = 50;\n// fade to 50% brightness within 1 second\nled_percentage.fadeTo(percent, 1000);\n</code></pre> <p>Note that you can also use the handler to animate LEDs which are connected externally, for example, via a WS2812 LED chain. Here you can use a helper function to map the values into an array which then transferred into the WS2812 LED chain.</p> <pre><code>uint8_t ws2812_values[3];\nvoid ws2812_setter(uint8_t index, uint8_t brightness)\n{\n    ws2812_values[index] = modm::ui::table22_8_256[brightness];\n}\n// Construct an array of LED animators\nmodm::ui::Led leds[3] =\n{\n    { [](uint8_t b) { ws2812_setter(0, b); } },\n    { [](uint8_t b) { ws2812_setter(1, b); } },\n    { [](uint8_t b) { ws2812_setter(2, b); } },\n};\n// Group them together as one RGB LED\nmodm::ui::RgbLed rgb(leds[1], leds[0], leds[2]);\n// animate to orange within 2 seconds\nrgb.fadeTo(modm::ui::Rgb(95, 177, 147), 2000);\n</code></pre>"},{"location":"reference/module/modm-ui-led/#options","title":"Options","text":""},{"location":"reference/module/modm-ui-led/#bit","title":"bit","text":"<p>Resolution of target values</p> <p>Default: <code>{12, 16, 7, 8}</code> Inputs: <code>[2 ... 16]</code> </p>"},{"location":"reference/module/modm-ui-led/#gamma","title":"gamma","text":"<p>Gamma correction of values</p> <p>Default: <code>{2.2}</code> Inputs: <code>[1.0 ... 3.0]</code> </p>"},{"location":"reference/module/modm-ui-led/#range","title":"range","text":"<p>Range of input values</p> <p>Default: <code>{256}</code> Inputs: <code>[2 ... 1024]</code> </p>"},{"location":"reference/module/modm-ui-led/#dependencies","title":"Dependencies","text":"<p> modm:ui:led modm_ui_led modm: ui: led modm_architecture_accessor modm: architecture: accessor modm_ui_led-&gt;modm_architecture_accessor modm_architecture_clock modm: architecture: clock modm_ui_led-&gt;modm_architecture_clock modm_processing_timer modm: processing: timer modm_ui_led-&gt;modm_processing_timer modm_ui_animation modm: ui: animation modm_ui_led-&gt;modm_ui_animation modm_ui_color modm: ui: color modm_ui_led-&gt;modm_ui_color </p>"},{"location":"reference/module/modm-ui-menu/","title":"Display Menu","text":"<p>lbuild module: <code>modm:ui:menu</code></p> <p>Simple to use classes for implementing menu structures on graphic displays.</p> <p>Some convenience classes for implementing menus. The menus are using a stack to allow stepping forward and backwards through the screens.</p> <p>The menus are based on the usage of five buttons. Inside most of the screens these buttons have the following functions:</p> <ul> <li>Left: Go back one screen.</li> <li>Right: Go to next screen.</li> <li>Up: Go to previous selected entry on screen</li> <li>Down: Go to next entry on screen</li> <li>OK: Edit selected entry</li> </ul> <p>Warning</p> <p>Some classes currently only work with the font <code>modm::font::FixedWidth5x8</code>!</p>"},{"location":"reference/module/modm-ui-menu/#dependencies","title":"Dependencies","text":"<p> modm:ui:menu modm_ui_menu modm: ui: menu modm_communication_xpcc modm: communication: xpcc modm_ui_menu-&gt;modm_communication_xpcc modm_container modm: container modm_ui_menu-&gt;modm_container modm_processing_timer modm: processing: timer modm_ui_menu-&gt;modm_processing_timer modm_ui_display modm: ui: display modm_ui_menu-&gt;modm_ui_display </p>"},{"location":"reference/module/modm-ui-time/","title":"Date and Time","text":"<p>lbuild module: <code>modm:ui:time</code></p>"},{"location":"reference/module/modm-ui-time/#dependencies","title":"Dependencies","text":"<p> modm:ui:time modm_ui_time modm: ui: time modm_architecture_accessor modm: architecture: accessor modm_ui_time-&gt;modm_architecture_accessor </p>"},{"location":"reference/module/modm-ui/","title":"User interface","text":"<p>lbuild module: <code>modm:ui</code></p> <p>Interfacing with human users. Contains code for Graphics, Buttons, LEDs, Animations, Menu Structures.</p>"},{"location":"reference/module/modm-unittest/","title":"Unit Tests","text":"<p>lbuild module: <code>modm:unittest</code></p> <p>Lightweight library for on-device unit testing.</p>"},{"location":"reference/module/modm-unittest/#dependencies","title":"Dependencies","text":"<p> modm:unittest modm_unittest modm: unittest modm_architecture_accessor modm: architecture: accessor modm_unittest-&gt;modm_architecture_accessor modm_io modm: io modm_unittest-&gt;modm_io </p>"},{"location":"reference/module/modm-utils/","title":"Utilities","text":"<p>lbuild module: <code>modm:utils</code></p>"},{"location":"reference/module/modm-utils/#dependencies","title":"Dependencies","text":"<p> modm:utils modm_utils modm: utils modm_architecture_assert modm: architecture: assert modm_utils-&gt;modm_architecture_assert </p>"}]}